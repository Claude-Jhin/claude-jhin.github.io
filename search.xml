<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎来到Claude的个人博客</title>
    <url>/2022/03/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<ul>
<li>Claude是谁？</li>
</ul>
<p>Claude是一名潜心游戏研发的开发者，致力于研究游戏开发中的种种技术，包括编程、渲染、动画、玩法等等。<br />
目前在做虚幻引擎的学习和研究，希望有一天能够引导做出自己的3A大作。</p>
<p>更多信息，可以点击右侧 <code>关于</code></p>
<ul>
<li>为什么要建立自己的博客网站呢？</li>
</ul>
<p>主要是希望能够通过这样一种方式作为自身能力的展示。作为游戏开发流水线中的程序一角，与策划和美术不同的是，程序除了游戏作品以外，很难拿出能够显示自身实力的东西，类似美术工作者的作品集和策划工作者的设定文案之类的。</p>
<p>所以自己这才想到去建立这样一个博客网站，一方面记录自己在游戏开发之路上所积累的技术点滴，另一方面也想要把一些东西共享出来。</p>
<p>此前自己已经在csdn和知乎上进行了一定量的博客文章撰写，但是考虑到有一些私人的东西希望自己管理，遂花了一些时间研究前端的内容，并且就一个方案（hexo框架）来实际落地自己的想法。</p>
<p>这第一篇文章，就把自己此时完成建站时的所思所想，记录下来。</p>
]]></content>
  </entry>
  <entry>
    <title>虚幻的细节</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<p>怎样才能说明你学会了某样东西呢？</p>
<p>通读了文档？学习了某篇超长的教程？还是成功做出了某个效果？</p>
<p>虚幻的官方文档篇幅甚巨，如果静下心来通读的话估计也就需要几周的时间；<br />
使用虚幻引擎的教程现在也非常多，其中时长最长者看完也不过几天。</p>
<p>就以虚幻引擎为例，现在基本大家都知道虚幻的lumen，nanite，更深入一点的像GameFeature，世界划分等。<br />
这些信息可以从很多来源获取到，比如我们去读某篇博主的文章，可能会介绍到ue5引入了lumen，它在提供全局光照支持方面提供了多少的便捷，<br />
但是真正这其中的细节有多少呢？我们仅仅需要知道的是引擎内lumen的勾选框在哪个位置吗？</p>
<p>笔者的观点是，我们对某项东西水平的高低，不在于泛泛而谈其功能，而是看所掌握的细节之多少。<br />
了解lumen能够做到什么只是第一步，了解其局限性，了解lumen如何与其他模块（如nanite）协作，等等，才能够让我们对其看得更加透彻，这样才能更加灵活得使用，甚至更进一步，自己去更具需要进行修改和调整。</p>
<p>这也是本篇文章的出发点。本文主要记录在使用虚幻引擎时所遇到、想到的细节。<br />
在文章的初期，内容会比较零散，在渐入佳境后，获得一定的积累量后，博主会尝试对已有内容进行重新组织和分类，使内容更具阅读性。</p>
<span id="more"></span>
<ol>
<li>构造脚本<code>Construction Script</code>的调用时机</li>
</ol>
<p>构造脚本入口节点被包含在构造脚本函数图表中，当把一个Actor添加到关卡中或当一个现有Actor在关卡中发生变化（移动，重新Compile时）会执行该事件。</p>
<ol start="2">
<li>宏<code>check(...)</code></li>
</ol>
<p>如PlayerController里：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">check</span>(PlayerInput);</span><br></pre></td></tr></table></figure>
<p>其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> check(expr)				UE_CHECK_IMPL(expr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Technically we could use just the _F version (lambda-based) for asserts</span></span><br><span class="line"><span class="comment">// both with and without formatted messages. However MSVC emits extra</span></span><br><span class="line"><span class="comment">// unnecessary instructions when using a lambda; hence the Exec() impl.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UE_CHECK_IMPL(expr) \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span>(UNLIKELY(!(expr))) \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">            struct Impl \</span></span><br><span class="line"><span class="meta">            &#123; \</span></span><br><span class="line"><span class="meta">                static void FORCENOINLINE UE_DEBUG_SECTION ExecCheckImplInternal() \</span></span><br><span class="line"><span class="meta">                &#123; \</span></span><br><span class="line"><span class="meta">                    FDebug::CheckVerifyFailedImpl(#expr, __FILE__, __LINE__, PLATFORM_RETURN_ADDRESS(), TEXT(<span class="string">&quot;&quot;</span>)); \</span></span><br><span class="line"><span class="meta">                &#125; \</span></span><br><span class="line"><span class="meta">            &#125;; \</span></span><br><span class="line"><span class="meta">            Impl::ExecCheckImplInternal(); \</span></span><br><span class="line"><span class="meta">            PLATFORM_BREAK(); \</span></span><br><span class="line"><span class="meta">            CA_ASSUME(false); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNLIKELY(x)			(!!(x))</span></span><br></pre></td></tr></table></figure>
<p>即如果expr为false，则会去执行内定的检查，并且停止执行程序。</p>
<p>参考：<a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Assertions/">虚幻 4.26 Documentation - Assertions</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
      </tags>
  </entry>
  <entry>
    <title>ActionRPG中的Gameplay Ability System拆解（更新中）</title>
    <url>/2022/04/07/ActionRPG%E4%B8%AD%E7%9A%84Gameplay-Ability-System%E6%8B%86%E8%A7%A3/</url>
    <content><![CDATA[<p>本文是对虚幻官方Gameplay Ability System（GAS）的示例项目ActionRPG的详细代码向拆解，<br />
将会涵盖GAS在代码和蓝图方面的各项配置和应用，旨在通过分析GAS的各种细节而掌握GAS的用法，<br />
为未来的游戏项目做准备。</p>
<p>关于方法，我希望是以工匠的态度，细致入微得深入代码的骨髓中，<br />
具体做法就是逐代码得阅读和分析，可能会加入一定量GAS以外的内容，所以本文的内容可能会非常庞大。<br />
我并不想在文章体量上做任何妥协，<br />
因为本文除了作为这次的研究学习成果外，<br />
也希望能作为未来一段时间使用GAS及虚幻引擎内其他与之相关的内容的参考文档。</p>
<span id="more"></span>
<h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2>
<h3 id="actionrpg"><a class="markdownIt-Anchor" href="#actionrpg"></a> ActionRPG</h3>
<p><code>ActionRPG.h</code>头文件会被项目中的所有头文件所包含，所以如果有什么所有类都需要用到的东西的话，<br />
放在这里是最合适的。</p>
<p>其内包含了两个重要的头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EngineMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Engine.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>EngineMinimal.h</code>中是一系列重要头文件的包含，截取一些我们常用的列举如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UObject core</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreUObject.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Actor based classes</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Controller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ActorComponent based classes</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/ActorComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SceneComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/StaticMeshComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/InputComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Other</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/World.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/StaticMesh.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>正如其命名，它是我们开发游戏时所需要用到的模块的一个最小（minimal）集合。<br />
与之相对的，<code>Engine.h</code>是一个更加大而且全的包含，内容量大概是<code>EngineMinimal.h</code>的三倍之多，<br />
所以相对应的，如果是包含<code>Engine.h</code>会直接包含更多的模块，但是相应的编译速度也会大大减慢。</p>
<p>接下来<code>ActionRPG.h</code>内还做了一个事情就是声明并且定义全局的Log Category，<br />
Category会在Log中体现出来，以便在茫茫Log中更容易区分其作用或所属模块。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_LOG_CATEGORY_EXTERN</span>(LogActionRPG, Log, All);</span><br></pre></td></tr></table></figure>
<p>对应在在<code>ActionRPG.cpp</code>中有其定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_LOG_CATEGORY</span>(LogActionRPG);</span><br></pre></td></tr></table></figure>
<p>两者成对存在，这样在包含该头文件的文件中就可以使用<code>UE_LOG(LogTemp, Warning, TEXT(&quot;Your message&quot;));</code>来进行日志的打印。</p>
<p>此外，在<code>ActionRPG.cpp</code>中还进行了一个工作，即<code>IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, ActionRPG, &quot;ActionRPG2022&quot; );</code>，<br />
是对本模块进行注册，并指定为主模块，UBT（UnrealBuildTool）会将其编译为对应的模块。</p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>C++</tag>
        <tag>GAS</tag>
        <tag>Gameplay</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 119 杨辉三角 II</title>
    <url>/2022/04/15/LeetCode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-II/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
</font>
<font color=#999AAA >
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
</font>
<p></p>
<ul>
<li>示例 1:<br />
输入: rowIndex = 3<br />
输出: [1,3,3,1]</li>
<li>示例 2:<br />
输入: rowIndex = 0<br />
输出: [1]</li>
<li>示例 3:<br />
输入: rowIndex = 1<br />
输出: [1,1]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/pascals-triangle-ii">https://leetcode-cn.com/problems/pascals-triangle-ii</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>与118题一样，只不过答案更加简化，只需要给出目标行数的数组即可。</p>
<p>所以可以不用二维数组，而直接使用两个数组来交替换行即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vCur = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vPre = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vPre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vCur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= rowIndex; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vPre.<span class="built_in">resize</span>(i);</span><br><span class="line">            vPre = vCur;</span><br><span class="line">            vCur.<span class="built_in">resize</span>(i+<span class="number">1</span>);</span><br><span class="line">            vCur[<span class="number">0</span>] = vCur[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                vCur[j] = vPre[j<span class="number">-1</span>]+vPre[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vCur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="LeetCode119_result.png" alt="" /></p>
<p>复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>w</mi><mi>I</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(rowIndex)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻代码中支持反射的说明符关键字——USTRUCT篇</title>
    <url>/2022/04/13/%E8%99%9A%E5%B9%BB%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%94%AF%E6%8C%81%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94USTRUCT%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻代码中支持反射的说明符关键字——UFUNCTION篇（更新中）</title>
    <url>/2022/04/13/%E8%99%9A%E5%B9%BB%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%94%AF%E6%8C%81%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94UFUNCTION%E7%AF%87/</url>
    <content><![CDATA[<p>虚幻引擎代码纷繁复杂，一定程度上就是因为从UObject开始架构的这套反射系统，<br />
它在带给我们优秀的反射机制的同时，也让代码的阅读及编写有了一定的门槛。</p>
<p>本篇文章的目的，就希望通过拆解虚幻中说明符关键字的这一环，帮助更多人逐步消解跨过这一道门槛。</p>
<p>本文是系列文章中针对UFUNCTION中涉及到的说明符关键字的解释。</p>
<span id="more"></span>
<h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="拆解"><a class="markdownIt-Anchor" href="#拆解"></a> 拆解</h2>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/GameplayArchitecture/Functions/Specifiers/">虚幻 4.26 Documentation - Function Specifiers</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
        <tag>反射</tag>
        <tag>关键字</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻代码中支持反射的说明符关键字——UCLASS篇（更新中）</title>
    <url>/2022/04/13/%E8%99%9A%E5%B9%BB%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%94%AF%E6%8C%81%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94UCLASS%E7%AF%87/</url>
    <content><![CDATA[<p>虚幻引擎代码纷繁复杂，一定程度上就是因为从UObject开始架构的这套反射系统，<br />
它在带给我们优秀的反射机制的同时，也让代码的阅读及编写有了一定的门槛。</p>
<p>本篇文章的目的，就希望通过拆解虚幻中说明符关键字的这一环，帮助更多人逐步消解跨过这一道门槛。</p>
<p>本文是系列文章中针对UCLASS中涉及到的说明符关键字的解释。</p>
<span id="more"></span>
<h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Within=OuterClassName</td>
<td>此类的对象无法在<code>OuterClassName</code>对象的实例之外存在。这意味着，要创建此类的对象，需要提供<code>OuterClassName</code>的一个实例作为其<code>Outer</code>对象。</td>
</tr>
<tr>
<td>config=ConfigName</td>
<td>指示此类可在配置文件（.ini）中存储数据。如果存在任何使用<code>config</code>或<code>globalconfig</code>说明符声明的类属性，此说明符将使这些属性存储在指定的配置文件中。此说明符会传播到所有子类并且无法使此说明符无效，但是子类可通过重新声明<code>config</code>说明符并提供不同的<code>ConfigName</code>来更改配置文件。常见的<code>ConfigName</code>值是&quot;Engine&quot;、“Editor”、“Input&quot;和&quot;Game”。</td>
</tr>
<tr>
<td>transient</td>
<td>此类的对象不会被保存到磁盘。常当与不持久的特定种类的native类配合使用。此说明符会传播到子类，但是可由<code>NonTransient</code>说明符覆盖。</td>
</tr>
</tbody>
</table>
<h2 id="拆解"><a class="markdownIt-Anchor" href="#拆解"></a> 拆解</h2>
<h3 id="withinouterclassname-configconfigname-transient"><a class="markdownIt-Anchor" href="#withinouterclassname-configconfigname-transient"></a> Within=OuterClassName, config=ConfigName, transient</h3>
<p>研究来源：PlayerInput.h中的UPlayerInput类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(Within=PlayerController, config=Input, transient)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> UPlayerInput : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Generic bindings of keys to Exec()-compatible strings for development purposes only */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config)</span><br><span class="line">	TArray&lt;<span class="keyword">struct</span> <span class="title class_">FKeyBind</span>&gt; DebugExecBindings;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/** List of Axis Mappings that have been inverted */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config)</span><br><span class="line">	TArray&lt;FName&gt; InvertedAxis;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Within=PlayerController表明UPlayerInput的对象不能在PlayerController的对象之外存在，<br />
实际上意味着我们不能够随随便便在某处new一个UPlayerInput出来，属于服务于代码规范和框架规范的说明符。</p>
<p>config=Input表明UPlayerInput会对Input.ini配置文件进行数据存储，<br />
<code>DebugExecBindings</code>和<code>InvertedAxis</code>即是要存储的属性。</p>
<p>transient表明UPlayerInput的对象不会被保存到磁盘，</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/GameplayArchitecture/Classes/Specifiers/">虚幻 4.26 Documentation - Class Specifiers</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
        <tag>反射</tag>
        <tag>关键字</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻代码中支持反射的说明符关键字——UPROPERTY篇（更新中）</title>
    <url>/2022/04/13/%E8%99%9A%E5%B9%BB%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%94%AF%E6%8C%81%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94UPROPERTY%E7%AF%87/</url>
    <content><![CDATA[<p>虚幻引擎代码纷繁复杂，一定程度上就是因为从UObject开始架构的这套反射系统，<br />
它在带给我们优秀的反射机制的同时，也让代码的阅读及编写有了一定的门槛。</p>
<p>本篇文章的目的，就希望通过拆解虚幻中说明符关键字的这一环，帮助更多人逐步消解跨过这一道门槛。</p>
<p>本文是系列文章中针对UPROPERTY中涉及到的说明符关键字的解释。</p>
<span id="more"></span>
<h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="拆解"><a class="markdownIt-Anchor" href="#拆解"></a> 拆解</h2>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/GameplayArchitecture/Properties/Specifiers/">虚幻 4.26 Documentation - Property Specifiers</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
        <tag>反射</tag>
        <tag>关键字</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 118 杨辉三角</title>
    <url>/2022/04/13/LeetCode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">数学推导，动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
</font>
<font color=#999AAA >
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
</font>
<p></p>
<ul>
<li>示例 1:<br />
输入: numRows = 5<br />
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</li>
<li>示例 2:<br />
输入: numRows = 1<br />
输出: [[1]]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/pascals-triangle">https://leetcode-cn.com/problems/pascals-triangle</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="数学推导动态规划"><a class="markdownIt-Anchor" href="#数学推导动态规划"></a> 数学推导，动态规划</h2>
<p>数组的每一层都可以由上一层推导而来，简化公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">v[i][j+1] = v[i-1][j] + v[i-1][j+1];
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为行数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>为列数。</p>
<p>此外，注意边界条件即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v0 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(v0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(v1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(i+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; i)</span><br><span class="line">                &#123;</span><br><span class="line">                    v[j+<span class="number">1</span>] = res[i<span class="number">-1</span>][j] + res[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="LeetCode118_result.png" alt="" /><br />
复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>R</mi><mi>o</mi><mi>w</mi><msup><mi>s</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(numRows^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，基本上是数组空间大小这一数量级<br />
空间复杂度：开辟辅助数组所出现的消耗，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻5新特性之AbilitySystemGameFeatureActions</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BAbilitySystemGameFeatureActions/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻5新特性之世界分区</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%96%E7%95%8C%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之资源处理</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之编译系统</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之Slate</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BSlate/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之图形编程</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之OnlineSubSystem</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BOnlineSubSystem/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之Actor</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BActor/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之多人游戏与网络复制</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之调试工具</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之性能分析</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之本地化</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之行为树</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之数据驱动</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之原生Input</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8E%9F%E7%94%9FInput/</url>
    <content><![CDATA[<p>输入是游戏交互中非常重要的一环，输入处理本质上是让机器读取、理解人的某项操作。这个过程是否完善，是否符合人的直观认知，直接影响一款游戏的操作手感，从而影响到游戏的品质。</p>
<p>虚幻引擎内置实现了一套原生的Input模块，在多个版本一直沿用，同时在实际项目中，又会被具体项目组进行定制，从而衍生了一定量的输入补充插件。</p>
<p>本文的目的不在于那些衍生的针对输入的代码插件或者蓝图插件，而是着眼于虚幻底层的输入部分，看看原生的输入部分的代码，也为以后的使用、改写和扩展建立理论基础。</p>
<span id="more"></span>
<h2 id="playerinput"><a class="markdownIt-Anchor" href="#playerinput"></a> PlayerInput</h2>
<p>PlayerInput对象主要负责的是对玩家的输入数据的处理，是虚幻接收外部硬件输入并将信号处理后转入内部的一个中间模块。</p>
<p>PlayerInput主要是在PlayerController里发挥管理作用， 在类定义的时候已经用关键字<code>Within=PlayerController</code>进行标记，表示其对象是存在于和PlayerController的对象实例里的，这意味着不可以随随便便去创建其他的PlayerInput。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(Within=PlayerController, config=Input, transient)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> UPlayerInput : <span class="keyword">public</span> UObject</span><br></pre></td></tr></table></figure>
<p>PlayerInput中，又声明了两个数组，<code>FInputActionKeyMapping</code>数组和<code>FInputAxisKeyMapping</code>数组，分别定义了动作映射<code>ActionMappings</code>和轴映射<code>AxisMappings</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** This player&#x27;s version of the Action Mappings */</span></span><br><span class="line">TArray&lt;<span class="keyword">struct</span> <span class="title class_">FInputActionKeyMapping</span>&gt; ActionMappings;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** This player&#x27;s version of Axis Mappings */</span></span><br><span class="line">TArray&lt;<span class="keyword">struct</span> <span class="title class_">FInputAxisKeyMapping</span>&gt; AxisMappings;</span><br></pre></td></tr></table></figure>
<p>结构体<code>FInputActionKeyMapping</code>，其中又有两个属性<code>ActionName</code>和<code>Key</code>，分别表示的是该输入绑定的动作名称和相应按键，其余属性均为组合按键的选项（如shift + 按键，来表示奔跑的指令）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Defines a mapping between an action and key </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="built_in">USTRUCT</span>( BlueprintType )</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FInputActionKeyMapping</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Friendly name of action, e.g &quot;jump&quot; */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	FName ActionName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** true if one of the Shift keys must be down when the KeyEvent is received to be acknowledged */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	uint8 bShift:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** true if one of the Ctrl keys must be down when the KeyEvent is received to be acknowledged */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	uint8 bCtrl:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** true if one of the Alt keys must be down when the KeyEvent is received to be acknowledged */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	uint8 bAlt:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** true if one of the Cmd keys must be down when the KeyEvent is received to be acknowledged */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	uint8 bCmd:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Key to bind it to. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	FKey Key;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体<code>FInputAxisKeyMapping</code>，其中也有两个属性<code>AxisName</code>和<code>Key</code>，分别表示的是该输入绑定的轴名称和相应按键，<code>Scale</code>属性用来给出具体值（相比于Action的离散触发，Axis则是连续的监听）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Defines a mapping between an axis and key </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="built_in">USTRUCT</span>( BlueprintType )</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FInputAxisKeyMapping</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Friendly name of axis, e.g &quot;MoveForward&quot; */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	FName AxisName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Multiplier to use for the mapping when accumulating the axis value */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	<span class="type">float</span> Scale;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Key to bind it to. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	FKey Key;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个结构体中都涉及到了同一个类（结构体）——<code>FKey</code>，它的定义位于<code>InputCoreTypes</code>中，其本质就是硬件输入的定义。</p>
<p>如图，经由虚幻内部的反射机制，将属性<code>ActionMappings</code>和属性<code>AxisMappings</code>序列化到Editor里，并且可以自定义，添加映射等等。添加绑定的过程实际上就是在对ActionName/AxisName和FKey写入的过程（还有其他属性如组合按键和Scale也在Editor界面里有体现）。</p>
<p><img src="Input_ActionMappings.png" alt="" /></p>
<p>上述，基本可以描绘出游戏按键到行为的建立映射的过程，当然到这一步，我们也仅仅是将映射的概念建立起来，接下来就需要为特定的映射绑定具体的行为了，这就是InputComponent所承担的任务了。</p>
<h2 id="inputcomponent"><a class="markdownIt-Anchor" href="#inputcomponent"></a> InputComponent</h2>
<p>InputComponent直接继承自ActorComponent，对象可以对Input.ini进行写入。</p>
<p>PlayerController里是维护着一个InputComponent的栈，而核心的处理逻辑实际上都在PlayerInput里。关于这一点，后面我们会细谈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implement an Actor component for input bindings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An Input Component is a transient component that enables an Actor to bind various forms of input events to delegate functions.  </span></span><br><span class="line"><span class="comment"> * Input components are processed from a stack managed by the PlayerController and processed by the PlayerInput.</span></span><br><span class="line"><span class="comment"> * Each binding can consume the input event preventing other components on the input stack from processing the input.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>(transient, config=Input, hidecategories=(Activation, <span class="string">&quot;Components|Activation&quot;</span>))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> UInputComponent: <span class="keyword">public</span> UActorComponent</span><br></pre></td></tr></table></figure>
<h3 id="actor内的inputcomponent"><a class="markdownIt-Anchor" href="#actor内的inputcomponent"></a> Actor内的InputComponent</h3>
<p>InputComponent在Pawn和Controller上非常常见，但实际上，其实Actor上就有在维护InputComponent相关的东西：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> AActor : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** If true, all input on the stack below this actor will not be considered */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Input)</span><br><span class="line">	uint8 bBlockInput:<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Automatically registers this actor to receive input from a player. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category=Input)</span><br><span class="line">	TEnumAsByte&lt;EAutoReceiveInput::Type&gt; AutoReceiveInput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** The priority of this input component when pushed in to the stack. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category=Input)</span><br><span class="line">	int32 InputPriority;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Component that handles input for this actor, if input is enabled. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(DuplicateTransient)</span><br><span class="line">	TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">UInputComponent</span>&gt; InputComponent;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actor上序列化出来的属性如图。默认情况下，Actor是不会接收用户输入的，即按图中配置Actor是不会响应PlayerInput设定好的输入事件的，但若是希望此Actor响应用户输入的话（在此Actor上使用输入事件，并使其实时响应），则需要修改<code>AutoReceiveInput</code>的值为<code>Player0</code>。</p>
<p><img src="Input_InputOnActor.png" alt="" /></p>
<p>相应的判定代码如下，该函数是在Actor生成的时候去调用的，主要就是在关卡一级进行Actor的输入管理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AActor::PreInitializeComponents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (AutoReceiveInput != EAutoReceiveInput::Disabled)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> int32 PlayerIndex = <span class="built_in">int32</span>(AutoReceiveInput.<span class="built_in">GetValue</span>()) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		APlayerController* PC = UGameplayStatics::<span class="built_in">GetPlayerController</span>(<span class="keyword">this</span>, PlayerIndex);</span><br><span class="line">		<span class="keyword">if</span> (PC)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">EnableInput</span>(PC);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">GetWorld</span>()-&gt;PersistentLevel-&gt;<span class="built_in">RegisterActorForAutoReceiveInput</span>(<span class="keyword">this</span>, PlayerIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="playercontroller内的inputstack"><a class="markdownIt-Anchor" href="#playercontroller内的inputstack"></a> PlayerController内的InputStack</h3>
<p>PlayerController间接继承自Actor，所以会有一个自己的InputComponent，但是同时负责构建和维护一个InputStack（通过Update，Push，Pop等操作）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> APlayerController : <span class="keyword">public</span> AController</span><br><span class="line">&#123;	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TickPlayerInput</span><span class="params">(<span class="type">const</span> <span class="type">float</span> DeltaSeconds, <span class="type">const</span> <span class="type">bool</span> bGamePaused)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ProcessPlayerInput</span><span class="params">(<span class="type">const</span> <span class="type">float</span> DeltaTime, <span class="type">const</span> <span class="type">bool</span> bGamePaused)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildInputStack</span><span class="params">(TArray&lt;UInputComponent*&gt;&amp; InputStack)</span></span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Internal.  Current stack of InputComponents. */</span></span><br><span class="line">	TArray&lt; TWeakObjectPtr&lt;UInputComponent&gt; &gt; CurrentInputStack;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Refresh state specific input components */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UpdateStateInputComponents</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Adds an inputcomponent to the top of the input stack. */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PushInputComponent</span><span class="params">(UInputComponent* Input)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Removes given inputcomponent from the input stack (regardless of if it&#x27;s the top, actually). */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">PopInputComponent</span><span class="params">(UInputComponent* Input)</span></span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ProcessPlayerInput</code>被<code>TickPlayerInput</code>调用（<code>TickPlayerInput</code>又被PlayerTick调用，故是每帧调用），其内部首先会调用<code>BuildInputStack</code>构建输入栈，再去调用<code>PlayerInput-&gt;ProcessInputStack(InputStack, DeltaTime, bGamePaused);</code>，即使用PlayerInput来处理InputStack。</p>
<p>这样基本就构建出输入处理的流程。</p>
<p><img src="Input_InputProcessingProcedure.png" alt="" /></p>
<p>图中的InputComponent存在优先级，即如果前面一层的InputComponent接收了输入（PlayerInput在处理输入时的逻辑），那么堆栈的下方将会无法访问（不会相应输入事件），这个优先级其实就是由<code>BuildInputStack</code>构建输入栈时的压栈顺序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerController::BuildInputStack</span><span class="params">(TArray&lt;UInputComponent*&gt;&amp; InputStack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Controlled pawn gets last dibs on the input stack</span></span><br><span class="line">	APawn* ControlledPawn = <span class="built_in">GetPawnOrSpectator</span>();</span><br><span class="line">	<span class="keyword">if</span> (ControlledPawn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ControlledPawn-&gt;<span class="built_in">InputEnabled</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Get the explicit input component that is created upon Pawn possession. This one gets last dibs.</span></span><br><span class="line">			<span class="keyword">if</span> (ControlledPawn-&gt;InputComponent)</span><br><span class="line">			&#123;</span><br><span class="line">				InputStack.<span class="built_in">Push</span>(ControlledPawn-&gt;InputComponent);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// See if there is another InputComponent that was added to the Pawn&#x27;s components array (possibly by script).</span></span><br><span class="line">			<span class="keyword">for</span> (UActorComponent* ActorComponent : ControlledPawn-&gt;<span class="built_in">GetComponents</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				UInputComponent* PawnInputComponent = <span class="built_in">Cast</span>&lt;UInputComponent&gt;(ActorComponent);</span><br><span class="line">				<span class="keyword">if</span> (PawnInputComponent &amp;&amp; PawnInputComponent != ControlledPawn-&gt;InputComponent)</span><br><span class="line">				&#123;</span><br><span class="line">					InputStack.<span class="built_in">Push</span>(PawnInputComponent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LevelScriptActors are put on the stack next</span></span><br><span class="line">	<span class="keyword">for</span> (ULevel* Level : <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetLevels</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ALevelScriptActor* ScriptActor = Level-&gt;<span class="built_in">GetLevelScriptActor</span>();</span><br><span class="line">		<span class="keyword">if</span> (ScriptActor)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ScriptActor-&gt;<span class="built_in">InputEnabled</span>() &amp;&amp; ScriptActor-&gt;InputComponent)</span><br><span class="line">			&#123;</span><br><span class="line">				InputStack.<span class="built_in">Push</span>(ScriptActor-&gt;InputComponent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">InputEnabled</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		InputStack.<span class="built_in">Push</span>(InputComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Components pushed on to the stack get priority</span></span><br><span class="line">	<span class="keyword">for</span> (int32 Idx=<span class="number">0</span>; Idx&lt;CurrentInputStack.<span class="built_in">Num</span>(); ++Idx)</span><br><span class="line">	&#123;</span><br><span class="line">		UInputComponent* IC = CurrentInputStack[Idx].<span class="built_in">Get</span>();</span><br><span class="line">		<span class="keyword">if</span> (IC)</span><br><span class="line">		&#123;</span><br><span class="line">			InputStack.<span class="built_in">Push</span>(IC);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			CurrentInputStack.<span class="built_in">RemoveAt</span>(Idx--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>这样基本上就将Input相关的代码进行了一遍简要的梳理，其内部的细节、流程基本已经清晰明了。我们在日常编程使用时，接触最多的可能是在Pawn/Character上使用<code>SetupPlayerInputComponent</code>来进行InputComponent的配置，底层的这些流程被封装好我们基本上是看不到的。</p>
<p>有人可能会认为我做这样一番解析工作的意义不大，只要会使用就可以了。出于使用的目的话，确实如此，但是当我们希望更加明了引擎的架构，甚至范围再小一些，希望明了PlayerController，Actor等这些基础类的架构时，一点点的模块化拆解可能反而是更加聪明的做法。</p>
<p>我们当然可以仅仅看一下官方文档里的相应的介绍，但是其字里行间隐藏的机要，不真正去到代码里，只能是看个皮毛。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/5.0/en-US/input/">虚幻 5.0 Documentation - Input</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
        <tag>c++</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之Gameplay游戏框架</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 112 路径总和</title>
    <url>/2022/04/12/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
</font>
<font color=#999AAA >
叶子节点 是指没有子节点的节点。
</font>
<ul>
<li>示例 1：<br />
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br />
输出：true<br />
解释：等于目标和的根节点到叶节点路径如上图所示。</li>
<li>示例 2：<br />
输入：root = [1,2,3], targetSum = 5<br />
输出：false<br />
解释：树中存在两条根节点到叶子节点的路径：<br />
(1 --&gt; 2): 和为 3<br />
(1 --&gt; 3): 和为 4<br />
不存在 sum = 5 的根节点到叶子节点的路径。</li>
<li>示例 3：<br />
输入：root = [], targetSum = 0<br />
输出：false<br />
解释：由于树是空的，所以不存在根节点到叶子节点的路径。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/path-sum">https://leetcode-cn.com/problems/path-sum</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>先将问题简化，看看最简单的情况：</p>
<p>树为空，即根节点为空，那么自然返回false；</p>
<p>树只有根节点，即根节点的左右子树全为空，那么就判断根节点的值和目标值是否相等即可；</p>
<p>再进一步，根节点的左右子树不为空，那么就分别去找左右子树，看看其值是否等于目标值减去根节点所得到的值。</p>
<p>依照这个思路得出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) ||     <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="LeetCode112_result.png" alt="" /></p>
<p>复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：开辟辅助数组所出现的消耗，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻插件之MultiplayerMissionSystem</title>
    <url>/2022/04/10/%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BMultiplayerMissionSystem/</url>
    <content><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>任务系统是串联游戏，为游戏提供强力游玩驱动的有效手段之一， 在传统RPG等游戏中有着非常广泛的应用。<br />
任务系统编辑器的意义就在于能够为创作者提供直观的非代码的界面，使其能够快速的创建一个又一个的任务并合理得安排其顺序或者逻辑， 并且在引擎的帮助下能够快速预览其效果。<br />
本文将就Mission System任务编辑系统，介绍任务编辑涉及到的核心内容。</p>
<span id="more"></span>
<p>（注：本文主要是对任务系统中涉及到的概念进行拆解，结合插件内容演示任务的定义、提示、开始、完成以及日志等等。同时，需要认识到，目前该系统是基于RPG类型游戏进行了高度的定制，所以任务的制作中包含了一定量的RPG要素，如经验等级）</p>
<h2 id="资源获取"><a class="markdownIt-Anchor" href="#资源获取"></a> 资源获取</h2>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/multiplayer-mission-system">https://www.unrealengine.com/marketplace/zh-CN/product/multiplayer-mission-system</a></p>
<p>本文使用的版本是4.26，其他版本可以自行编译使用。</p>
<h2 id="快速上手"><a class="markdownIt-Anchor" href="#快速上手"></a> 快速上手</h2>
<p>本小节内容是为了让读者快速上手使用该系统来进行任务的制作。<br />
本文不包含资源的安装，这里假定读者已经安装成功。</p>
<h3 id="输入模块"><a class="markdownIt-Anchor" href="#输入模块"></a> 输入模块</h3>
<p>输入部分，系统使用了第三人称的模板，所以基本的移动可以参照第三人称模板来操作；此外，还进行了三项操作的扩充——攻击、交互和呼出任务面板；攻击对应鼠标左键，交互对应键盘E建，呼出任务面板对应键盘Tab键。这些按键响应都是实现于PlayerController，并通过核心任务组件（BP_MissionComponent）中定义的事件来作响应。<br />
（注：任务管理器组件也可以挂载在任何位置，但是为了方便访问及网络复制Replication，放在PlayerController上是一个推荐的选择）</p>
<p><img src="MissionSystem_InputResponse.png" alt="" /></p>
<p>UMG的输入提示：</p>
<p><img src="MissionSystem_InputTips.png" alt="" /></p>
<h3 id="任务制定"><a class="markdownIt-Anchor" href="#任务制定"></a> 任务制定</h3>
<p>DT_Missions（Data Table资产）是用来创建、配置和维护任务的核心资产，其本质上是一个数据表，可以直接增加或删除任务（Mission）。Mission代表着一个大的阶段性任务，比如新手教学就可以作为一个任务存在：</p>
<p><img src="MissionSystem_DTMissions.png" alt="" /></p>
<p>其中，除了Mission名称（Name）之外，还可以配置任务是否是可以重复的（Repeatable，影响着任务是否可以重复接取），任务的具体描述（Description，可以反映到UMG上），需要的玩家等级（Level），任务子序列（Sequence），任务完成后的收益（Finished，经验收益以及新增任务等）。</p>
<h3 id="任务拆解"><a class="markdownIt-Anchor" href="#任务拆解"></a> 任务拆解</h3>
<p>假定在新手任务（Startup Mission）中，玩家需要根据指引探索区域，与机关交互解锁新的区域，最后完成新手的简单战斗。根据前文的描述可以将任务差分为三个子任务序列（序列代表着任务之间有着相对顺序，即完成任务一才可以去继续完成任务二，而不可以顺序颠倒）。<br />
将所有子任务序列及其描述依次进行配置（sequence time是任务的限制时间，超时未完成将导致任务失败）：</p>
<p><img src="MissionSystem_Sequences.png" alt="" /></p>
<p>UMG中的子任务序列显示：</p>
<p><img src="MissionSystem_SequenceInUMG.png" alt="" /></p>
<p>Objectives代表了当前子任务序列的目标，即它定义了玩家当前任务的主要玩法。如可以定义玩家的当前任务目标为探索寻路（follow）：</p>
<p><img src="MissionSystem_Objectives.png" alt="" /></p>
<p>其中WidgeType描述了当前任务的UMG展现形式：</p>
<p><img src="MissionSystem_WidgeType.png" alt="" /></p>
<p>对于探索寻路任务（follow），可以使用检查点（Checkpoint）来定义要去的地方（主要是定义一些检查点的核心属性，如显示规则，位置及UI外观等）。<br />
而对于其他任务来说，就需要用到Objective Targets。其中需要自己去添加相应的Target Actor来定义具体的规则，及对应的Actor上需要添加BP_TargetComponent组件，如与特定机关交互的Actor：</p>
<p><img src="MissionSystem_TargetComponent.png" alt="" /></p>
<p>如需要进行击杀的Actor：</p>
<p><img src="MissionSystem_EnemyTargetComponent.png" alt="" /></p>
<h3 id="任务切换"><a class="markdownIt-Anchor" href="#任务切换"></a> 任务切换</h3>
<p>在配置表的最后，当任务完成时，可以配置经验奖励，以及在任务列表里新增的任务，该任务依然可以通过ID查找任务表里的其他任务来实现。</p>
<p><img src="MissionSystem_MissionSwitch.png" alt="" /></p>
<h3 id="任务开始"><a class="markdownIt-Anchor" href="#任务开始"></a> 任务开始</h3>
<p>任务的控制是在任务管理器（BP_MissionComponent）中进行的，可以利用BP_MissionComponent组件方便得进行任务的控制。</p>
<p><img src="MissionSystem_MissionEvent.png" alt="" /></p>
<p>可以简单得在PlayerControler里在BeginPlay时开始之前配置好的任务：</p>
<p><img src="MissionSystem_StartMission.png" alt="" /></p>
<h3 id="接入umg"><a class="markdownIt-Anchor" href="#接入umg"></a> 接入UMG</h3>
<p>BP_MissionComponent中管理着所有的任务数据和日志，包括完成的，未完成的，成功的，失败的，等等。UMG可以方便得访问运行时的任务数据，并予以显示：</p>
<p><img src="MissionSystem_UMGGlobal.png" alt="" /></p>
<p><img src="MissionSystem_UMGLog.png" alt="" /></p>
<h2 id="演示"><a class="markdownIt-Anchor" href="#演示"></a> 演示</h2>
<p><a href="https://www.bilibili.com/video/BV1XY411777M">演示Demo</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>插件</tag>
        <tag>任务系统</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻5新特性之GameFeature</title>
    <url>/2022/04/08/%E8%99%9A%E5%B9%BB5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BGameFeature/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3a2a77867c312dec004b2c52918e1e8a8438362fced4174dd8a0aaa76619b5e6">fa2633a7d743470e974359ef9dad0234f30774894771689c244dd76c90a00c707e2b0b6b53c70c9116e6c04f325fabfebe5d967d3d9c14599e169f7aaa1570c3c38240daf1ae1532d5afb15dba8aa3ea55f48ee2c31074acb32324f723d53439340ac23c855abaedb9d018bcad80aab888877285a993baa1410c66288895a530a704c8ff01d261decedd2f507e784727e814683021ee726001340231967f92768cb15164c1352464f8de6ac20ab2144ae8e2209838abcf791a1a917717c79038f293394e1469b98ede072befa2dc93f1e9c41980d376a1e8b30c153b3e270b15d94fca7d2878f47dde43e203d1341a13a37cf2d45789377b2e63715e8b0c08c4245ec5f80de95a7a934c6d5c44163883d38908731f018d79fefbc1a9fe9b684a550c8ab4d3eddc9515fd033c323d57850aee5ce13bd3d991992ad325654e55a0e562159834abaf45941a8853055b121a3fae25cac87e4be3756d184b999ab8bd76a82b80af8d684b2f6f7b1b94e4a71e970e76d784c503a7d3185aa74168b0507652ddb5c6fc0c2d4a4663e2a2b22643655b995c7d829f4cd1fef4dc4e7798bb1f450c63bc3ef74c5c7ea8cf63d486d1d6132319f8861f7551fc8068f61aaa81cd3510bd8e4bae54ec4b73261683cad36440f786f262cd674bed247e4814a39b2cdedbdfc0107bd05140f87e1efe8db9f1349b82bd2eb39004928407527d75554e30c37ea0d17144dbdd0c551d77501577395e1e1dccd7ef1ccc4803920a78bf742483be62bb345cc94547952bc54c73b16b4c5764c7e95bc5e56462386a52ae71e8d64b5b99210b62cd7bae9dde8ee955ce546d670a199f0970b9f20a9ebcd38a30a88c5c0f9f6a6a36ac0d216c412b8b5eb5499ed3a89c829ef45de8eadaba231a8e9a7a38c39c2437b89d664ceb115255cdbfbdb5e232bc1519a40b70b43ba8663f4cced321b4a8c80eac4c106d166ceb84b58ac9dde9cc037df30d982977bb5a6c16ee6d18d5de086edf2cfacfdb9599b08da331407c4a5e0d529b3e8517a799a40f678138c3d8a7db0b00cd054f3849d3310cba8e30df748e114de29e547c644422968697cf3ed7c3dec370d44fac66ce50b1a7d7262988f9980d7c134561f3a9810e97dfa112e047f942143f7756a41d0f8bfaae906799f1b54ae600da98dce4d4d7ad01363d80932fcb2397b044b9fd1e7123af6f66d9a0b7b1ace75ce9ba42888673de91fb2638ff12057cac127a5fc75a11730d4956667b120b030c364c7bf1477794d3d67e04d5939ca17bb52cb63487759c560bb2212fb9860ccd5c217b6878337c42bb57ef1280d076a7f7072648b1bd6a8b801b62a526f16e45b805f178cceabb79cde86988bd097b4a95239e764ece0aa3b966b66b48ab58fcffef73543a101c4a0187f2f8e5a10aa21f2126549f5e447a56f3704c5f5343a541b143839eef3ae47e700d5480c53e9147fa8799b008ce91643f89a58427187378ecf68a82b11a57b8b128cbb647c53415e4ec867b6a5e3fa95f16a52a17e436ed39bacbd871ea43baecca042b8e2dd15807c3ebb6d4bc1a555368657e042a9d4c6ae8409fdfe131f6e1fcb6042f9c61a49b357fa558e58709843c391d5c48f433660ddad1f96b12455dfd9002ce66579cdb02dc2f566716c771456221f21947e57f5699dc7dad618d6911b63a566d23210e6fc45c104ac395a472923d92a69cdffa01986efe08ca19489f46d684be75272f1ce0a59eb0cf2f1934f3cab65e94638c3d4cc3c1fdb64f99250eff56e68903c18c6413d13623f35a327c6e6a8ac1476a4b5cd36653a557d7e6b0bcb2439ab3c287f2915a630444f7507325bd780ab96736bde0498d6f8db65c88bb846f8b18dd02c381940242a51474c70d6db4773315e339f953ee1daf9db85a9d145c907c6c93639aad67fa5f1cd2102770bf496c662e951849d50d03fecf5a6e25be84556fc3f954f520cc05e677b56581e99cc453fb7a4ec8d20330bd64fceb1bab6a4fa81c5a6aa8dd6f042aefe33d1537eeed29f298075aa1f141808eb96ef04f5fbcb4a72d1bab836318bc05540eb339ca37ff55477923e2ebdb1bccbfe8ac0c78de5f600d7179651fd71abb17a46672587377a719acbde9fb4a60bde385b594e3e3f7f0b0393244b83997e2362d8cee4a1f6d8531a16cdaf715ec66f8a15abd5504fcd5c1a3dfe324ebb405ef6f4ebe20b1705a989291e4762966006ae3d713d6f1dbd6d417e2cc98394744a5eb967a7cad0947e5988b92a0b5a93d6142640fb3c41b711c72702ab7ec47f267918eb3d9abe9dcb8d743c2db4623f50c63a7993d7a0ec5dd0552cd469c81c2640ca1d5cfd59efb26bb22522c2f9e1e1be044bb725ce63ba305f4dec3ba97706bcb253cd0eb4140c3a286bb953dd98e666fc444ef6df563e23adb6d46851f9f09d8d3b85deea8c4102d01f621bb16f29536ed9f01e680d41e4c1c01b139b0e2b2e52738de0d633f2144c64336df5d51e1e6478fd37e0b95710df85be4d1403911138dfc9050afba75668ae763ebe005cf0bc8c2c358a6c34728e2b0548ef59babf436c0fc1504682139b87a2c7b8e1a1afb9cd04af79c35023c69899319d72f249d83f2b2d79f1778fa2f4e6fc828d8a63f542a63a8862ed6e9435251b2fd5760d326bd6873e8aa28c7c8c81cec46957bf331dd39121b3581d26db0cf1469a576f14508623760672982acb3fd8dfa91cf522450bca040852ac9c4a49ebe08d8e7cc384645ce4ebcf3848bf0ab734f7200b7817f2639e911228edca44363a62d06efe8c3d357a2e82ec593868fbe1568221fb1875d8e2abdb9c9b65de6c8acfd391126fa22910cb4acae1500d942c959a3b5ca88b7a3a80f611fcd83ca56b11ff40ab58d8975e01f7b747c5c502eb55dd7588ce3c2bcb4242f9539b2ac144bcf159647f7c3a8f02bf79b4aa079d4890152e7eb0cdac77505e2ff2f990f06f9203893dc92ae813906619d252fd81f3bc427751247f770c09fad2904c97ec6939fccb56147fb559768508025c6fabff2a103df2f441c34b42f922205b5bef223dadf83b1263813d2414947e752a2564ae4831b2856a52497206b4be44c8019e48a6e82780c496a5ef09f8f5adf9660d190f626c62c4be7718b44c4ca1745f91b878920f213f3bc83608799fe0228031bd9c0ef559093c514b8835447f3c2e82fe6996aa076db864a537860bced0197ec17b22a3bf48fe15deb0b5136afff58bafc2ce20dd7a1c1a8352f8816fb5e6c99156d8a826d461352f29b5e20c255656f67a617fb44947e593406575193e7a2a484d555ee4b761cdcd58c7b48f7a7a01ef48ad7c87120e1b6d10ff9c4c801cc29d9dc97070a9686450e552ed0479b4e11ab2bd1b328f53a59159d13044626ce1776a67ad11a26a1efbaaddd4e8b5516953883cf8cc47e008da26af92e3e4dee684586b4cbd727171f58e79782bd5d6911fcd0477b08cd63f5db52ae00dbe6839c61f52daf1e36a56e5566971a7e4de2da7353c050860392a148cd726f754ed14369e8e8bb2339847a4f1e52a29736ce1462ca9d7fdbcda6afbb073ceec5c17c348706d58bd94d0986f8d9b9e4484ab07185e27de459c75ec82744ad617f5360af6541fb6e80573669dfde0ea3bd9d0ff15543f2a5cf52b93bb26b8001c357701c4e0e2170de162c7c38b05cc14d3a9833741bb5e496b9c294e961f7c8c3a0d730685b9e398ce83a1a1bbfb10367b7f207b55404f1913d63a183ce7e80f5c387e5db47c55e949d1a147a47f15d9aacabdef9fd42a076bf98000a8420cc30b864fc625972c58362bef131d50cfd00281cfab1acd74e0b2b2e53d2a89901e3d5568da00359acfd8dc9b8c1bfd6dcb20443da7d7bab787d5e7b083de4f28aab2c24765f9fa91326e29bb5e4c2ba91edf622977c564d69b3fb8c69ec4b21d3dc42a240f186e31ed0070a9c0e5c8394f86cdac9af39ba0280b503b8d4eafaaa6ffd06f58a01c6ccb729b55d20e4ca7f4b97663e1e377a35b7e985fd3be72fcdacba0d925be0c0b1f7054bf3aedb4e8d88456cf04ab0082c1ebc4f9bdbe05fa98c1abf3907b20b3f9612c5825ead83adb10916245bf0dd93fd8e9ffaf02be2d02b182aa828fc06998d7c9530cc9bfa3eb17fc454d09a42cee5dcd1fc6ca3e12efa786518b760491d1d949115d42535f0ebaf361963231c3b4a736d24f6df5f07f5ceb9b395825197da7d2a2972196b21ea0b9378b71e74016c288583ad3170482457011cf8853d05663eb7ac4b6df29f6f54a1a9f60be5878bf460b199a212e235326a5aea8f9d67ffddcbf9d5b427ce44a619365b05649bf858061b743d7f502f9eca78b0e520278ef19a152ee4735aa7818ab8804e4bb6bef9195fd56e7263c0a6aad661795f8a1ec60a2f5a1144edf932c665dc442915564a996217819179a81728aaa4c9a043d4962a0025d998c2b17f2c7aead67a5ec865b49d3a82aa88c62e6ee1274efc1ba9713ef166864bc63898ec521618f451fbb0f8373b6dc4c577fc4137d6c858148acc0ab172a3974f14ba4cf1091a7e775a920b02da836da7b2ae0bb92a20a97e82d52b4e76bce21fbe84a3f34027b5cdc4522fa14423235dadc52ee4c402512c4a93fe8d7c663fbf15f27a6f14c245cfa272023d30e75e720c6862cb8e0b3dc62adf5a4d0debafb54e258026f34aca93eb021ab55ac63e9d89724422811d2d37c05e95c739d6f2ebede3e0330340f5679769f8e09d98e039a593d07cf0dd91d549cb9bcd91c387545f6e7c736213d2fae2ef7f35917da60d5a94ba8d1af9480efb7fef632e76fe4a5e945769fa1ba6754e72ceb4b48cc3d0ffe6c4a04c36637d6f64b70a8df0e3d3f72d0c8aa7bf5319dd0d640337e4e91b1db8577e2a836ff9fcdcb58573483388e66b828557ed9c40790f98a5e0b92259dcbc2ced980ddfa6fc03757a941bb19a2368adcf503194c9e1904749fbe6c0bf1f3cc5ac413a23b5b11dd24abd35f8a45bc7d149139c44193f84ab452c2ca9bea52b432212ad69e10227b5a48a9f79e6f2fd31452e72c9958b0109de5034f09601d7152a5670d81220759bddd9b59c60f70b989c463be4a51df42e3ed5e2e4bc52e261b05c216519353798465af0854b75b4d364d0c82a735dd9d1a0f8552677a3db38ec101dbb520d64d3f0cfd607fb7a515d5bafc18df232e5c160102a4614ca98c5bc9c954ad6c32f917299934e401fb81ff305fe203a2efc7a5f973caf33fc03e06d573d68cc2ba84a73461c1dafc5d2332e321adc4641c59c9182f4515e4427f7d0bf261756ccce90c5489365acdc9812fe284c0e1ec2d152c8face0ad6f393345656baa1d19f29fd8d3e3c449181378d4fdc0d879ff4ded09774e496962b24c3f48ca7977739c052f6060ab7f27ea809b7be60162bcb1be474cd7e5c335ae79cc2989f56e940b45dab2a516978644ad2d1755838ac3118f75b1e7432ac68656aa29dbc71c62a11763c77d4b43adcc96f2ab5d336990ffe49da41b00645ae3d43321c02d00ac5f438ae7a5a37028db422c5ba176075313578743931259faccaa2441bf9b1e92e1c336866557f4853506804ad3f211362e8c166867c36689ffb550ef81aab78dca442428fa4b0464f7a3e97bff50d417b7ce044587aad2077b2ba96dce0aea9c7b7a76f137fa60c9fa493271645079d6337bfaa95ee1ebd5e31a4e05daa7f3c07a6b9299ace3d8c8d9b05817daf266c9d865ddf8a427deaabd9ee41d933f990de0688f0efd8d1d4ffbd098e13819c20c00bd60c36730f6e998cb8754ba7cdf66e61df04544f95d7feee2b11bfb81d0f69cda59d4f1087aa18f1af886211510282234cc83457850e06d958b08af8680ce8ebc4e7a029e866a9cf1e002a79569e9a8ba2506f33c11591ab0a6ef99bac08432ceb1b0bd7763ceeab274d3ea2ada3bacf5757d1a63e78f245e7344c5d627337b630ce70cd0eab25d787cdfcea6d6a3b68a0db9fe24e1c97b91da107a64439c186104f888808401d22acb27b930f5127c9e1d5169e31f3720e9af5da89164408292682bf5d45b7e6e1a926a370509138417e79221195f0c52e279969c9299917f34946369b39e4c315466ce72ff505ae13fb778253c9fc90db61e29d7c7cab1960893234fddff433eaae254c14d5e85fe86c99909d263ce2bdf43262e750428cae299b08765042ae31c21cfc8aee30314bc3762d3b3c628bc0afbd3a9f826d0f869a8a6ffa82d2267d87c5080d6b890506827358d82759a3c1b351cb73512ce125f5b0d9431531f8e51040bcbdd9543429b9f7e493e3ffcba9f1c271444b3095918e59145bed61349416ffdba973808cc090c5e8b5b0f9c1c0533c85bfb56e4640e77aee53e83504d0b224b255c13012a1df4d09e3522ff8193be73c3be31074f2bdc40df1507df88ad87df5d92b34414b4f9060cb4052263820dcc0a822f6014840eb75fca75aa883637b1cad3bd113e498d0bc3cb793bf0711ce066f7ca748a14a63e03e50b042e0b2b6699905ae26ca9c13090c45ae58819777c7dc0deb230f97038ac953e6761a0bb39104bf1516f4fbba719d714b5744fd45eb622bd31db2793d96b5f9c1d96f73d82834704343d32ab30b191a445be9a97aecf3678dabcf967f86c6708e5e07cc92fd3cdfac962048001d5b0d257c7244eadeef215772c95ab76f32dbe05da48c1272100af3e53bcdb4b31d1094f899f61e14c4d142acc6e0ed8eead9e98182950f89db92240f1b2ab2c467e23066a9f244f79aad8c87ae1b0eb21f64bd641243c7a950c54705fc5f2cbe8b97682b9120d560ef85c473f24dca727c0bb5ef4369bfb0ebc2ce4e722aed5c6dfd2b64048b0251e4f7e691ae1b1fb165fd1092a9326bfe31e462545de19b4f069756b503be3660a474148505b93e1fcb5ac612f48ae5bd6524087a79a49b1a3c1d5cf960ef2d118aeac7f46aac9fc0225314b15604936abbd18c7aab20ec1c26842cdb13c30ec00c72b68c2b67b282bad2f7050149254d0521127fdcfa1f914adcfda0be0a18d6f4fb0da638c6fa74f528c454eaaf613350034ae1bdfa71675ef104b1fac68fd7560b44fb96f189d59a8cf4f56a38940d7121abc3e6e5532e9cb88457e0774b469edff5df5eb53901947c77e3454101e787463c7891e7895c51b1168830628c7f8763c3cdab08ab3cad79ce5375cbb332116c40ea5d668034662280c09832730257ffb09926b3acb8c75cb478c864ce8f648c19f2f605e80de602fe8ce389c2f6f5eea416e0c15cc0412059767bfa2b8c88943f27ae00272408095017426c98e41e4832f833cc17c685b8fe3153c7b5cc8883d232b3c4c83c9498ef5b58d89ac36574f0a36ff6f8b5ba25f101b9841ca169a5c1cc41ab5c3e659660afd8fca2ec9b8b9590fd75886700e2d6579adbe1de10dd4f2bfef24bbe9faa1bf05287e07b045ded6dab0e10b031a5de22521c3b1a52de0e8e0646336a04cade590cd50288c55ad6dffbee6039ac428eb1d336a6c1b35627cd961ddd8dc005b002c58a75da4ac2a2bb248d62cff5862d6f3dd9aefe48fe1fcd3b110fcc220f465869669885bae07ae7422da0cb2a6bee89c22d5519bb62ee1582b3418fc52be05da9516544a7be172de3b43652ef66c199665e75d8ce18d6b7b6c80221080bfe4af6fb359660624c7e8e71cf128b9b73562f3f8ab5d24a441256f15050959a962bf43564ff3d80144ee6b0ea6dc58bae69f9f62fd48ae6d27ac196f1f61d626838c5ea28d333f653f46e63f6f31b92f2d1f2471d89b8e3503c057856a31cb9b10c0a17ac84eab1c8b766cf5c9a33dddda7ddbdd81e75dbba0ddb7f9ad3ba508d777f1988273c5fdea31985326ca59b951fd2d46208110464c56b0e548738cdf6b4842d8748a0069c03ff93b28a186eb800aa885b6b400d4e86f07d88e119d95aabdea2ed8b2aa1981309e009e24644c0dba9df25b7f5d805669e05653ebfd247e318ba8c347b15a72063081ed2e45647f939f56109cb99a6f3eb82c14ab18bf3a706c0a1738142fe6e693522f1ef79f3c6ba6cbbaf49e5417adda00a139ef7257a517cab86dfce1699d7fbc624a683a439cf055e533b6d9022ddb85c6dae7f016f03a385d0d6e806451619adfb6bc37cffff78161c490506f80f9b11e5c2630f78e53c8d1779cc39e4252e612444575fed1e4bece3ab6aa0d0e179e569d48bb6c801568d512aae11d2b6af5df8cb347e820f213a730cbeb97f7cb22465b8e148e83d9c6648fee2a474f32f51d2914b4f501613e4522cef217fc9675abd2d130dec8f743a9eebf7bdb21a55a8df581e079fadbeaf98c2f13c0afe4a26634522e5f89f1dff058e471b51ba9ed83a3b6589ca8bf654bd15377a52d0e71dc09c962985f9cd646fc1a31975e60a285bed0159e12b9a8196eb8314384bec5769abcb15f973371a79c4a9a64b98e8f334bdcf5e25398bbb8c4e3a7ed6818b88b0a61f72407bcd540e52ae5b12db52bee19833409363332c6495d52a6299978f90075c23a447e4c7db23a18bdc902dd1584057f92854b5836a0e2118f2f3739d7b304d55eeac390cec1444ce63b461cb1b9bff46d12275939189f3a8e391f2904ffccf1f10256f5225fe826ddb61fcf4b331e3d7b9e1b22487a7ade2730ad533e5b71ffe9488fe30609cad99e8c3d825c2ccf1bb65f7f98b847aeadecf839e69358f0891d0d88f1cc671d646bef9da1b43dbd820a61696f05295f064690413189bed17dda2f720ff99b22f3da01ab18b56a1c53fc38fa8dbf7932220766c643b4ca0881b0476b120345d683ea508e216131fa6b6fa7e0401ab6a5e4fefd0060a6d621bbc8ad457d7dfe71c16f6f93720eeeb2504c159e12110d8900c6a9334419b14306be6a7a7eb247f685fb6687fa9731d322481858ac0c52ce222007512b2814f745e19c056374d071a71661615ca64b5ebf212c32e0286bfa2d860dc05a3b05a3b5e7e5443a1421f3b4544f3a12b60d7e2dd87b0daa52bdeec4bc6075110166b0631e1cdfc8cfbbcc05c1820b5f66888d91861eb12bff4a7d102ea6eea8c8a2a32b1c2364d63980647d9ae25519af307d81275a4041130c4308e0924ec80ae14efbb56858e0350f6afe5f584cda1d73fb4c1bd0996c4b2edb91fee0c71b97d06221b05f2beeb178a9e50e69f370303013951cbc4740a05e18ecc49d10061789979187272b4bb623930adb01212e8e5ba5bd4302dea1eeaa8effcd61bb350c8105e0fc59bab0d4507800270153b86c70f88eaa7aba59006669e5823bfbf03f2f75e38c42193545bebf47b7dfa88a4814d35b45c7ab41ed28bf70f6db6903a96c56f7f82f0addafefaf6eb922e8e1e1c8defca4c733986dea4a7f2f6800c8c46f9e6b0ac2abbb6af68efae2890a3d7e6daad3816d32f3f365433ba44990a1713d5be3710733f41daa6e60eeda8a0feca88820d01763ddbcfe7a3169177aa78a9eab4f6dbba13142c62943ba8148ff5f6b95b09a80a98e6e78f7bc6d8844e74be4f149fd731fc26d2e254bf82d87933bed4c3fceb048ed590268d90c0275939e6fa1e84211cbe71ed82e947017244d7f1bb833b01747e518f45869f1713dbe613ea1cfb6ca25827b430af62a6a12ef1770a91421831085bfb8bba43a3eea5c1f2e49cae1837298b81945fdee88e89bc49a71640273eab3568d018653dad4270e8345604a7e6267e02f2b7d70ec8b2852b24164469dab4c47a4e9390c5c0a2d87488004264313ee2448cb1471d74a423ff53c1b49ecc3fe04fc2e5f8aa6a5d5d5ee42650726eab3cf62abb22e0acaeb279723ab38d6288e307a1b777ebb00bd385101529ca3a3dce02adaeae0f21a58e7c72a69034337b8385449c4526b07cf1cdf7a5758ce36ea6f6adf7bc51490035f94e86088f29cb2a025698c51eeca9a3e74b5b5369cd6ec98b8235cf96370639fdf2ad1b36239a38fe8ab205cf04f46e0c0cf6573639650ddd83bdd5bbe7a3ffbffc98c6ab10174a174889fc32be5120d1a80c37086da0eb8d80ba28382445b549ea570663827ee3741e5758365b6fd5424121e3bf9650929d5ffe90519fe7346d7c4a950d137726d48856eff6c0489d3f3108ce11e35dd33977314686e6fc2ebf5e995e8b74479d945add1a01e1e212216a66b929a0698a0d293f5d1bffac43fdc242928860cd31f0af037ecc46ad8ab0b8cd647f44726d08079ea40eccd580b35b3a40fddb1283f722283e5b079113879fecde6217854261d0ef505a4c056f8b42b8cc0ab1ffa4c72b6bc609d442898eb63caea4cc6196f61e0a10b18aa1781fc52b364d3d3f34e7261895c0fbf50798771cdb99a3652823c5239d3a8b16a00e9414ea095e95d6ad0f8a137c35fafe84bbae19ab7f06b99dba2164c68a0c1b80ab06b0e6db1bd9b43fcfa46b94d10a22c3560d667c1999f736b12b0158ddb46d303c8e040717bd683b2fb990932ef919a39585cade50eb92a8905a481816dc51e17881595fdd9282ee69213fb126a4e783208b8213f80485353a161a3c98e83cf42df32f305932f81f0f14a8370d110b0e363a86fa6d7eef42d84da5c0b0a47cbb8cc0aad993c5aeca511314b3e9fb861ec518c781526796e8d6b5d4d3faea4111156e840250cfdbf7778d0358d3e0bd02dd6dd8c6d73a5a8b81822b0abe772d1a0e237a52048d0a2bc3f323d5113a821f8d0253e84dab1c58560237e86d155bb9ccfc6be8c6e1aa5a11ed4f35ecd4be1edf06b28a6fe212bdc78c3e4d2eed473b95542ff9bc34d4e53bdd92928798b5075b719d0ceb219268797adb85c88d7e1d6d7138752f2d93bd2085e7a9b51e14caa09e4294cfc56b651d5cc1e5337bd30f0dc7cc7dbe9ffdc5f8fe04849a8d3f2cb959b017caf8dc69e9e32286c6b47cedde6e2534d37f902c25d927ccda84e6d42d2477b5de7d3fbbc7806488cf6adb06bc6214acb66ef36c84740dc1dc2f5d93900582790ba7c7cff3e5ec412811320ade8b7c2d108a227a09ceb310f8aefa048fdc548e43fefcedb94befe094509765a91aa859eead886d1307c4c1cc855a6db6df9e743a34f41c0f8704883cbe2b03d9f0e554fd9093a92216902ae7555480fb7901f8522be49917dec5e6efe0bde76ddbabe03a12d336f634a00de166f7e552def3388faf894fa56024a06167b4d14467a737866b5beb6863f014f05795c20e5469087dd7ef368a5ff99419902588c7e084c5ef7c87a3cf29a8c9ec9e31877f5317f4f268789497bca33159f9db406e5b09232d539fb954316bb33bc6124bafc15c3d1ab03e8395e35880c865094d140d4e122127e381eac96780c772cb4e1317df40c928b4bc8bc00b74caf98d67a2286bcd6fac0436e474f6e5a0ae9e58a9c3b2ddd23ae003b60ffc870682bc045f4475ee9d632b8a0f946442e37dbdb3e7cf9b8bad9e05c2cd45f74da07aded1d67144fc94ae28b9c3310158745cd01a82ac0abe7f278251e9221bab31e6909d5a12946304cc14674daf56a7fe339778c559427def09b43d23dfba8ac67d5a85d0ac227eda153cc660341eae58fa103456488582c22f0f579416553069ae3fae30ae4a71105619fd77c068f08743008f0c66ef0326d9d09f0ea0d4848f02e3baef4957e2d3dbcb7162d37aded785334f042d151d6dc29f26d0ed4dda9e12d0f233a5bc79dfccb8067d7f71e3e86abc077557f04ec431899c6d38d1bf4d4db5dd66a1696a526fae43c3891c55a38e0f45995a9d91f5a1d2cac2038ad07d01428cd96f18e58d52fe7bcf46a866f26ad5b99f91cad680bcfee53e2b5d6e61497d170818b57dee37f02581aeeb206340b2bb1ce4e93b720c3908001eddc264dc77c7f0807a2523e9d8b86bcd1c4f12e3c8d87f9b5abf70e64a200e6a5f444110b1f76277cf0a903e78010c20a82cb03de5d63ae6de0d433a434b292e2302cbe005bf712d51644b9b84b1b69a7ce9ef605e0dae44c976968ee780753b98a42351895f088f5f0e1b3358125147ce6f9668caf7a3def47fd553c347360c89abdd8fb0179195eb9ad1495849fa095e74007ba7468aaf713950391a49a08ee7fc769bc0c5cd2b607f5f93cd4889dcaaeaec4c2c0a948e2522f9fa8a46a8e6207b1599da9848df3b2eac7e6080e392811d5dc762a1927b61b716a1008b277ae30fafb59bf6f868d5476f0a085d997f4884d4a4beaf7d6b31368fee3b367c5cbe7f4d43f4f5f214e49d07d651ff178a3af5d286e474761c6c2e47fb7ac780a485adff8b2748c00f7ee05348b15599dd274e0202abf245b670d5b070d650f46cf351aa075943cce8597e7f0f63a31c934c09d044adf5bd03cbca99fa65e97df881553653081fbae72ca0bf471bc96a25536fe6ef664560e07b0bc57d7a25e536b1c19546c6230aa33f31e97566d6e8460fecd7f8fdf75fae914ddc8dd6e6bc64afb05cc85545fd1a8afd40cc78316cff8a01356ffe43a0db24aa976f437594ebe0ddeb94c51bac27fe4369247f7e2ca0b1ef3d1ea7c9bea41ac005beee3ca9b64be6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入邀请码阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>Gameplay</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻编程准备之 宏定义的语法</title>
    <url>/2022/04/07/%E8%99%9A%E5%B9%BB%E7%BC%96%E7%A8%8B%E5%87%86%E5%A4%87%E4%B9%8B-%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>虚幻编程要面对的很大一部分代码都是用宏来书写的，包括整个虚幻的反射机制也是由宏来支撑的。</p>
<p>这里对宏来做一个简单的用法总结，主要还是针对C++和C的宏语法。</p>
<span id="more"></span>
<h2 id="最简形式的宏"><a class="markdownIt-Anchor" href="#最简形式的宏"></a> 最简形式的宏</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.14</span></span><br></pre></td></tr></table></figure>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">funcSampleMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pi * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">31.4</span></span><br></pre></td></tr></table></figure>
<h2 id="带参数的宏单参数"><a class="markdownIt-Anchor" href="#带参数的宏单参数"></a> 带参数的宏(单参数)</h2>
<h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> func(x) (x * 2)</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-2"><a class="markdownIt-Anchor" href="#使用-2"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">funcParamerizedMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-2"><a class="markdownIt-Anchor" href="#输出-2"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">40</span></span><br></pre></td></tr></table></figure>
<h2 id="带参数的宏多参数"><a class="markdownIt-Anchor" href="#带参数的宏多参数"></a> 带参数的宏(多参数)</h2>
<h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(...) t(##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">t</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-3"><a class="markdownIt-Anchor" href="#使用-3"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">t</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">t</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">funcMultiParaMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TEST</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float funcMultiParaMacro()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	return TEST(1, 2);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="输出-3"><a class="markdownIt-Anchor" href="#输出-3"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="换行"><a class="markdownIt-Anchor" href="#换行"></a> 换行</h2>
<h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Wrap(functionName) float functionName()\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">	return 3.14;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-4"><a class="markdownIt-Anchor" href="#使用-4"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Wrap</span>(unnamed)</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">funcWrapMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">unnamed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-4"><a class="markdownIt-Anchor" href="#输出-4"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<h2 id="号的使用"><a class="markdownIt-Anchor" href="#号的使用"></a> #号的使用</h2>
<p><code>#</code> 用来转化字符串</p>
<h3 id="定义-5"><a class="markdownIt-Anchor" href="#定义-5"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOSTRING(x) #x</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-5"><a class="markdownIt-Anchor" href="#使用-5"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">funcToStringMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TOSTRING</span>(hello world);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-5"><a class="markdownIt-Anchor" href="#输出-5"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="号的使用-2"><a class="markdownIt-Anchor" href="#号的使用-2"></a> ##号的使用</h2>
<p><code>##</code> 用来拼接</p>
<h3 id="定义-6"><a class="markdownIt-Anchor" href="#定义-6"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMBINE(x,y) x##y</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-6"><a class="markdownIt-Anchor" href="#使用-6"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">funcCombineMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">COMBINE</span>(func, <span class="built_in">ToStringMacro</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-6"><a class="markdownIt-Anchor" href="#输出-6"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="内置的宏"><a class="markdownIt-Anchor" href="#内置的宏"></a> 内置的宏</h2>
<h3 id="列举"><a class="markdownIt-Anchor" href="#列举"></a> 列举</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__FILE__</span><br><span class="line">__LINE__</span><br><span class="line">__DATE__</span><br><span class="line">__TIME__</span><br><span class="line">__FUNCTION__</span><br></pre></td></tr></table></figure>
<h3 id="使用-7"><a class="markdownIt-Anchor" href="#使用-7"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcBuildInMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-7"><a class="markdownIt-Anchor" href="#输出-7"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">E:\Project\CppResearchLoc\CppResearch\MacroResearch\Commen.h</span><br><span class="line"><span class="number">66</span></span><br><span class="line">Apr  <span class="number">7</span> <span class="number">2022</span></span><br><span class="line"><span class="number">16</span>:<span class="number">36</span>:<span class="number">28</span></span><br><span class="line">funcBuildInMacro</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 111 二叉树的最小深度</title>
    <url>/2022/04/06/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%80%92%E5%BD%92">深度优先搜索（递归）</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
 <font color=#999AAA >
给定一个二叉树，找出其最小深度。
</font>
<font color=#999AAA >
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
</font>
<font color=#999AAA >
说明：叶子节点是指没有子节点的节点。
</font>
<ul>
<li>示例 1：<br />
输入：root = [3,9,20,null,null,15,7]<br />
输出：2</li>
<li>示例 2：<br />
输入：root = [2,null,3,null,4,null,5,null,6]<br />
输出：5</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先搜索递归"><a class="markdownIt-Anchor" href="#深度优先搜索递归"></a> 深度优先搜索（递归）</h2>
<p>该题目的重点是理解题意，为何“最近叶子节点”？叶子节点是树中某个左右子树均为空的节点，即只要只要该节点左右子树中某一个不为空的话，该节点即为叶子节点。此时可以依据情况具体讨论：</p>
<ul>
<li>当该节点为空时，该节点到最近叶子节点的距离为0；</li>
<li>当该节点的左右子树均为空时，该节点到最近叶子节点的距离为1；</li>
<li>当该节点的左右子树中其中一个为空另一个不为空时，该节点到最近叶子节点的距离为不为空的子树节点到其最近叶子节点的距离 + 1；</li>
<li>当该节点的左右子树均不为空时，该节点到最近叶子节点的距离为两个子树节点中距其最近叶子节点的较小者再 + 1；</li>
</ul>
<p>如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> || root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left) + <span class="built_in">minDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),<span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f6ab59ccb7d64b599de68a54ed75baba.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，h为二叉树的高度</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104 二叉树的最大深度</title>
    <url>/2022/04/05/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88">深度优先</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个二叉树，找出其最大深度。
</font>
<font color=#999AAA >
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
</font>
<font color=#999AAA >
说明: 叶子节点是指没有子节点的节点。
</font>
<ul>
<li>示例：<br />
给定二叉树 [3,9,20,null,null,15,7]，<br />
返回它的最大深度 3 。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先"><a class="markdownIt-Anchor" href="#深度优先"></a> 深度优先</h2>
<p>当前节点的最大深度就是左右子树中深度较大者再加上1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f558609051e24295838510b34d78197d.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(height)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>，height表示树的高度，最大可能是n</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101 对称二叉树</title>
    <url>/2022/04/05/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个二叉树的根节点 root ， 检查它是否轴对称。
</font>
<ul>
<li>示例 1：<br />
输入：root = [1,2,2,3,4,4,3]<br />
输出：true</li>
<li>示例 2：<br />
输入：root = [1,2,2,null,3,null,3]<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/symmetric-tree">https://leetcode-cn.com/problems/symmetric-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp;  <span class="built_in">check</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">check</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/10cd49e251a245018bb99f5ade67d0f1.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 100 相同的树</title>
    <url>/2022/04/05/LeetCode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%80%92%E5%BD%92">深度优先搜索（递归）</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
</font>
<font color=#999AAA >
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
</font>
<ul>
<li>示例 1：<br />
输入：p = [1,2,3], q = [1,2,3]<br />
输出：true</li>
<li>示例 2：<br />
输入：p = [1,2], q = [1,null,2]<br />
输出：false</li>
<li>示例 3：<br />
输入：p = [1,2,1], q = [1,1,2]<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/same-tree">https://leetcode-cn.com/problems/same-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先搜索递归"><a class="markdownIt-Anchor" href="#深度优先搜索递归"></a> 深度优先搜索（递归）</h2>
<p>先试着想想如何判断其中某个节点是否相等：判断其值是否相等 &amp;&amp; 判断其左子节点的值是否相等 &amp;&amp; 判断其右子节点的值是否相等。其中当要判断的两者中某个节点为空时，或者都为空时，可以不用判断相等而提前进行判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/274003d717384a2f82c989cd6e5345fd.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，取决于两树中最小的那个的大小<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 94 二叉树的中序遍历</title>
    <url>/2022/04/05/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个二叉树的根节点 root ，返回它的 中序 遍历。
</font>
<ul>
<li>示例 1：<br />
输入：root = [1,null,2,3]<br />
输出：[1,3,2]</li>
<li>示例 2：<br />
输入：root = []<br />
输出：[]</li>
<li>示例 3：<br />
输入：root = [1]<br />
输出：[1]</li>
<li>示例 4：<br />
输入：root = [1,2]<br />
输出：[2,1]</li>
<li>示例 5：<br />
输入：root = [1,null,2]<br />
输出：[1,2]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>中序遍历是左中右，即左子节点-&gt;当前节点-&gt;右子节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">recurve</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recurve</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">recurve</span>(root-&gt;left, v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">recurve</span>(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/30d5641c3f124aaf8d4d9c438c5cde91.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，遍历节点的复杂度<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，用分配空间存储结果，同时也需要分配相应的递归栈。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 88 合并两个有序数组</title>
    <url>/2022/04/05/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
</font>
<font color=#999AAA >
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
</font>
<font color=#999AAA >
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
</font>
<ul>
<li>示例 1：<br />
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br />
输出：[1,2,2,3,5,6]<br />
解释：需要合并 [1,2,3] 和 [2,5,6] 。<br />
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</li>
<li>示例 2：<br />
输入：nums1 = [1], m = 1, nums2 = [], n = 0<br />
输出：[1]<br />
解释：需要合并 [1] 和 [] 。<br />
合并结果是 [1] 。</li>
<li>示例 3：<br />
输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br />
输出：[1]<br />
解释：需要合并的数组是 [] 和 [1] 。<br />
合并结果是 [1] 。<br />
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array">https://leetcode-cn.com/problems/merge-sorted-array</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h2>
<p>利用两个指针分别遍历两个数组，比较指向的数据的大小，直到其中一方遍历完成，再把剩余数据填充完整即可。这里需要借助辅助数组空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums1_index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nums2_index = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vtemp</span><span class="params">(m+n)</span></span>;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (nums1_index &lt; m || nums2_index &lt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1_index == m) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[nums2_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums2_index == n) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[nums1_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[nums1_index] &lt; nums2[nums2_index]) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[nums1_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[nums2_index++];</span><br><span class="line">            &#125;</span><br><span class="line">            vtemp[nums1_index + nums2_index - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m + n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i] = vtemp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/0e6e0fc1d200457b88a2d5e22829fee8.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，遍历的代价<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，辅助数据空间的代价</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 83 删除排序链表中的重复元素</title>
    <url>/2022/04/05/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E9%81%8D%E5%8E%86">双指针遍历</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。
</font>
<ul>
<li>
<p>示例 1：<br />
输入：head = [1,1,2]<br />
输出：[1,2]</p>
</li>
<li>
<p>示例 2：<br />
输入：head = [1,1,2,3,3]<br />
输出：[1,2,3]</p>
</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="双指针遍历"><a class="markdownIt-Anchor" href="#双指针遍历"></a> 双指针遍历</h2>
<p>用一个指针pre指向前一个节点，然后用另一个指针cur进行链表的遍历，当cur的值和pre的值相同时，进行链表节点的删除。当cur指针为空时，说明遍历进行到了链表的结尾。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == pre-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e67b92d80e834fdbacb2e746d76feda9.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 70 爬楼梯</title>
    <url>/2022/04/05/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
</font>
<font color=#999AAA >
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
</font>
<ul>
<li>示例 1：<br />
输入：n = 2<br />
输出：2<br />
解释：有两种方法可以爬到楼顶。</li>
</ul>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<ul>
<li>示例 2：<br />
输入：n = 3<br />
输出：3<br />
解释：有三种方法可以爬到楼顶。</li>
</ul>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>每一层楼梯，基本都有两种方式可以到达：从前一阶过来，或者从前两阶过来。如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n<span class="number">-1</span>) + <span class="built_in">climbStairs</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，爆栈了。<br />
<img src="https://img-blog.csdnimg.cn/d7d6a1363ca241bc91d94ac06f7a4320.png" alt="在这里插入图片描述" /></p>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>先预先分配好内存，将求取的值存入到内存中，直到找到目标值对应的数目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        v[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i] = v[i<span class="number">-1</span>] + v[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2a9c86691e844d9e9b03bb365eddddf4.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 69 x的平方根</title>
    <url>/2022/04/05/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE">暴力枚举</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%B3%95">二分法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
</font> 
<font color=#999AAA >
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
</font> 
<font color=#999AAA >
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
</font> 
<ul>
<li>示例 1：<br />
输入：x = 4<br />
输出：2</li>
<li>示例 2：<br />
输入：x = 8<br />
输出：2<br />
解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/sqrtx">https://leetcode-cn.com/problems/sqrtx</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力枚举"><a class="markdownIt-Anchor" href="#暴力枚举"></a> 暴力枚举</h2>
<p>已知x是非负整数，那么一定有要求的平方根小于x，所以可以从0开始遍历，直到找到平方后大于x的值，再在这个值上减去1即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> seed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="type">long</span> <span class="type">long</span>)seed * seed &lt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            seed ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seed - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/10cd7c75f6b545eda47b5d25c9daaf98.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，从0到x遍历<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h2>
<p>从暴力枚举出发进行优化，利用二分法找目标值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="type">int</span> seed = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid &lt;= x) </span><br><span class="line">            &#123;</span><br><span class="line">                seed = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6d510435d4e0498f9bb6a91e4c9ff61d.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 67 二进制求和</title>
    <url>/2022/04/05/LeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%85%A7%E6%8A%84">照抄</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两个二进制字符串，返回它们的和（用二进制表示）。
</font> 
<font color=#999AAA >
输入为 非空 字符串且只包含数字 1 和 0。
</font> 
<ul>
<li>示例 1:<br />
输入: a = “11”, b = “1”<br />
输出: “100”</li>
<li>示例 2:<br />
输入: a = “1010”, b = “1011”<br />
输出: “10101”</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/add-binary">https://leetcode-cn.com/problems/add-binary</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="照抄"><a class="markdownIt-Anchor" href="#照抄"></a> 照抄</h2>
<p>凹了几天，最后还是照抄了官方给的做法，即先把字符串反过来（reverse()s函数），然后再把最后得到的结果反过来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((carry % <span class="number">2</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5105d7414e9b484388d28a964d733a66.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 66 加一</title>
    <url>/2022/04/05/LeetCode-66-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%BE%AA%E7%8E%AF%E8%BF%9B%E4%BD%8D">循环进位</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
</font> 
<font color=#999AAA >
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
</font> 
<font color=#999AAA >
你可以假设除了整数 0 之外，这个整数不会以零开头。
</font> 
<p>示例 1：</p>
<p>输入：digits = [1,2,3]<br />
输出：[1,2,4]<br />
解释：输入数组表示数字 123。<br />
示例 2：</p>
<p>输入：digits = [4,3,2,1]<br />
输出：[4,3,2,2]<br />
解释：输入数组表示数字 4321。<br />
示例 3：</p>
<p>输入：digits = [0]<br />
输出：[1]</p>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/plus-one">https://leetcode-cn.com/problems/plus-one</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="循环进位"><a class="markdownIt-Anchor" href="#循环进位"></a> 循环进位</h2>
<p>从数组最后一位开始遍历，如果有进位的话则继续下一位加一，最后需要在循环结束时判断是否还有进位，有的话则需要重新申请内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = end; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vtemp;</span><br><span class="line">            vtemp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                vtemp.<span class="built_in">push_back</span>(digits[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vtemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e7df2a129b68411fa582bec0b19b1a7b.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 58 最后一个单词的长度</title>
    <url>/2022/04/05/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E9%81%8D%E5%8E%86">暴力遍历</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。
</font> 
<font color=#999AAA >
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
</font> 
<ul>
<li>示例 1：<br />
输入：s = “Hello World”<br />
输出：5<br />
解释：最后一个单词是“World”，长度为5。</li>
<li>示例 2：<br />
输入：s = &quot;   fly me   to   the moon  &quot;<br />
输出：4<br />
解释：最后一个单词是“moon”，长度为4。</li>
<li>示例 3：<br />
输入：s = “luffy is still joyboy”<br />
输出：6<br />
解释：最后一个单词是长度为6的“joyboy”。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/length-of-last-word">https://leetcode-cn.com/problems/length-of-last-word</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力遍历"><a class="markdownIt-Anchor" href="#暴力遍历"></a> 暴力遍历</h2>
<p>从最后一位开始找起，当该位上字符不为空格时，开始计数，等到找到边界时，返回找到的不为空格的字符数。这里的边界可能是字符串的开头，也有可能是字符串中间的某个位置，即该字符不为空格，而前一个字符为空格，即为边界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4626a0f21a4d4004b64f278109f84268.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 53 最大子数组和</title>
    <url>/2022/04/05/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
</font> 
<font color=#999AAA >
子数组 是数组中的一个连续部分。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br />
输出：6<br />
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</li>
<li>示例 2：<br />
输入：nums = [1]<br />
输出：1</li>
<li>示例 3：<br />
输入：nums = [5,4,-1,7,8]<br />
输出：23</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>从第一位开始，我们找以该元素为结尾的最大子数组和，然后找出所有这些子数组和中最大的即可。这个问题的关键就是要紧紧围绕这个元素展开，不论我们如何运算，比较的内容中一定要包含这个元素，因为现在的子目标是要找的是<strong>以该元素为结尾的最大子数组和</strong>，可以想到，可以比较前一子数组和加上当前元素与当前元素进行比较，取二者中较大的一个，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)=max(f(i−1)+nums[i],nums[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxSubSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSubSum = <span class="built_in">max</span>(maxSubSum + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, maxSubSum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f48544a31b8f4647bfd81476eb0fc87e.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 35 搜索插入位置</title>
    <url>/2022/04/05/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C%E5%88%86%E6%B3%95">二分法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
</font> 
<font color=#999AAA >
请必须使用时间复杂度为 O(log n) 的算法。
</font> 
<ul>
<li>示例 1:<br />
输入: nums = [1,3,5,6], target = 5<br />
输出: 2</li>
<li>示例 2:<br />
输入: nums = [1,3,5,6], target = 2<br />
输出: 1</li>
<li>示例 3:<br />
输入: nums = [1,3,5,6], target = 7<br />
输出: 4</li>
<li>示例 4:<br />
输入: nums = [1,3,5,6], target = 0<br />
输出: 0</li>
<li>示例 5:<br />
输入: nums = [1], target = 0<br />
输出: 0</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/search-insert-position">https://leetcode-cn.com/problems/search-insert-position</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h2>
<p>直接使用二分法的话，查找到的条件是目标值和数组中元素相等；但是这里题目中描述的是数组中可能不存在与目标值相等的元素，此时的操作是返回插入该元素的位置，所以可以略微修改二分查找的条件：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>&gt;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[right - 1] &lt; target \leq nums[right]\\
left &gt; right
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5c34cef07cbe454d881c9888397ea254.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：数组二分，复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，也符合题目要求<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 28 实现strStr()</title>
    <url>/2022/04/05/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D">暴力匹配</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
实现 strStr() 函数。
</font> 
<font color=#999AAA >
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
</font> 
<font color=#999AAA >
说明：
</font> 
<font color=#999AAA >
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
</font> 
<font color=#999AAA >
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
</font> 
<ul>
<li>示例 1：<br />
输入：haystack = “hello”, needle = “ll”<br />
输出：2</li>
<li>示例 2：<br />
输入：haystack = “aaaaa”, needle = “bba”<br />
输出：-1</li>
<li>示例 3：<br />
输入：haystack = “”, needle = “”<br />
输出：0</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/implement-strstr">https://leetcode-cn.com/problems/implement-strstr</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力匹配"><a class="markdownIt-Anchor" href="#暴力匹配"></a> 暴力匹配</h2>
<p>匹配的实质是找出长字符串中的短字符串部分，所以可以枚举所有长字符串中的长度为短字符串长度的子字符串与短字符串进行匹配，如果匹配结果合适，则返回首字符下标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lenHay = haystack.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> lenNeedle = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (lenNeedle == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenHay - lenNeedle + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i + j &lt; lenHay &amp;&amp; j &lt; lenNeedle; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == lenNeedle - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/424b30b4772740d295f4c50a80d67ffe.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，极端情况下需要挨个对两个字符串进行匹配<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 27 移除元素</title>
    <url>/2022/04/05/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95">快慢指针解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
</font> 
<font color=#999AAA >
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
</font> 
<font color=#999AAA >
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [3,2,2,3], val = 3<br />
输出：2, nums = [2,2]<br />
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</li>
<li>示例 2：<br />
输入：nums = [0,1,2,2,3,0,4,2], val = 2<br />
输出：5, nums = [0,1,4,0,3]<br />
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="快慢指针解法"><a class="markdownIt-Anchor" href="#快慢指针解法"></a> 快慢指针解法</h2>
<p>分别设定快慢指针，快指针进行数组的遍历，慢指针负责维护“不等于目标元素的元素的数组”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> slowptr = <span class="number">-1</span>, quickptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; quickptr &lt; len; quickptr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[quickptr] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++slowptr] = nums[quickptr];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowptr + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4c834f280a3545fe9dc9a45f5779603a.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 26 删除有序数组中的重复项</title>
    <url>/2022/04/05/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%80%9F%E5%8A%A9%E8%BE%85%E5%8A%A9%E7%A9%BA%E9%97%B4">借助辅助空间</a></li>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95">快慢指针解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
</font> 
<font color=#999AAA >
由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
</font> 
<font color=#999AAA >
将最终结果插入 nums 的前 k 个位置后返回 k 。
</font> 
<font color=#999AAA >
不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [1,1,2]<br />
输出：2, nums = [1,2,_]<br />
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</li>
<li>示例 2：<br />
输入：nums = [0,0,1,1,1,2,2,3,3,4]<br />
输出：5, nums = [0,1,2,3,4]<br />
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="借助辅助空间"><a class="markdownIt-Anchor" href="#借助辅助空间"></a> 借助辅助空间</h2>
<p>对数组中元素遍历，当当前元素与前一个元素不等时，则判断其为新元素，加入到辅助数组空间中，直到遍历数组结束。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = res;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/642a1ed90cec498f9351b2905aabc413.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：申请了额外的数组空间，最大可能和原数组同样大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h2 id="快慢指针解法"><a class="markdownIt-Anchor" href="#快慢指针解法"></a> 快慢指针解法</h2>
<p>分别设定快慢指针，快指针进行数组的遍历，寻找“新元素”，而慢指针负责将不同的元素存储起来，即当快指针找到一个不同的元素时，将其覆盖掉慢指针指向元素的后一位，这样就相当于利用慢指针在维护一个无重复项的数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> slowPtr = <span class="number">0</span>, quickPtr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; quickPtr &lt; len; quickPtr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[quickPtr] != nums[quickPtr<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++slowPtr] = nums[quickPtr];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowPtr + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/321f3940a5044a20abdd8c79480d81e0.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 21 合并两个有序链表</title>
    <url>/2022/04/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%93%BE%E8%A1%A8%E9%A1%BA%E5%BA%8F%E6%9E%9A%E4%B8%BE">链表顺序枚举</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95">递归解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
</font> 
<ul>
<li>示例 1：<br />
输入：l1 = [1,2,4], l2 = [1,3,4]<br />
输出：[1,1,2,3,4,4]</li>
<li>示例 2：<br />
输入：l1 = [], l2 = []<br />
输出：[]</li>
<li>示例 3：<br />
输入：l1 = [], l2 = [0]<br />
输出：[0]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="链表顺序枚举"><a class="markdownIt-Anchor" href="#链表顺序枚举"></a> 链表顺序枚举</h2>
<p>按顺序对两链表的当前node进行数值的比对，符合条件者入新链表，并找该node的next继续进行这个比对操作，直到其中一个链表到头。此时将未遍历完的链接合到已有链上即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* curr = preHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                curr-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                curr-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr-&gt; next = list1 == <span class="literal">nullptr</span> ? list2:list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/54473df4dc834d8aa6d5db8b27be7a3b.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历两链表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="递归解法"><a class="markdownIt-Anchor" href="#递归解法"></a> 递归解法</h2>
<p>递归的理解是，求两个链表的合并，即是每个节点后接上该节点的后续链和另外一条链的合并。递归终止条件是其中一条链为空，此时返回另外一条链。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/206ec42b1aed4076b61fb7397c69e982.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历两链表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(n,m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，需要用到函数堆栈，容量与两链表的长度相关，最小函数堆栈为两个链表中较短的那一条的大小，最大即需要一直将所有节点都遍历一遍，此时函数堆栈大小为n+m。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 20 有效的括号</title>
    <url>/2022/04/05/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
</font>
<font color=#999AAA >
有效字符串需满足：
</font>
<font color=#999AAA >
左括号必须用相同类型的右括号闭合。
</font>
<font color=#999AAA >
左括号必须以正确的顺序闭合。
</font> 
<ul>
<li>示例 1：<br />
输入：s = “()”<br />
输出：true</li>
<li>示例 2：<br />
输入：s = “()[]{}”<br />
输出：true</li>
<li>示例 3：<br />
输入：s = “(]”<br />
输出：false</li>
<li>示例 4：<br />
输入：s = “([)]”<br />
输出：false</li>
<li>示例 5：<br />
输入：s = “{[]}”<br />
输出：true</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>可以利用一个栈结构来进行括号的存储，即遍历字符串，在遇到左括号（不论是哪一个），都进栈处理，而一旦遇到右括号，就和栈顶进行比对，不匹配说明不符合要求，则返回false，匹配的话则进行出栈，再继续进行判断。</p>
<p>值得注意的是这里的第二的条件“左括号必须以正确的顺序闭合”，即当遍历遇到右括号时，此时栈顶必须得是相应左括号才行，否则就不可能是以正确得顺序闭合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sta.<span class="built_in">empty</span>() || !<span class="built_in">isParaMatch</span>(sta.<span class="built_in">top</span>(), s[i])) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sta.<span class="built_in">empty</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isParaMatch</span><span class="params">(<span class="type">char</span> l, <span class="type">char</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2840a078c7a54fa69b822586adb95020.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组及字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，即栈的可能最大长度</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 14 最长公共前缀</title>
    <url>/2022/04/05/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
编写一个函数来查找字符串数组中的最长公共前缀。
</font>
<font color=#999AAA >
如果不存在公共前缀，返回空字符串 ""。
</font>
<ul>
<li>示例 1：<br />
输入：strs = [“flower”,“flow”,“flight”]<br />
输出：“fl”</li>
<li>示例 2：<br />
输入：strs = [“dog”,“racecar”,“car”]<br />
输出：&quot;&quot;<br />
解释：输入不存在公共前缀。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix">https://leetcode-cn.com/problems/longest-common-prefix</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>可以实现一个方法在两个字符串间寻找最长公共前缀，即按位比较，直到不一致时跳出，即可得到最长公共前缀。然后用这个得到的串再和数组内其他的字符串求最长公共前缀，直到遍历数组结束。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">getCommonPrefix</span>(res, strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getCommonPrefix</span><span class="params">(string str00, string str01)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len00 = str00.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len01 = str01.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len = len00 &lt;= len01 ? len00 : len01;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str00[i] == str01[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res += str00[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/91d589b02e9d4f44a61d3e3f4ea709ac.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组及字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，m表示单个字符串长度，n表示数组大小<br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，借助了临时字符串作存储</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 13 罗马数字转整数</title>
    <url>/2022/04/05/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
</font>
<table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:center">数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>V</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>X</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>L</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td>C</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td>D</td>
<td style="text-align:center">500</td>
</tr>
<tr>
<td>M</td>
<td style="text-align:center">1000</td>
</tr>
</tbody>
</table>
  <font color=#999AAA >
  例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
  </font>
<font color=#999AAA >
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
</font>
<font color=#999AAA >
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
</font>
<font color=#999AAA >
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
</font>
<font color=#999AAA >
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
</font>
<font color=#999AAA >
给定一个罗马数字，将其转换成整数。
</font>
<ul>
<li>示例 1:<br />
输入: s = “III”<br />
输出: 3</li>
<li>示例 2:<br />
输入: s = “IV”<br />
输出: 4</li>
<li>示例 3:<br />
输入: s = “IX”<br />
输出: 9</li>
<li>示例 4:<br />
输入: s = “LVIII”<br />
输出: 58<br />
解释: L = 50, V= 5, III = 3.</li>
<li>示例 5:<br />
输入: s = “MCMXCIV”<br />
输出: 1994<br />
解释: M = 1000, CM = 900, XC = 90, IV = 4.</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/roman-to-integer">https://leetcode-cn.com/problems/roman-to-integer</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>除了特殊情况以外（4，9，40，90等），这里的核心其实就是累加，如VII，就是5+1+1 = 7，即可以通过遍历字符串来将每个字符对应的值找到并累加。其实可以将特殊情况也用这样的方法的看，比如IV，就是在找到字符对应的值的时候，与后一位（如果存在的话）的对应的值进行比较，如果小于的话，那么就可以将该位上的值取反，即-1 + 5 = 4。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="built_in">getSingleInt</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; len &amp;&amp; temp &lt; <span class="built_in">getSingleInt</span>(s[i+<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                temp = <span class="number">0</span> - temp;</span><br><span class="line">            &#125;</span><br><span class="line">            res += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSingleInt</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6e92fbab0fe049ce90a949a95723c496.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 9 回文数</title>
    <url>/2022/04/05/LeetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">暴力解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
</font>
<font color=#999AAA >
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。
</font>
<ul>
<li>示例 1：<br />
输入：x = 121<br />
输出：true</li>
<li>示例 2：<br />
输入：x = -121<br />
输出：false<br />
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</li>
<li>示例 3：<br />
输入：x = 10<br />
输出：false<br />
解释：从右向左读, 为 01 。因此它不是一个回文数。</li>
<li>示例 4：<br />
输入：x = -101<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/palindrome-number">https://leetcode-cn.com/problems/palindrome-number</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力解法"><a class="markdownIt-Anchor" href="#暴力解法"></a> 暴力解法</h2>
<p>将各位上的数字依次输出，然后按照顺序进行比对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arrPalindrome;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x%<span class="number">10</span> != <span class="number">0</span> || x/<span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">            arrPalindrome.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = arrPalindrome.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrPalindrome[i] != arrPalindrome[len <span class="number">-1</span> - i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/abb8239a33f54bd7875a5f50b3dfc52c.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn + \frac{1}{2}logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：开辟辅助数组所出现的消耗，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1 两数之和</title>
    <url>/2022/04/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE">暴力枚举</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8C%96%E5%81%9A%E6%B3%95">基于哈希表的优化做法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。
</font>
<font color=#999AAA >
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。
</font>
<ul>
<li>
<p>示例 1：<br />
输入：nums = [2,7,11,15], target = 9<br />
输出：[0,1]<br />
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
</li>
<li>
<p>示例 2：<br />
输入：nums = [3,2,4], target = 6<br />
输出：[1,2]</p>
</li>
<li>
<p>示例 3：<br />
输入：nums = [3,3], target = 6<br />
输出：[0,1]</p>
</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力枚举"><a class="markdownIt-Anchor" href="#暴力枚举"></a> 暴力枚举</h2>
<p>按照下标从小往大的顺序，将数组中任意两数两两组合，以枚举出所有的可能性，从而检查两数字之和是否与目标值相等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/50fc18cd45ff4f3ba2a3ac31c487e401.png" alt="在这里插入图片描述" /><br />
复杂度分析<br />
时间复杂度：最坏情况下（符合要求两数字的下标位于数组的末尾），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="基于哈希表的优化做法"><a class="markdownIt-Anchor" href="#基于哈希表的优化做法"></a> 基于哈希表的优化做法</h2>
<p>利用哈希表的特性（查找快速），在遍历数组的同时，检查每个元素达成目标值所需要的另一元素是否存在于哈希表中，从而实现在遍历一遍数组的前提下，就能够找出符合要求的两个数组元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator iter = hashMap.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != hashMap.<span class="built_in">end</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, iter-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/1e538207d91a4d198ab33ad1e016203f.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，对每个元素需要以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的代价来判断是否存在另一个元素<br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，主要是用来开辟哈希表空间</p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 纹理的处理（Texturing）</title>
    <url>/2022/03/30/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BA%B9%E7%90%86%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%88Texturing%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 着色基础（Shading Basics）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%9D%80%E8%89%B2%E5%9F%BA%E7%A1%80%EF%BC%88Shading-Basics%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 变换（Transforms）</title>
    <url>/2022/03/30/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E6%8D%A2%EF%BC%88Transforms%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 图形处理单元（The Graphics Processing Unit）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83%EF%BC%88The-Graphics-Processing-Unit%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 图形渲染管线（The Graphics Rendering Pipeline）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%88The-Graphics-Rendering-Pipeline%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 介绍（Introduction）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%8B%E7%BB%8D%EF%BC%88Introduction%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>渲染</category>
        <category>Real-Time Rendering 4th Edition 读书与翻译</category>
      </categories>
      <tags>
        <tag>渲染管线</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>快速建站方案（hexo + next）全面记录</title>
    <url>/2022/03/23/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>本文记录了笔者在搭建 <a href="https://claude-jhin.github.io">个人博客网站</a> 时所经历的过程，包含整个流程和中间遇到的一些麻烦。<br />
这里记录下来，作为自己一个阶段对网站开发学习的总结，并且如果能够帮助或者启发更多的人，也将不胜荣幸。<br />
当然，笔者并不是专业的前端开发人员，前端开发只是作为工具而去粗浅的使用，所以在一些细节上难以尽善尽美。</p>
<span id="more"></span>
<p>本文仅是对工具浮于表面的粗浅使用，更多的信息还是请参考备注的各种官方链接。</p>
<h3 id="hexo简介"><a class="markdownIt-Anchor" href="#hexo简介"></a> Hexo简介</h3>
<p>依据 <a href="https://hexo.io/zh-cn">Hexo中文官网</a> 中的介绍，Hexo是一个快速、简洁且高效的博客框架。<br />
最直观的，在这套框架的帮助下，我们可以很快的通过markdown来完成一篇又一篇博客的编辑。<br />
此外，Hexo也是可扩展的，在各种各样插件的帮助下，可以实现多种多样的前端效果。</p>
<h3 id="next简介"><a class="markdownIt-Anchor" href="#next简介"></a> next简介</h3>
<p>next是Hexo丰富多彩的主题中比较受欢迎的一个，其本身是一个 <a href="https://github.com/next-theme/hexo-theme-next">开源的项目</a> 到现在一直在不断得推出新的版本。</p>
<p>如果说Hexo是对前端开发的简化和封装，那么next就是对hexo框架允许内的前端效果的封装。<br />
在这两者的帮助下，降低了开发难度，让使用者可以仅仅通过简单的配置就可以拥有和维护属于自己的博客网站。</p>
<h2 id="本地基础开发环境准备"><a class="markdownIt-Anchor" href="#本地基础开发环境准备"></a> 本地基础开发环境准备</h2>
<ul>
<li><a href="https://nodejs.org/">Node.js</a></li>
</ul>
<p>下载后依据导航安装即可，推荐下载长期支持版（LTS）。</p>
<ul>
<li><a href="https://git-scm.com/">Git</a></li>
</ul>
<p>下载后依据导航安装即可，Git安装过程中会有很多的配置选项，如果有特定需求的话（了解其各个配置选项的含义）可以按需配置，否则就按照推荐选项进行安装即可。</p>
<p>安装完成后，右键的下拉菜单中就会出现Git相关的功能选项。</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_rightclick.png" alt="" /></p>
<h2 id="hexo环境搭建"><a class="markdownIt-Anchor" href="#hexo环境搭建"></a> hexo环境搭建</h2>
<p>在基本环境准备完成后，即可开始hexo相关的下载和安装。</p>
<p>在预先准备好的文件夹下（如 E:/Blog/），右键打开下拉菜单，点击Git Bash Here，输入下面的命令后点击回车键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_gitbush.png" alt="" /></p>
<p>完成后，再执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>完成后，对应文件夹中出现内容，目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>以上各文件各有作用，和我们博客最后的表现息息相关，在具体配置和使用时我们再做详细介绍。</p>
<p>最后执行以下命令完成配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>在等待上述命令执行完成后，可以在命令行键入以下命令启动hexo服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>此时，本地服务启动成功，可以在浏览器中键入<code>http://localhost:4000/</code> 来尝试访问默认的博客模板，<br />
出现以下页面即表示着前面的安装过程没有出现问题：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_defaultpage.png" alt="" /></p>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>在文件夹中找到 <code>_config.yml</code> 文件，该文件即是博客的主要配置文件，其中包含了绝大部分关于网站的我们可以自定义的部分。</p>
<p>预想要完成博客的个性化定制，需要对该文件各个部分的配置内容有个大概的了解。这里罗列一些核心部分，剩余部分的配置建议参考 <a href="https://hexo.io/zh-cn/docs/configuration">官方网站的内容</a> 。</p>
<p>当然，如果对美观和个性化没有需求的话，这一小节可以暂时先掠过，先进行后面的阅读。</p>
<h3 id="site"><a class="markdownIt-Anchor" href="#site"></a> Site</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: </span><br><span class="line">subtitle: </span><br><span class="line">description: </span><br><span class="line">keywords: </span><br><span class="line">author: </span><br><span class="line">language: </span><br><span class="line">timezone: </span><br></pre></td></tr></table></figure>
<p>这里是网站的一些主要属性的配置，其中各项代表的含义为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">网站标题</td>
</tr>
<tr>
<td style="text-align:center">subtitle</td>
<td style="text-align:center">网站副标题</td>
</tr>
<tr>
<td style="text-align:center">description</td>
<td style="text-align:center">网站描述</td>
</tr>
<tr>
<td style="text-align:center">keywords</td>
<td style="text-align:center">网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td style="text-align:center">author</td>
<td style="text-align:center">您的名字</td>
</tr>
<tr>
<td style="text-align:center">language</td>
<td style="text-align:center">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</td>
</tr>
<tr>
<td style="text-align:center">timezone</td>
<td style="text-align:center">网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</td>
</tr>
</tbody>
</table>
<h3 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https://claude-jhin.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure>
<p>这里是关于网站url的一些配置相关的内容，主要作用是对url进行美化。</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">后键入自己准备好的域名，我这里使用的是github提供的免费域名。</td>
</tr>
<tr>
<td style="text-align:center">permalink</td>
<td style="text-align:center">表示的是每一个我们编辑的markdown博客文件应该是以什么样子的域名来显示的，默认是以年+月+日+文章名字的形式。</td>
</tr>
<tr>
<td style="text-align:center">permalink_defaults</td>
<td style="text-align:center">是对permalink给出一个默认值。</td>
</tr>
<tr>
<td style="text-align:center">trailing_index</td>
<td style="text-align:center">是否为博客文件保留<code>index.html</code> 的后缀</td>
</tr>
<tr>
<td style="text-align:center">trailing_html</td>
<td style="text-align:center">是否为博客文件保留<code>.html</code> 的后缀</td>
</tr>
</tbody>
</table>
<h3 id="home-page-setting"><a class="markdownIt-Anchor" href="#home-page-setting"></a> Home page setting</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;) 博客索引页的根目录</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination) 每一页显示的文章数量</span><br><span class="line"># order_by: Posts order. (Order by date descending by default) 文章的排序方式</span><br><span class="line">index_generator:</span><br><span class="line">path: &#x27;&#x27;</span><br><span class="line">per_page: 10</span><br><span class="line">order_by: -date</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">博客索引页的根目录</td>
</tr>
<tr>
<td style="text-align:center">per_page</td>
<td style="text-align:center">每一页显示的文章数量</td>
</tr>
<tr>
<td style="text-align:center">order_by</td>
<td style="text-align:center">文章的排序方式</td>
</tr>
</tbody>
</table>
<h3 id="extension"><a class="markdownIt-Anchor" href="#extension"></a> Extension</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">theme</td>
<td style="text-align:center">所选择的主题，主题下载后保存在根目录的themes文件夹下，通过这里指定加载的主题。</td>
</tr>
</tbody>
</table>
<h2 id="写作"><a class="markdownIt-Anchor" href="#写作"></a> 写作</h2>
<h3 id="创建文章"><a class="markdownIt-Anchor" href="#创建文章"></a> 创建文章</h3>
<p>新建文章的指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>其中 [layout] 默认有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">布局</th>
<th style="text-align:center">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">post</td>
<td style="text-align:center">source/_posts</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">source</td>
</tr>
<tr>
<td style="text-align:center">draft</td>
<td style="text-align:center">source/_drafts</td>
</tr>
</tbody>
</table>
<p>在创建这三种不同类型的文件时，它们将会被保存到不同的路径。但是默认来说我们基本只需要用到post，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new post &quot;文章名字&quot;</span><br></pre></td></tr></table></figure>
<p>执行上面命令后，在source/_posts文件夹下就会生成对应的md文件，按照md格式进行文档的编辑即可。</p>
<p>截取本文的编辑界面如下：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_content.png" alt="" /></p>
<h3 id="配置文章属性front-matter"><a class="markdownIt-Anchor" href="#配置文章属性front-matter"></a> 配置文章属性（Front-matter）</h3>
<p>与博客一样，每篇文章除了内容以外，还有自己的属性，如建立时间、更行时间、分类和标签等。</p>
<p>博客模板会利用这些属性来自动实现一些高级的功能，如显示博客文章时间戳，按照分类来讲文章进行归档等。<br />
post模板会自动帮助我们创建出title，date和tags，此外还有一些其他内容，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">标题</td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">文件建立日期</td>
</tr>
<tr>
<td style="text-align:center">updated</td>
<td style="text-align:center">更新日期	文件更新日期</td>
</tr>
<tr>
<td style="text-align:center">comments</td>
<td style="text-align:center">开启文章的评论功能（true/false）</td>
</tr>
<tr>
<td style="text-align:center">tags</td>
<td style="text-align:center">标签（不适用于分页）</td>
</tr>
<tr>
<td style="text-align:center">categories</td>
<td style="text-align:center">分类（不适用于分页）</td>
</tr>
</tbody>
</table>
<p>如本文的Front-matter：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 快速建站方案（hexo + next）全面记录</span><br><span class="line">date: 2022-03-23 21:35:53</span><br><span class="line">updated: 2022-03-24 20:00:00</span><br><span class="line">comments: true</span><br><span class="line">tags:</span><br><span class="line">  - 前端</span><br><span class="line">categories: </span><br><span class="line">  - hexo</span><br></pre></td></tr></table></figure>
<h2 id="next主题"><a class="markdownIt-Anchor" href="#next主题"></a> next主题</h2>
<h3 id="主题下载与加载"><a class="markdownIt-Anchor" href="#主题下载与加载"></a> 主题下载与加载</h3>
<p>在hexoblog文件夹下打开命令行，键入并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>等待完成后，有：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_nextexplorer.png" alt="" /></p>
<p>在hexoblog下的_config.yml里配置theme即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<h3 id="预览"><a class="markdownIt-Anchor" href="#预览"></a> 预览</h3>
<p>在hexoblog文件夹下打开命令行，键入并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>有：</p>
<p>![](快速建站全面记录_hexo s.png)</p>
<p>此时就可以在浏览器中用 <code>http://localhost:4000/</code> 的地址来进行访问了。</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_localhost.png" alt="" /></p>
<p>但是注意，此时我们只是开启了一个本地服务，就是说，只能在我们开启服务时，在本地机器上进行访问，还没有发布到网络上供别人来查看。</p>
<h2 id="github-page准备"><a class="markdownIt-Anchor" href="#github-page准备"></a> github page准备</h2>
<p>在github上新建一个仓库，进入到 <code>General/Code and automation/Pages</code> 配置界面：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_githubpage.png" alt="" /></p>
<p>这里顺便需要去设置界面把SSH给配置了，方便后续的更新和维护，<a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh">具体操作</a> ，这里不做过多赘述。</p>
<p>下面就是把之前做的内容推送到远程仓库里。</p>
<h2 id="发布"><a class="markdownIt-Anchor" href="#发布"></a> 发布</h2>
<p>回到hexoblog文件夹下的_config.yml，将远程仓库相关内容键入（注意这里使用的是SSH地址）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Github用户名/Github用户名全小写.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>在hexoblog打开命令行，键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>生成静态页面内容后，再键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>如果是第一次的话，可能过程中还要填写github的用户名和密码，按导航完成即可。</p>
<p>等待完成后，过一段时间（取决于github的处理），访问仓库地址（如<code>https://claude-jhin.github.io/</code> ），可以看到本地仓库已经发布到了网页。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>到此，基本上完成了从零开始的一个博客搭建，当然对于有心人来讲，事情远远还没有完成。<br />
一篇篇博客的积累，一点点前端特性的尝试与引入，学习的乐趣，开发的乐趣，远不止于此。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>frontend</tag>
      </tags>
  </entry>
</search>
