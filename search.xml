<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎来到Claude的个人博客</title>
    <url>/2022/03/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<ul>
<li>Claude是谁？</li>
</ul>
<p>Claude是一名潜心游戏研发的开发者，致力于研究游戏开发中的种种技术，包括编程、渲染、动画、玩法等等。<br />
目前在做虚幻引擎的学习和研究，希望有一天能够引导做出自己的3A大作。</p>
<p>更多信息，可以点击右侧 <code>关于</code></p>
<ul>
<li>为什么要建立自己的博客网站呢？</li>
</ul>
<p>主要是希望能够通过这样一种方式作为自身能力的展示。作为游戏开发流水线中的程序一角，与策划和美术不同的是，程序除了游戏作品以外，很难拿出能够显示自身实力的东西，类似美术工作者的作品集和策划工作者的设定文案之类的。</p>
<p>所以自己这才想到去建立这样一个博客网站，一方面记录自己在游戏开发之路上所积累的技术点滴，另一方面也想要把一些东西共享出来。</p>
<p>此前自己已经在csdn和知乎上进行了一定量的博客文章撰写，但是考虑到有一些私人的东西希望自己管理，遂花了一些时间研究前端的内容，并且就一个方案（hexo框架）来实际落地自己的想法。</p>
<p>这第一篇文章，就把自己此时完成建站时的所思所想，记录下来。</p>
]]></content>
  </entry>
  <entry>
    <title>虚幻的细节</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    <content><![CDATA[<p>怎样才能说明你学会了某样东西呢？</p>
<p>通读了文档？学习了某篇超长的教程？还是成功做出了某个效果？</p>
<p>虚幻的官方文档篇幅甚巨，如果静下心来通读的话估计也就需要几周的时间；<br />
使用虚幻引擎的教程现在也非常多，其中时长最长者看完也不过几天。</p>
<p>就以虚幻引擎为例，现在基本大家都知道虚幻的lumen，nanite，更深入一点的像GameFeature，世界划分等。<br />
这些信息可以从很多来源获取到，比如我们去读某篇博主的文章，可能会介绍到ue5引入了lumen，它在提供全局光照支持方面提供了多少的便捷，<br />
但是真正这其中的细节有多少呢？我们仅仅需要知道的是引擎内lumen的勾选框在哪个位置吗？</p>
<p>笔者的观点是，我们对某项东西水平的高低，不在于泛泛而谈其功能，而是看所掌握的细节之多少。<br />
了解lumen能够做到什么只是第一步，了解其局限性，了解lumen如何与其他模块（如nanite）协作，等等，才能够让我们对其看得更加透彻，这样才能更加灵活得使用，甚至更进一步，自己去更具需要进行修改和调整。</p>
<p>这也是本篇文章的出发点。本文主要记录在使用虚幻引擎时所遇到、想到的细节。<br />
在文章的初期，内容会比较零散，在渐入佳境后，获得一定的积累量后，博主会尝试对已有内容进行重新组织和分类，使内容更具阅读性。</p>
<span id="more"></span>
<ol>
<li>构造脚本<code>Construction Script</code>的调用时机</li>
</ol>
<p>构造脚本入口节点被包含在构造脚本函数图表中，当把一个Actor添加到关卡中或当一个现有Actor在关卡中发生变化（移动，重新Compile时）会执行该事件。</p>
<ol start="2">
<li>宏<code>check(...)</code></li>
</ol>
<p>如PlayerController里：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">check</span>(PlayerInput);</span><br></pre></td></tr></table></figure>
<p>其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> check(expr)				UE_CHECK_IMPL(expr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Technically we could use just the _F version (lambda-based) for asserts</span></span><br><span class="line"><span class="comment">// both with and without formatted messages. However MSVC emits extra</span></span><br><span class="line"><span class="comment">// unnecessary instructions when using a lambda; hence the Exec() impl.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UE_CHECK_IMPL(expr) \</span></span><br><span class="line"><span class="meta">    &#123; \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span>(UNLIKELY(!(expr))) \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">            struct Impl \</span></span><br><span class="line"><span class="meta">            &#123; \</span></span><br><span class="line"><span class="meta">                static void FORCENOINLINE UE_DEBUG_SECTION ExecCheckImplInternal() \</span></span><br><span class="line"><span class="meta">                &#123; \</span></span><br><span class="line"><span class="meta">                    FDebug::CheckVerifyFailedImpl(#expr, __FILE__, __LINE__, PLATFORM_RETURN_ADDRESS(), TEXT(<span class="string">&quot;&quot;</span>)); \</span></span><br><span class="line"><span class="meta">                &#125; \</span></span><br><span class="line"><span class="meta">            &#125;; \</span></span><br><span class="line"><span class="meta">            Impl::ExecCheckImplInternal(); \</span></span><br><span class="line"><span class="meta">            PLATFORM_BREAK(); \</span></span><br><span class="line"><span class="meta">            CA_ASSUME(false); \</span></span><br><span class="line"><span class="meta">        &#125; \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNLIKELY(x)			(!!(x))</span></span><br></pre></td></tr></table></figure>
<p>即如果expr为false，则会去执行内定的检查，并且停止执行程序。</p>
<p>参考：<a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/ProgrammingWithCPP/Assertions/">虚幻 4.26 Documentation - Assertions</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
      </tags>
  </entry>
  <entry>
    <title>ActionRPG中的Gameplay Ability System拆解（更新中）</title>
    <url>/2022/04/07/ActionRPG%E4%B8%AD%E7%9A%84Gameplay-Ability-System%E6%8B%86%E8%A7%A3/</url>
    <content><![CDATA[<p>本文是对虚幻官方Gameplay Ability System（GAS）的示例项目ActionRPG的详细代码向拆解，<br />
将会涵盖GAS在代码和蓝图方面的各项配置和应用，旨在通过分析GAS的各种细节而掌握GAS的用法，<br />
为未来的游戏项目做准备。</p>
<p>关于方法，我希望是以工匠的态度，细致入微得深入代码的骨髓中，<br />
具体做法就是逐代码得阅读和分析，可能会加入一定量GAS以外的内容，所以本文的内容可能会非常庞大。<br />
我并不想在文章体量上做任何妥协，<br />
因为本文除了作为这次的研究学习成果外，<br />
也希望能作为未来一段时间使用GAS及虚幻引擎内其他与之相关的内容的参考文档。</p>
<span id="more"></span>
<h2 id="代码分析"><a class="markdownIt-Anchor" href="#代码分析"></a> 代码分析</h2>
<h3 id="actionrpg"><a class="markdownIt-Anchor" href="#actionrpg"></a> ActionRPG</h3>
<p><code>ActionRPG.h</code>头文件会被项目中的所有头文件所包含，所以如果有什么所有类都需要用到的东西的话，<br />
放在这里是最合适的。</p>
<p>其内包含了两个重要的头文件：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;EngineMinimal.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/Engine.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p><code>EngineMinimal.h</code>中是一系列重要头文件的包含，截取一些我们常用的列举如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// UObject core</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CoreUObject.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Actor based classes</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Character.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/Controller.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/PlayerController.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;GameFramework/GameModeBase.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ActorComponent based classes</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/ActorComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/SceneComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/StaticMeshComponent.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Components/InputComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Other</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/World.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Engine/StaticMesh.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<p>正如其命名，它是我们开发游戏时所需要用到的模块的一个最小（minimal）集合。<br />
与之相对的，<code>Engine.h</code>是一个更加大而且全的包含，内容量大概是<code>EngineMinimal.h</code>的三倍之多，<br />
所以相对应的，如果是包含<code>Engine.h</code>会直接包含更多的模块，但是相应的编译速度也会大大减慢。</p>
<p>接下来<code>ActionRPG.h</code>内还做了一个事情就是声明并且定义全局的Log Category，<br />
Category会在Log中体现出来，以便在茫茫Log中更容易区分其作用或所属模块。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DECLARE_LOG_CATEGORY_EXTERN</span>(LogActionRPG, Log, All);</span><br></pre></td></tr></table></figure>
<p>对应在在<code>ActionRPG.cpp</code>中有其定义：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">DEFINE_LOG_CATEGORY</span>(LogActionRPG);</span><br></pre></td></tr></table></figure>
<p>两者成对存在，这样在包含该头文件的文件中就可以使用<code>UE_LOG(LogTemp, Warning, TEXT(&quot;Your message&quot;));</code>来进行日志的打印。</p>
<p>此外，在<code>ActionRPG.cpp</code>中还进行了一个工作，即<code>IMPLEMENT_PRIMARY_GAME_MODULE( FDefaultGameModuleImpl, ActionRPG, &quot;ActionRPG2022&quot; );</code>，<br />
是对本模块进行注册，并指定为主模块，UBT（UnrealBuildTool）会将其编译为对应的模块。</p>
]]></content>
      <categories>
        <category>虚幻</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>C++</tag>
        <tag>GAS</tag>
        <tag>Gameplay</tag>
      </tags>
  </entry>
  <entry>
    <title>bat批处理笔记</title>
    <url>/2022/08/27/bat%E6%89%B9%E5%A4%84%E7%90%86%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%89%B9%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8Fbat">什么是批处理程序（.bat）？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E7%BC%96%E8%BE%91bat">如何编辑<code>.bat</code>？</a></li>
<li><a href="#bat%E7%9A%84%E5%8A%9F%E7%94%A8"><code>.bat</code>的功用</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E7%9A%84bat%E6%96%87%E4%BB%B6">基本的<code>.bat</code>文件</a></li>
<li><a href="#%E5%91%BD%E4%BB%A4%E5%88%86%E7%B1%BB">命令分类</a>
<ul>
<li><a href="#%E5%86%85%E9%83%A8%E5%91%BD%E4%BB%A4">内部命令</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E5%91%BD%E4%BB%A4">外部命令</a></li>
</ul>
</li>
</ul>
</p>
<span id="more"></span>
<h1 id="批处理入门"><a class="markdownIt-Anchor" href="#批处理入门"></a> 批处理入门</h1>
<h2 id="什么是批处理程序bat"><a class="markdownIt-Anchor" href="#什么是批处理程序bat"></a> 什么是批处理程序（.bat）？</h2>
<p>Batch file programming是微软操作系统自带原生的开发语言，是不需要构建任何环境就可以执行的脚本。</p>
<p>Batch file（后续简称为<code>.bat</code>）批处理文件采用cmd.exe执行。</p>
<h2 id="如何编辑bat"><a class="markdownIt-Anchor" href="#如何编辑bat"></a> 如何编辑<code>.bat</code>？</h2>
<p>任意文本编辑工具（text工具，代码环境等）</p>
<h2 id="bat的功用"><a class="markdownIt-Anchor" href="#bat的功用"></a> <code>.bat</code>的功用</h2>
<p>使用一系列内置命令进行自动化操作</p>
<ul>
<li>匹配规则删除文件</li>
<li>新建文件、日志等</li>
<li>批量创建计算机病毒</li>
</ul>
<h2 id="基本的bat文件"><a class="markdownIt-Anchor" href="#基本的bat文件"></a> 基本的<code>.bat</code>文件</h2>
<p>输出 hello world</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">Echo &quot;hello world&quot;</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>
<p><code>@echo off</code>会取消显示当前的盘符；<br />
<code>pause</code>则是在程序执行完成之后继续停留在命令行；</p>
<h2 id="命令分类"><a class="markdownIt-Anchor" href="#命令分类"></a> 命令分类</h2>
<h3 id="内部命令"><a class="markdownIt-Anchor" href="#内部命令"></a> 内部命令</h3>
<p>cls ipconfig等</p>
<h3 id="外部命令"><a class="markdownIt-Anchor" href="#外部命令"></a> 外部命令</h3>
<p>java，python等</p>
]]></content>
      <categories>
        <category>Tricks</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Http原理入门</title>
    <url>/2022/08/25/Http%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">请求报文</a>
<ul>
<li><a href="#%E8%AF%B7%E6%B1%82%E8%A1%8Crequestline">请求行（requestline）</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E5%A4%B4%E9%83%A8header">请求头部（header）</a></li>
<li><a href="#%E7%A9%BA%E8%A1%8C">空行</a></li>
<li><a href="#%E8%AF%B7%E6%B1%82%E4%BD%93">请求体</a></li>
</ul>
</li>
<li><a href="#%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">响应报文</a>
<ul>
<li><a href="#%E7%8A%B6%E6%80%81%E8%A1%8C">状态行</a></li>
</ul>
</li>
<li><a href="#%E5%93%8D%E5%BA%94%E5%A4%B4%E9%83%A8">响应头部</a></li>
<li><a href="#%E7%A9%BA%E8%A1%8C-2">空行</a></li>
<li><a href="#%E5%93%8D%E5%BA%94%E4%BD%93">响应体</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="http服务器用途"><a class="markdownIt-Anchor" href="#http服务器用途"></a> Http服务器用途</h1>
<ul>
<li>用于Web服务器访问网站</li>
<li>上传，下载</li>
<li>注册，登录，数据请求交互操作</li>
<li>服务器GM封号，限制登录，发放道具，后台充值</li>
<li>其他企业级应用的数据获取</li>
</ul>
<h1 id="http工作原理"><a class="markdownIt-Anchor" href="#http工作原理"></a> Http工作原理</h1>
<p>Http协议采用请求/响应模型——客户端向服务器发送请求报文，服务器以一个状态作为响应。</p>
<p>客户端和服务器进行一次交互的过程主要可以拆解为一下5步：</p>
<ol>
<li>客户端连接到Http服务器：Http客户端与Web服务器建立一个TCP连接</li>
<li>客户端向服务器发起Http请求：客户端通过已建立的TCP连接向服务器发送一个请求报文</li>
<li>服务器受到Http请求，并返回Http响应：服务器解析请求，定位请求资源，服务器将资源副本写道TCP连接，由客户端进行读取</li>
<li>释放TCP连接：若connection模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接；若connection模式为keep-alive，则该连接会保持一段时间，在该时间内可以继续接收请求</li>
<li>客户端浏览器解析html内容：客户端将服务器响应的信息进行解析</li>
</ol>
<h1 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h1>
<p>何为URL？URL全拼Uniform Resource Locator，即统一资源定位符，我们俗称的网址一般就是指它。</p>
<p>组成：</p>
<ul>
<li>传送协议、层级URL标记符号（“//”）</li>
<li>传送资源需要的凭证信息（可省略）</li>
<li>服务器（通常为域名，有时为IP地址）</li>
<li>端口号（以数字方式表示，若为Http的默认值“：80”可省略）</li>
<li>路径（以“/”区分路径中的各级目录）</li>
<li>查询（GET模式的窗体参数，以“?”字符为起点，每个参数以“&amp;”隔开，再以“=”分开参数名称与数据，通常以UTF8的URL编码，避开字符冲突）</li>
</ul>
<p>在浏览器内键入某个URL，其内部一般具体会有以下的流程：</p>
<ol>
<li>浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址</li>
<li>之后，根据IP地址和默认端口80，和服务器建立TCP连接</li>
<li>浏览器发送出读取文件的Http请求</li>
<li>服务器对浏览器请求做出响应，将对应的请求数据发送给浏览器</li>
<li>释放TCP连接</li>
<li>浏览器将对应数据进行显示</li>
</ol>
<h1 id="报文"><a class="markdownIt-Anchor" href="#报文"></a> 报文</h1>
<h2 id="请求报文"><a class="markdownIt-Anchor" href="#请求报文"></a> 请求报文</h2>
<p>请求报文的结构：</p>
<p><img src="Http%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/Http_%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.jpg" alt="" /></p>
<h3 id="请求行requestline"><a class="markdownIt-Anchor" href="#请求行requestline"></a> 请求行（requestline）</h3>
<ul>
<li>请求方法</li>
</ul>
<p><code>GET</code>方法主要用于查询和下载，参数直接显示在地址栏中，不适合传递私密数据，也不适合传递大量数据；<br />
<code>POST</code>方法常用于游戏行业，将数据封装在请求数据中，对数据量没有限制，不会显示在地址栏中；<br />
<code>PUT</code>方法主要用于上传，将资源存放到指定位置，与<code>POST</code>的区别主要体现在是否指定存放位置（<code>POST</code>是服务器自己决定位置）；<br />
<code>HEAD</code><br />
<code>DELETE</code><br />
<code>OPTIONS</code><br />
<code>TRACE</code><br />
<code>CONNECT</code></p>
<ul>
<li>请求URL（不包括域名）</li>
<li>HTTP协议版本</li>
</ul>
<figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="code"><pre><span class="line">POST /user HTTP/1.1 \r\n</span><br></pre></td></tr></table></figure>
<h3 id="请求头部header"><a class="markdownIt-Anchor" href="#请求头部header"></a> 请求头部（header）</h3>
<ul>
<li>Content-Type</li>
</ul>
<figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attribute">HOST</span><span class="punctuation">: </span>www.user.com \r\n</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/json \r\n</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>11 \r\n</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>Keep-Alive \r\n</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0. \r\n</span><br></pre></td></tr></table></figure>
<h3 id="空行"><a class="markdownIt-Anchor" href="#空行"></a> 空行</h3>
<figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="code"><pre><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<h3 id="请求体"><a class="markdownIt-Anchor" href="#请求体"></a> 请求体</h3>
<p>待发送的数据</p>
<figure class="highlight http"><figcaption><span>request</span></figcaption><table><tr><td class="code"><pre><span class="line">name=world</span><br></pre></td></tr></table></figure>
<h2 id="响应报文"><a class="markdownIt-Anchor" href="#响应报文"></a> 响应报文</h2>
<h3 id="状态行"><a class="markdownIt-Anchor" href="#状态行"></a> 状态行</h3>
<ul>
<li>状态码</li>
</ul>
<h2 id="响应头部"><a class="markdownIt-Anchor" href="#响应头部"></a> 响应头部</h2>
<h2 id="空行-2"><a class="markdownIt-Anchor" href="#空行-2"></a> 空行</h2>
<h2 id="响应体"><a class="markdownIt-Anchor" href="#响应体"></a> 响应体</h2>
<p>请求报文的实体举例：</p>
<p><img src="Http%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8/Http_%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E7%A4%BA%E4%BE%8B.jpg" alt="" /></p>
]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Http</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻插件之Gameplay Ability System</title>
    <url>/2022/05/05/%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BGameplay-Ability-System/</url>
    <content><![CDATA[<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/5.0/en-US/gameplay-ability-system-for-unreal-engine/">虚幻 5.0 Documentation - Gameplay Ability System</a></p>
<p><a href="https://github.com/tranek/GASDocumentation">Github tranek 的仓库 - GASDocumentation</a></p>
<p><a href="https://vorixo.github.io/devtricks/gas/">Devtricks -  Unreal Engine 5 - The truth of the Gameplay Ability System</a></p>
<p><a href="https://www.bilibili.com/video/BV1X5411V7jh">b站 虚幻引擎官方 - 第31期｜GAS插件介绍（入门篇）</a></p>
<p><a href="https://www.bilibili.com/video/BV1Wy4y1j7RB">b站 虚幻引擎官方 - A Guided Tour of Gameplay Abilities</a></p>
<p>[UnrealOpenDay2020]深入GAS架构设计 | EpicGames 大钊 <a href="https://www.bilibili.com/video/BV1zD4y1X77M">https://www.bilibili.com/video/BV1zD4y1X77M</a></p>
<p>动作RPG：Gameplay Abilities System <a href="https://www.bilibili.com/video/BV1Ub411S71W">https://www.bilibili.com/video/BV1Ub411S71W</a></p>
<p>[真实字幕组]Action RPG Gameplay Abilities System <a href="https://www.bilibili.com/video/BV18J411M7jg">https://www.bilibili.com/video/BV18J411M7jg</a></p>
<p>[FestEurope2019]使用游戏玩法技能系统 | Using the Gameplay Ability System(官方汉化) <a href="https://www.bilibili.com/video/BV1gJ411J7AM">https://www.bilibili.com/video/BV1gJ411J7AM</a></p>
<p>[UnrealFestOnline2020]Gameplay Abilities Framework的优缺点(官方字幕) <a href="https://www.bilibili.com/video/BV1Y54y1e7VJ">https://www.bilibili.com/video/BV1Y54y1e7VJ</a></p>
<p><a href="https://www.bilibili.com/video/BV1vB4y1w7q6">https://www.bilibili.com/video/BV1vB4y1w7q6</a></p>
<p><a href="https://blog.csdn.net/pirate310/article/details/106311256">https://blog.csdn.net/pirate310/article/details/106311256</a></p>
<p><a href="https://www.cnblogs.com/JackSamuel/p/7155500.html">https://www.cnblogs.com/JackSamuel/p/7155500.html</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
        <category>GAS</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>C++</tag>
        <tag>GAS</tag>
        <tag>Gameplay</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之Level Streaming和World Composition</title>
    <url>/2022/05/05/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BLevel-Streaming%E5%92%8CWorld-Composition/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>再读《C++ Primer》（更新中）</title>
    <url>/2022/04/29/%E5%86%8D%E8%AF%BBC-Primer/</url>
    <content><![CDATA[<p>我的程序学习之路是自大学就开始了，但是真正第一次拜读《C++ Primer》这部公认的必读书籍却是从研究生阶段才开始的，当时我身在法国，从网上找了一本像模像样的电子版就开始了阅读学习。</p>
<p>其实第一次读完（其实也并没有读完，只是将学业要求内的知识点相关看完了），并没有感到什么所谓脱胎换骨的感觉，其中的很多知识点我从前就接触过，而一些新的细节的地方当时也没有仔细去做记录和研究，所以当时心中也并没有像其他读者那样将之封为神作。当然这段读书经历还是在很长一段时间作为了我自我炫耀的其中一项谈资，因为毕竟是耐着性子读完了一本七八百页的理论书，现在想想有这种炫耀的想法也说明了自己的不成熟。</p>
<p>但是随着学业和工作的不断深入，我愈发得感觉到自己对于某些内容、对于人生和学习等，产生了一些不同的理解，关于类，关于内存，关于对细节的执着，关于读书的习惯。我发觉这本书给我的影响比想象中要大的多。</p>
<p>彼时我使用C<ins>仅限于对图形图像的研究学习，同时，还学习了Python以及更多的，使用C#进行Unity相关内容的开发。此刻，我也在虚幻研究中探索了一段时间，虚幻引擎内对C</ins>的使用使我对这门语言又产生了一些不一样的理解。我觉得是时候了，去再翻开这本书，将初时阅读未竟的遗憾完成，也希望这个自己能够再次借着这本书，产生某种蜕变。</p>
<span id="more"></span>
<p><ul class="markdownIt-TOC">
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%BC%80%E5%A7%8B">第一章 开始</a>
<ul>
<li><a href="#11-%E7%AE%80%E5%8D%95%E7%9A%84c%E7%A8%8B%E5%BA%8F">1.1 简单的C++程序</a></li>
<li><a href="#12-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA">1.2 输入和输出</a></li>
<li><a href="#13-%E6%B3%A8%E9%87%8Acomments">1.3 注释（comments）</a></li>
<li><a href="#14-%E6%8E%A7%E5%88%B6%E6%B5%81">1.4 控制流</a><br />
*
<ul>
<li><a href="#while%E8%AF%AD%E5%8F%A5">while语句</a></li>
<li><a href="#for%E8%AF%AD%E5%8F%A5">for语句</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E8%AF%BB%E5%8F%96%E8%BE%93%E5%85%A5">循环读取输入</a></li>
<li><a href="#if%E8%AF%AD%E5%8F%A5">if语句</a></li>
</ul>
</li>
<li><a href="#15-%E7%B1%BB">1.5 类</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B">第二章 变量和基本类型</a>
<ul>
<li><a href="#21-%E5%9F%BA%E6%9C%AC%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">2.1 基本内置类型</a><br />
*
<ul>
<li><a href="#%E7%AE%97%E6%95%B0%E7%B1%BB%E5%9E%8B">算数类型</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
<li><a href="#%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F">字面值常量</a></li>
</ul>
</li>
<li><a href="#22-%E5%8F%98%E9%87%8F">2.2 变量</a><br />
*
<ul>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89">变量的定义</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E">变量的声明</a></li>
</ul>
</li>
<li><a href="#23-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B">2.3 复合类型</a><br />
*
<ul>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a></li>
<li><a href="#%E6%8C%87%E9%92%88">指针</a></li>
<li><a href="#%E7%BB%BC%E5%90%88%E7%90%86%E8%A7%A3%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8">综合理解指针和引用</a></li>
</ul>
</li>
<li><a href="#24-const%E9%99%90%E5%AE%9A%E7%AC%A6">2.4 const限定符</a><br />
*
<ul>
<li><a href="#const%E5%92%8C%E5%BC%95%E7%94%A8">const和引用</a></li>
<li><a href="#const%E5%92%8C%E6%8C%87%E9%92%88">const和指针</a></li>
<li><a href="#%E9%A1%B6%E5%B1%82const">顶层const</a></li>
<li><a href="#constexpr%E5%92%8C%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F">constexpr和常量表达式</a></li>
</ul>
</li>
<li><a href="#25-%E5%A4%84%E7%90%86%E7%B1%BB%E5%9E%8B">2.5 处理类型</a><br />
*
<ul>
<li><a href="#%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D">类型别名</a></li>
<li><a href="#auto%E7%B1%BB%E5%9E%8B%E8%AF%B4%E6%98%8E%E7%AC%A6">auto类型说明符</a></li>
<li><a href="#decltype%E7%B1%BB%E5%9E%8B%E6%8C%87%E7%A4%BA%E7%AC%A6">decltype类型指示符</a></li>
</ul>
</li>
<li><a href="#26-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">2.6 自定义数据结构</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84">第三章 字符串、向量和数组</a>
<ul>
<li><a href="#31-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84using%E5%A3%B0%E6%98%8E">3.1 命名空间的using声明</a></li>
<li><a href="#32-string">3.2 string</a><br />
*
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96">定义和初始化</a></li>
<li><a href="#string%E5%AF%B9%E8%B1%A1%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C">string对象上的操作</a></li>
</ul>
</li>
<li><a href="#33-vector">3.3 vector</a></li>
<li><a href="#34-%E8%BF%AD%E4%BB%A3%E5%99%A8">3.4 迭代器</a></li>
<li><a href="#35-%E6%95%B0%E7%BB%84">3.5 数组</a><br />
*
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-2">定义和初始化</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88">数组指针</a></li>
<li><a href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84">多维数组</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%A1%A8%E8%BE%BE%E5%BC%8F">第四章 表达式</a>
<ul>
<li><a href="#41-%E5%9F%BA%E7%A1%80">4.1 基础</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="第一章-开始"><a class="markdownIt-Anchor" href="#第一章-开始"></a> 第一章 开始</h2>
<h3 id="11-简单的c程序"><a class="markdownIt-Anchor" href="#11-简单的c程序"></a> 1.1 简单的C++程序</h3>
<p>函数（function）的四个部分：返回类型（return type），函数名（function name），形参列表（parameter list），函数体（function body）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回类型：int，函数名：main，形参列表：[空]，函数体：&#123;return 0;&#125;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型（type），定义了数据元素（变量）的内容，同时定义了该类数据可以进行的运算。</p>
<h3 id="12-输入和输出"><a class="markdownIt-Anchor" href="#12-输入和输出"></a> 1.2 输入和输出</h3>
<p>iostream库提供IO机制。</p>
<ul>
<li>istream表示输入流，使用cin的istream类型对象作为标准输入（standard input），从所运行的窗口读入；</li>
<li>ostream表示输出流，使用cout的ostream类型对象作为标准输出（standard output），此外标准库还定义了cerr和clog两个ostream类型的对象，分别用来输出错误信息和日志信息；这些信息也都是通过正在运行的程序窗口进行输出。</li>
</ul>
<p>流的本质就是字符序列，表示对特定的设备（如计算机）进行读取或者写入。</p>
<p>简单的输入输出示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 头文件引用，表明要使用iostream库</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 输出运算符（&lt;&lt;）左侧必须是一个ostream对象，右侧是要打印的值，</span></span><br><span class="line">	<span class="comment">// 表示将待打印的值写到给定的ostream对象cout上，用来在标准信息上打印消息</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 两个&lt;&lt;符号其实是链式编程思想的体现，</span></span><br><span class="line">	<span class="comment">// 即第一个运算符的结果成为第二个运算符的左侧对象，从而对输出请求进行连接</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二个要打印的是一个操纵符（manipulator）endl，</span></span><br><span class="line">	<span class="comment">// 意味着结束当前行，并把缓冲区（buffer）中的内容刷新到设备中</span></span><br><span class="line">	<span class="comment">// 刷新的操作可以保证产生的输出都真正写入到流中，避免输入停留在缓冲区，从而导致一些错误的判断</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// std::用来表明对象的命名空间（namespace），</span></span><br><span class="line">	<span class="comment">// std为标准库定义的所有名字的命名空间，::为作用域运算符</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输入运算符（&gt;&gt;）左侧必须是一个istream对象，表明从该对象读入数据，并存取到右侧对象上</span></span><br><span class="line">	std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印输出</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-注释comments"><a class="markdownIt-Anchor" href="#13-注释comments"></a> 1.3 注释（comments）</h3>
<p>程序会忽略注释（预处理器遇到注释会以空行替换），所以注释的作用是帮助代码的人类读者理解程序内容。</p>
<p>单行注释：以双斜线（//）开始，以换行符结束，其间所有内容都会被编译器所忽略，通常用于半行和单行附注；</p>
<p>界定符对注释（源自C语言）：以/<em>开始，以</em>/结束，通常用于多行解释。</p>
<p>简单用法示意如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 界定符对注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 单行注释</span></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Enter two numbers:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	<span class="type">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>; <span class="comment">// 半行注释（同样属于单行注释）</span></span><br><span class="line">	std::cin &gt;&gt; v1 &gt;&gt; v2;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;The sum of &quot;</span> &lt;&lt; v1 &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; v2 &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; v1 + v2 &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="14-控制流"><a class="markdownIt-Anchor" href="#14-控制流"></a> 1.4 控制流</h3>
<h5 id="while语句"><a class="markdownIt-Anchor" href="#while语句"></a> while语句</h5>
<p>反复执行一段代码（<em>statement</em>），直到给定条件（<em>condition</em>）为假。</p>
<p>形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (i &lt;= <span class="number">10</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 复合复制运算符（+=），将右侧的运算对象加到左侧运算对象上，将结果保存到左侧运算对象上</span></span><br><span class="line">		sum += i; <span class="comment">// 等价于 sum = sum + i</span></span><br><span class="line">		<span class="comment">// 后缀递增运算符（++），将运算对象的值增加1</span></span><br><span class="line">		i++；<span class="comment">// 等价于 i = i + 1</span></span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Sum of 1 to 10 inclusive is: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="for语句"><a class="markdownIt-Anchor" href="#for语句"></a> for语句</h5>
<p>是一种特定的针对变量递增（递减）的模式的循环语句，是对while的某种意义上的简化。</p>
<p>for语句的结构为循环头+循环体两部分。</p>
<p>循环头控制循环体的执行次数，它又更进一步由三部分组成：初始化语句（<em>init-statement</em>），循环条件（<em>condition</em>），以及表达式（<em>expression</em>）。</p>
<p>简化while中的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>, i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//while (i &lt;= 10)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	sum += i;</span></span><br><span class="line">	<span class="comment">//	i++;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += i;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Sum of 1 to 10 inclusive is: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="循环读取输入"><a class="markdownIt-Anchor" href="#循环读取输入"></a> 循环读取输入</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> sum = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 循环条件为std::cin &gt;&gt; val，本质上是判断对象cin是否为空，</span></span><br><span class="line">	<span class="comment">// 若输入错误，或遇到文件结束符（end-of——file，windows平台为Ctrl+Z），此时istream对象无效，从而结束循环</span></span><br><span class="line">	<span class="keyword">while</span> (std::cin &gt;&gt; val)</span><br><span class="line">	&#123;</span><br><span class="line">		sum += val;</span><br><span class="line">	&#125;</span><br><span class="line">	std::cout &lt;&lt; <span class="string">&quot;Sum is: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="if语句"><a class="markdownIt-Anchor" href="#if语句"></a> if语句</h5>
<p>对某个条件进行求值。</p>
<p>统计数字出现次数的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentVal = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span> (std::cin &gt;&gt; currentVal)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (std::cin &gt;&gt; val)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 使用相等运算符（==）来判断符号两侧的值是否相等，这与赋值运算符（=）是完全不同的</span></span><br><span class="line">			<span class="keyword">if</span> (val == currentVal)</span><br><span class="line">			&#123;</span><br><span class="line">				count++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				std::cout &lt;&lt; currentVal &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; times&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">				currentVal = val;</span><br><span class="line">				count = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		std::cout &lt;&lt; currentVal &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot; times&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-类"><a class="markdownIt-Anchor" href="#15-类"></a> 1.5 类</h3>
<p>类（class）定义了一种数据类型（设计目的与内置数据类型一样，如int，float等）的同时，还定义了与该类型相关联的一系列操作。</p>
<p>成员函数（member function）作为类的一部分而存在，有时候也称为是方法（method）。</p>
<p>成员函数通常是通过类的对象使用点运算符（.）来进行调用。点运算符的左侧是类类型的对象，右侧是该类型的一个成员名，运算结果是右侧对象的返回值。</p>
<p>而调用某个函数需要使用调用运算符（()），里面可以为空也可以放置实参列表（argument）。</p>
<h2 id="第二章-变量和基本类型"><a class="markdownIt-Anchor" href="#第二章-变量和基本类型"></a> 第二章 变量和基本类型</h2>
<p>数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作。</p>
<p>对象的数据类型定义了能够利用对象存储的数据以及这些数据可以参与的运算。</p>
<h3 id="21-基本内置类型"><a class="markdownIt-Anchor" href="#21-基本内置类型"></a> 2.1 基本内置类型</h3>
<p>包括算数类型（arithmetic type）和空类型（void）。其中算数类型包含字符，整型数，布尔值和浮点数；而空类型经常作为不返回任何值的函数的返回类型。</p>
<h5 id="算数类型"><a class="markdownIt-Anchor" href="#算数类型"></a> 算数类型</h5>
<p>算数类型分为两类：整型和浮点型（字符和布尔类型本质上属于整型）。</p>
<p>计算机以比特（bit）序列存储数据，每个比特非0即1。 可寻址的最小内存块称为字节（byte)，存储的基本单元称为字（word）。这三个概念的大小依次为：1个字可能4或8个字节构成，1个字节可能由8比特构成。</p>
<p>计算机中的每个字节都与一个地址（address）关联（这也是为什么字节是最小的可寻址内存块）。而为了赋予内存中某个地址明确的含义，必须先知道存储在该地址的数据的类型，类型会决定数据所占的比特数以及该如何解释这些比特背后所代表的含义。</p>
<p>除去布尔型和扩展的字符型外，其他整型可以划分为带符号的（signed）和无符号的（unsigned）。带符号类型可以表示正数，负数还有0，无符号类型就只能表示大于等于0的值。一般的基本类型都是带符号的，将带符号的类型转换为不带符号的只需要在类型前面添加unsigned，如unsigned int， unsigned long等等。</p>
<h5 id="类型转换"><a class="markdownIt-Anchor" href="#类型转换"></a> 类型转换</h5>
<p>某种类型的对象一般都具备参与某种运算的能力，比如int，float等可以进行四则运算，bool可用于作为条件进行判断（这一点一些其他类型也同样具备），类类型能够支持更复杂的使用，等等。</p>
<p>那么这些类型是否具备某种通用的能力？大部分编程语言，以及其中大部分类型都支持的一种——类型转换（convert），将某种给定类型转换为另一种<strong>相关</strong>类型。这种能够可以看作是编译器为了减少程序开发负担而设计的一种智能效果。</p>
<p>类型转换的原则就是：</p>
<ul>
<li>当转换的结果会导致丢失信息时（一般来说占比特数大的类型比占比特数小的类型所能承载更多的信息），需要进行舍去，如浮点型转整型，需要抹掉小数点的信息；</li>
<li>当转换的结果会导致能够容纳额外的信息时，需要进行信息的补充，如整型转浮点型，需要补充小数点后的0以增加精度；</li>
</ul>
<p>具体的细则：</p>
<ul>
<li>当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false，负责结果为true；</li>
<li>当我们把一个布尔值赋给整数类型时，初始值为false则结果为0，初始值为true则结果为1；</li>
<li>当我们把一个浮点数赋给整数类型时，进行近似处理。结果值将仅保留浮点数中小数点之前的部分；</li>
<li>当我们把一个整数值赋给浮点类型时，小数部分记为0、如果该整数所占的空间超过浮点类型的容量，精度可能会有损失；</li>
<li>当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数；</li>
<li>当我们赋给带符号类型一个超过它表示范围的值时，结果是未定义的（undefined）。此时程序可能会继续工作，也可能会崩溃，还可能会产生垃圾数据。（编程中尽量减少无法预知的行为）</li>
</ul>
<p>最后，切勿混用带符号类型和无符号类型，除非你了解背后的转换且故意这么做。</p>
<h5 id="字面值常量"><a class="markdownIt-Anchor" href="#字面值常量"></a> 字面值常量</h5>
<p>字面值常量（literal）的形式和值决定了它所属的数据类型。</p>
<p>整型字面值的数据类型依据值和符号来决定：</p>
<ul>
<li>十进制整型字面值是带符号数，其具体类型应当取<strong>能够容纳该数</strong>的<strong>最小</strong>的类型（int，long，long long）；</li>
<li>八进制和十六进制字面值既可能是带符号也可能是无符号的，其具体类型应当取<strong>能够容纳该数</strong>的<strong>最小</strong>的类型（int，unsigned int，long，unsinged long，long long，unsigned long long）。</li>
</ul>
<p>如果与该字面值关联的最大的数据类型都无法将其放下（完整描述信息），那么将会产生错误。</p>
<p>浮点型字面值表现为一个小数或者以科学计数法表示的指数，其中指数部分用E或e标识：</p>
<ul>
<li>浮点型字面值默认是double；</li>
</ul>
<p>char型字面值是一个以单引号括起来的一个字符，如’a’</p>
<p>字符串型字面值是一个以双引号括起来的字符串（长度可以为0），如&quot;a&quot;，“Hello”。字符串的本质是常量字符组成的数组（array）。与我们看到的所不同的是，实际上每个字符串会被编译器默认加上一个空字符（’\0’）作为真正的结尾，所以字符串字面值的实际长度要比其内容多1。</p>
<p>有两类字符我们是不能直接使用的：不可打印（nonprintable）字符，如退格等没有可视的图符的字符；有特殊含义的字符，如单引号，双引号，问好，反斜线等。</p>
<p>应对上述字符时，就需要用到转义序列就，以反斜线开始，配以特定字符，从而整体上被当作一个字符来对待（正如其名，转义序列（escape sequence）的作用就将字符原先的含义抹除掉，并赋以新的意义）：</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>用途</th>
<th>转义序列</th>
<th>用途</th>
<th>转义序列</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>\n</td>
<td>换行符</td>
<td>\t</td>
<td>横向制表符</td>
<td>\a</td>
<td>报警符</td>
</tr>
<tr>
<td>\v</td>
<td>纵向制表符</td>
<td>\b</td>
<td>退格符</td>
<td>&quot;</td>
<td>双引号</td>
</tr>
<tr>
<td>\</td>
<td>反斜线</td>
<td>?</td>
<td>问号</td>
<td>’</td>
<td>单引号</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
<td>\f</td>
<td>进纸符</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>此外，还可以通过指定前缀或后缀，改变整型、浮点型和字符型字面值的默认类型。</p>
<p>字符和字符串字面值前缀：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>含义</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u</td>
<td>Unicode 16字符</td>
<td>char16_t</td>
</tr>
<tr>
<td>U</td>
<td>Unicode 32字符</td>
<td>char32_t</td>
</tr>
<tr>
<td>L</td>
<td>宽字符</td>
<td>wchar_t</td>
</tr>
<tr>
<td>u8</td>
<td>UTF-8</td>
<td>char</td>
</tr>
</tbody>
</table>
<p>整型字面值后缀：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>u or U</td>
<td>unsigned</td>
</tr>
<tr>
<td>l or L</td>
<td>long</td>
</tr>
<tr>
<td>ll or LL</td>
<td>long long</td>
</tr>
</tbody>
</table>
<p>浮点型字面值后缀：</p>
<table>
<thead>
<tr>
<th>后缀</th>
<th>最小匹配类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>f or F</td>
<td>float</td>
</tr>
<tr>
<td>l or L</td>
<td>long double</td>
</tr>
</tbody>
</table>
<p>布尔字面值有两个：true，false。</p>
<p>指针字面值有：nullptr。</p>
<h3 id="22-变量"><a class="markdownIt-Anchor" href="#22-变量"></a> 2.2 变量</h3>
<p>变量本身代表着可以通过一个名字来对一段内存进行访问和操作，而变量的类型则决定具体占用内存的大小，以及该变量能够参与的运算等等。</p>
<p>当我们提到“变量”（variable），或者“对象”（object），要知道本质上说的是同一回事，都是<strong>具有某种数据类型的内存空间</strong>。</p>
<h5 id="变量的定义"><a class="markdownIt-Anchor" href="#变量的定义"></a> 变量的定义</h5>
<p>变量的定义由两部分组成：类型说明符（type specifier），变量名。在定义的时候可以顺便为变量赋予初始值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[type specifier] [变量名];</span><br><span class="line">[type specifier] [变量名<span class="number">1</span>], [变量名<span class="number">2</span>];</span><br><span class="line">[type specifier] [变量名] = [初始值];</span><br></pre></td></tr></table></figure>
<p>这里注意，初始化（initialized）不等于赋值，初始化是创建变量时赋予其一个初始值；而赋值则是抹除对象的当前值，并用替换一个新的值。</p>
<p>除却用=进行初始化，还有其他一些初始化方法，如使用小括号（()），花括号（{}），其中花括号的用法被称为是列表初始化（list initialization）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">a</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然，即便我们不用上述任何的初始化方法，变量依然会执行一个默认初始化（default initialization）操作，而此时这个默认值会由该变量的类型所决定。</p>
<p>内置类型的变量在函数之外进行定义时，会被默认初始化为0；某些情况下，内置类型变量不会自动初始化，这时视图拷贝或者进行其他操作将会引发错误。所以书上会建议我们初始化每一个内置类型的变量，当然我们知道并不是对每一个变量这个操作都是必须的，但是出于安全性考虑，这样不失为一个编程的好习惯。、</p>
<h5 id="变量的声明"><a class="markdownIt-Anchor" href="#变量的声明"></a> 变量的声明</h5>
<p>如果要在多个文件里使用同一个变量，就必须将变量的定义和声明分离。这样做的原因也显而易见——声明（declaration）规定了变量的名字和类型，使得名字被程序所知，而定义（definition）负责创建与名字所关联的实体（赋予初始值），这个实体只能是唯一的一份（不能重复定义），但是申明却可以有多次。这种做法就引出了C++语言中的分离式编译（separate compilation）机制，将头文件（一般用来存放申明）和cpp文件（用来实现定义）分开。</p>
<p>extern关键字被用来作声明用，但是要注意不能去显示初始化，否则会抵消掉extern的申明作用，从而完全变成了定义。</p>
<p>当我们在程序中引用别的文件中的类型时，可以在程序最上面直接引用头文件来用，也可以使用前置申明，再在后面补充引用。</p>
<p>C++是静态类型（statically typed）的语言，即在编译阶段进行类型检查（type checking），从而检查数据类型是否支持其所有罗列的运算，如果其中存在不支持进行的运算，那么编译器就会直接报错显示编译不通过。</p>
<h3 id="23-复合类型"><a class="markdownIt-Anchor" href="#23-复合类型"></a> 2.3 复合类型</h3>
<p>复合类型（compound type）是基于其他类型之上而进行定义的类型，最常见的就是引用和指针。</p>
<p>这里将前面提到的声明语句进行一个更严谨的定义：<code>基本数据类型（base type）+声明符（declarator）列表</code>。</p>
<p>其中声明符命名了一个变量并指定该变量为与基本数据类型相关的某种类型。在前面的例子中，声明符就是变量名，而变量的类型就是声明的基本数据类型。当然还有其他更复杂的声明符，从而得到一些基于基本数据类型的更加复杂的类型，并将其指定给变量。</p>
<h5 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h5>
<p>引用（reference）是为对象起了一个别名，其行为是引用（refer to）。其定义形式为（其声明符为<code>&amp;[别名]</code>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[数据类型] [变量名] = [值];</span><br><span class="line">[数据类型] &amp;[别名] = [变量名];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;rVal = val;</span><br></pre></td></tr></table></figure>
<p>引用本身并不是一个对象，必须初始化（进行绑定操作），且不能重新绑定（bind）另一个对象。</p>
<h5 id="指针"><a class="markdownIt-Anchor" href="#指针"></a> 指针</h5>
<p>指针（pointer）是用某种类型的指针对象存储该类型数据的地址，其行为是指向（point to）。其定义形式为（其声明符为<code>*[指针名]</code>）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[数据类型] [变量名] = [值];</span><br><span class="line">[数据类型] *[指针名];</span><br><span class="line">[数据类型] *[指针名] = &amp;[变量名];</span><br><span class="line">*[指针名];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *p;</span><br><span class="line"><span class="type">int</span> *p1 = &amp;val;</span><br><span class="line">*p1;</span><br></pre></td></tr></table></figure>
<p>其中，获取某个对象的地址需要用到取址符（&amp;）。访问指向的对象可以利用解引用符（*）（对于有效指针来说适用）。</p>
<p>与引用相同，指针也被用来简介访问某个对象。而与引用不同的是，指针本身就是一个对象，可以在定义时不进行初始化，也可以在指向某个对象后再改变指向。</p>
<p>指针的值会出于以下四个状态之一：</p>
<ul>
<li>指向某个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针</li>
<li>无效指针</li>
</ul>
<p>其中空指针（null pointer）是指不指向任何对象的指针，可以用字面值nullptr或者0直接初始化指针从而生成空指针。空指针不属于无效指针。所以为了避免出现使用无效指针的情况出现，用声明空指针的形式来声明所有的指针（可以随后更改指针的指向是一个推荐的编程习惯。</p>
<h5 id="综合理解指针和引用"><a class="markdownIt-Anchor" href="#综合理解指针和引用"></a> 综合理解指针和引用</h5>
<p>这里再次强调<code>基本数据类型（base type）+声明符（declarator）列表</code>的提法，操作符*和操作符&amp;都是声明符的一部分，而不是基本数据类型的构成部分。</p>
<p>所以在同一行声明多个变量时，可以有以下的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> val, *pVal, &amp;rVal = val;</span><br></pre></td></tr></table></figure>
<h3 id="24-const限定符"><a class="markdownIt-Anchor" href="#24-const限定符"></a> 2.4 const限定符</h3>
<p>利用关键字const可以对变量的类型加以限定，从而限制变量的值的发生改变的行为，这样，就把该变量定义为了一个常量，任何试图改变该值的行为都将引发错误。</p>
<p>因为const对象一旦创建其值就不能改变，所以const对象必须初始化，否则也将引发错误。</p>
<p>此外const也可以和extern联用，即在某个文件中进行定义，其他文件通过引用头文件及声明的方式进行使用。</p>
<h5 id="const和引用"><a class="markdownIt-Anchor" href="#const和引用"></a> const和引用</h5>
<p>即对常量的引用，这个引用不能被用作修改它所绑定的对象。</p>
<p>形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> [数据类型] [变量名] = [初始化值];</span><br><span class="line"><span class="type">const</span> [数据类型] &amp;[别名] = [变量名];</span><br></pre></td></tr></table></figure>
<p>此时，不能去修改变量的值，也就不能通过引用去修改相应的变量。</p>
<p>注意，不能用非常量引用去指向一个常量对象；但是相对的，可以用一个常量引用去指向一个非常量的对象，比如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span> &amp;ri = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;cri = i;</span><br></pre></td></tr></table></figure>
<p>此时，i的值我们知道是可以随意修改的，对const的引用却无法用来修改相应的绑定的值，所以这里的情况是，const限定了我们不能用cri来修改i的值，但是可以通过其他诸多方法来实现修改（比如直接对i进行赋值）。</p>
<p>前面我们提到，正常情况下，引用的类型必须和其所引用对象的类型一致。这一点当然没错，但是某些写法下，会令我们产生一些误解，比如说如下的写法也是正确的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = dval;</span><br></pre></td></tr></table></figure>
<p>实际上，是编译器为我们做了中间的转换工作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> temp = dval;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = temp;</span><br></pre></td></tr></table></figure>
<p>这种情况下，编译器帮我们建立了一个临时量（temporary）对象。这个对象的本质是当编译器需要一个空间来暂存表达式的求值结果时创建的一个未命名的对象。</p>
<p>上面的例子中，把const拿掉是否也合法？实际测试结果是并不允许，C++并不允许把引用绑定到临时量上（上面的结果是常量引用绑定到一个临时量常量上，虽然这个说法并不严谨）。</p>
<h5 id="const和指针"><a class="markdownIt-Anchor" href="#const和指针"></a> const和指针</h5>
<p>常量指针和指针常量。</p>
<p>常量指针即指向常量的指针（pointer to const），不能用于改变其所指的对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> [数据类型] [变量名] = [初始化值];</span><br><span class="line"><span class="type">const</span> [数据类型] *[别名] = &amp;[变量名];</span><br></pre></td></tr></table></figure>
<p>同常量引用一样，常量指针更多的是限定不能通过该指针去修改指向的值，若是本身指向的对象存在其他修改方法的话，是不影响的。</p>
<p>指针常量即指针本身是一个常量（const pointer），意味着指针本身的指向不能发生改变（指针存储的内存地址被限定不能修改），所以是可以通过这个指针去修改指向的值的。</p>
<p>形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[数据类型] [变量名] = [初始化值];</span><br><span class="line">[数据类型] <span class="type">const</span> *[别名] = &amp;[变量名];</span><br></pre></td></tr></table></figure>
<p>这里也体现了指针和引用的区别：指针本身就是一个对象，所以才存在常量指针这种东西。</p>
<h5 id="顶层const"><a class="markdownIt-Anchor" href="#顶层const"></a> 顶层const</h5>
<p>上面指针的使用中，体现了对const的两种用法，我们称之为顶层const（top-level const）和底层const（low-level const）。顶层const意味着我们对任意数据类型的数据对象都能加以限制，成为常量，如指针常量的用法；而底层const实际上是对复合类型的基础类型加以限定，如常量指针。</p>
<h5 id="constexpr和常量表达式"><a class="markdownIt-Anchor" href="#constexpr和常量表达式"></a> constexpr和常量表达式</h5>
<p>常量表达式（const expression）是指值不会改变并且在编译过程中就能得到计算结果的表达式。需要运行时得到结果的表达式不是常量表达式。</p>
<p>显著的两个要素是：const数据类型，以及初始值（比如是否是字面值或常量，或是否可以通过字面值或常量得到）。</p>
<p>当然，即便做出这样的总结，有时候还是很难看出某个表达式是否是常量表达式，所以C++中引入了constexpr关键字来让编译器帮忙验证变量的值是否是一个常量表达式。</p>
<p>声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化（以及一种特殊的constexpr函数）。</p>
<p>在声明constexpr时用到的类型我们设定为字面值类型（literal type），包括有算数类型，引用，指针等。自定义的类以及标准库内的一些内容都不属于字面值类型。</p>
<p>constexpr需要和const区别对待，并不能划等号。比如constexpr会把其定义的对象置为顶层const，如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> *q = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>这里的p时常量指针，q是指针常量。</p>
<h3 id="25-处理类型"><a class="markdownIt-Anchor" href="#25-处理类型"></a> 2.5 处理类型</h3>
<h5 id="类型别名"><a class="markdownIt-Anchor" href="#类型别名"></a> 类型别名</h5>
<p>类型别名（type alias）的含义并没有想象的那么复杂，其代表着给类型起一个其他的名字（就类似于给变量起别名一样）。</p>
<p>在C++中，现在有两种方法可以用于定义类型别名：</p>
<ul>
<li>使用关键字typedef；</li>
<li>使用别名声明（alias declaration）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> [类型名] [类型别名];</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> [类型别名] = [类型名];</span><br></pre></td></tr></table></figure>
<h5 id="auto类型说明符"><a class="markdownIt-Anchor" href="#auto类型说明符"></a> auto类型说明符</h5>
<p>auto的用法，就是就是让编译器代替我们去分析表达式所属的类型。auto会根据变量的初始值来判断变量的类型（所以用auto定义的变量必须有初始值）。</p>
<p>注意：因为一条语句只能有一个基本数据类型，所以即便是auto语句中，也只能对应一种基本数据类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> [变量名] = [初始值];</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>上面的例子中auto会根据初始值10被推断为int，并以该初始值赋对a进行初始化；</p>
<h5 id="decltype类型指示符"><a class="markdownIt-Anchor" href="#decltype类型指示符"></a> decltype类型指示符</h5>
<p>decltype的用法和auto完全不一样，auto是根据初始值进行推断，而decltype是根据给定的函数的返回值进行类型的推断，跟初始值无关联，甚至不强制要求赋予初始值（引用等必须要求初始值的情况除外）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>([函数名]()) [变量名];</span><br><span class="line"><span class="keyword">decltype</span>([函数名]()) [变量名] = [初始值];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">f</span>()) a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(i) d;</span><br></pre></td></tr></table></figure>
<p>这里a的类型就是f()的返回值的类型，即int类型，d的类型就是i的类型，也为int。</p>
<p>此外存在一种特殊情况，decltype的表达式如果是加上括号的变量，结果将是一个引用（而引用，必须初始化）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) e = a;</span><br></pre></td></tr></table></figure>
<h3 id="26-自定义数据结构"><a class="markdownIt-Anchor" href="#26-自定义数据结构"></a> 2.6 自定义数据结构</h3>
<p>本小节将会探讨简单的自定义数据结构，即仅具备数据成员（data member）的类。在定义该类数据类型时，需要使用关键字struct。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> [类名]</span><br><span class="line">&#123;</span><br><span class="line">    [数据成员]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用class，但是要知道仅从作用上来讲，两者是一致的。通常习惯上来讲，我们把用struct定义的类称为是结构体，用class定义的类称为是类。</p>
<p>其中，数据成员部分可以提供一个类内初始值，创建对象时，类内初始值可以用于对数据成员的初始化。</p>
<p>前面小节提到过C++的分离式编译，可以将一个类拆在头文件和cpp文件里分别实现，从而能够“多次声明，单次实现”。头文件通常包含那些只能被定义一次的实体，如类、const和constexpr变量。</p>
<p>头文件需要承担的另一个责任就是包含与被包含——头文件可以包含其他的头文件（#include），也可以被其他的文件包含。</p>
<p><code>#include</code>本身是一个预处理功能，它是由预处理器（preprocessor）承担，在正式编译之前所执行的一段功能，实际上就是以相应的代码替换掉对应的行。</p>
<p>在某些情况下可能我们会有意无意得重复包含同一个头文件，那么它可能就会被重复展开，这自然是不行的，会造成变量以及函数的重复。所以预处理器提供了另一项预处理功能——头文件保护符（header guard）。</p>
<p>常用的写法有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> [预处理变量]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> [预处理变量]</span></span><br><span class="line"></span><br><span class="line">[头文件内容]</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这样就可以保证该头文件内容被只在第一次被包含时展开，重复包含时会自动略过。</p>
<h2 id="第三章-字符串-向量和数组"><a class="markdownIt-Anchor" href="#第三章-字符串-向量和数组"></a> 第三章 字符串、向量和数组</h2>
<h3 id="31-命名空间的using声明"><a class="markdownIt-Anchor" href="#31-命名空间的using声明"></a> 3.1 命名空间的using声明</h3>
<p>作用域操作符（::）的含义是：编译器应从操作符左侧的名字所示的作用域中寻找右侧那个名字。而存在一种更加方便、也更加安全的方法来实现同样的效果，也就是使用using声明（using declaration）。</p>
<p>using声明的形式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    cin &gt;&gt; i;</span><br><span class="line">    std::cout &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以声明多个using声明，而快捷得使用多个命名空间下的名字。</p>
<p>注意：位于头文件中的代码一般来说不应该使用using声明，因为头文件中的内容会被反复引用，这样using语句也被反复添加，从而可能会产生很多的命名冲突。</p>
<h3 id="32-string"><a class="markdownIt-Anchor" href="#32-string"></a> 3.2 string</h3>
<p>标准库类型string表示可变长的字符序列，使用string需要添加以下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::string; </span><br></pre></td></tr></table></figure>
<h5 id="定义和初始化"><a class="markdownIt-Anchor" href="#定义和初始化"></a> 定义和初始化</h5>
<p>前面提到过，可以通过默认的方式初始化一个string对象，这样就得到一个空的字符串。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1;</span><br></pre></td></tr></table></figure>
<p>当我们使用等号（=）来初始化一个变量时，实际上执行的是拷贝初始化（copy initialization），是编译器把等号右侧的初始值拷贝到新创建的对象中去的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s2 = s1;</span><br><span class="line">string s3 = <span class="string">&quot;hello world&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>反之，若没使用等号，而是用小括号（()）等，则是直接初始化（direct initialization）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(s3)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="string">&quot;hello world&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">string <span class="title">s6</span><span class="params">(n, <span class="string">&#x27;c&#x27;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h5 id="string对象上的操作"><a class="markdownIt-Anchor" href="#string对象上的操作"></a> string对象上的操作</h5>
<p><strong>读写string对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">cout &lt;&lt; s &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>程序的效果是用istream对象从第一个非空格的字符开始读取，到后面遇到的第一个空格为止，之间的字符串，写入到s，然后用ostream对象进行输出。</p>
<p><strong>读取未知数量的string对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读取一整行的字符串</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(cin, line))</span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>getline函数就是用来获取一整行输入的函数，它接收一个istream对象，和一个string类型对象，返回istream类型。注意getline返回的对象不包含换行符。</p>
<p><strong>string的empty和size</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s;</span><br><span class="line">s.<span class="built_in">empty</span>();</span><br><span class="line">s.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure>
<p>s.empty()会返回一个布尔值，用以表示当前字符串是否为空；s.size()会返回一个string::size_type类型的对象，其本质是一个无符号类型的值，而且足够存放下任何string对象的大小。这里要注意无符号类型和有符号类型的混用问题（如int和size_type，尽量避免在同一表达式出现）。</p>
<p><strong>string对象的比较</strong></p>
<p>在进行string对象的比较时，主要有几个关键的运算符：相等性运算符（==和!=），关系运算符（&lt;，&lt;=，&gt;，&gt;=）。</p>
<p>相等性运算符是大小写敏感，用以判断两个string是否完全相同。</p>
<p>关系运算符的规则则比较复杂：</p>
<ul>
<li>如果两个string对象的长度不同，而且较短的string对象的每个字符都与较长string对象对应位置上的字符相同，就说较短string对象小于较长string对象。</li>
<li>如果两个string对象在某些对应位置上不一致，则string对象比较的结果其实是string对象中第一对相异字符比较的结果。</li>
</ul>
<p><strong>string对象的加法</strong></p>
<p>当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。这里需要把握一个核心的原则——字符串字面值和string是不同的类型。</p>
<h3 id="33-vector"><a class="markdownIt-Anchor" href="#33-vector"></a> 3.3 vector</h3>
<p>标准库类型vector表示对象的集合，是多个对象的容器（container），（这样一看，其实把这个对象类型具体到字符，就是上面介绍过的string了）。某种程度上相当于数组，但是又和普通数组存在着一些差别。</p>
<p>使用vector需要在文件开始添加相应的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br></pre></td></tr></table></figure>
<p>vector可以作为<strong>多种对象类型</strong>的容器，实际上是依托C++语言的其中一项特性——模板，更具体来说，是类模板（class template）（此外，模板还包括函数模板）。</p>
<p>模板本身并不是类或者函数，它是编译器帮助编程者快速生成特定的类或者函数的一种便捷方式，其中从模板生成具体类或者函数的过程称为实例化（instantiation），这个过程往往是指定具体的类型。</p>
<p>以vector为例，在使用之前，我们并没有指定vector是一个什么类型对象的容器，所以需要用尖括号（&lt;&gt;）来指定具体的类型，进行实例化操作：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; iVec;</span><br><span class="line">vector&lt;<span class="type">char</span>&gt; cVec;</span><br></pre></td></tr></table></figure>
<p>单独的vector并不能称为某种类型，而是和具体尖括号里的内容共同构成声明的对象的类型，比如iVec的类型为vector<int>，表示一个容器是一个int类型的数据集合。</p>
<p>而后一个例子cVec基本的用法就等同于string了，可以利用方括号（[]）去具体访问其中的某个字符（前提是该位置上的存在元素），可以使用与string中相同的初始化方法，以及大部分的操作。</p>
<p>关于vector和string后续还会有专门的章节详细介绍其用法，还会引入更多类似的且又有不同特性的容器。</p>
<h3 id="34-迭代器"><a class="markdownIt-Anchor" href="#34-迭代器"></a> 3.4 迭代器</h3>
<p>前面在介绍string和vector，都提到了访问其中某个对象元素（字符）的方法，即通过大括号（[]）和元素下标，实际上还存在另外一种对容器来说更加通用的机制——迭代器（iterator）。</p>
<p>并不是所有的标准库容器都可以使用下标，但是都支持迭代器。</p>
<p>最常见的用法有：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>(), e = v.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>
<p>begin成员返回指向的第一个元素的迭代器，end成员返回指向的尾元素的下一位置（one past the end），即该迭代器指示的是容器本不存在的尾后（off the end）元素，这样的迭代器称为是尾后迭代器（off-the-end iterator）或简称为尾迭代器（end iterator）。这样的迭代器没有什么意义，仅作标记使用。</p>
<p>前面使用了auto来让编译器帮忙判断迭代器的类型，实际上迭代器的类型就是iterator和const_iterator：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string::iterator strIter;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator vIter;</span><br></pre></td></tr></table></figure>
<p>const_iterator常量迭代器和常量指针的概念类似，即无法通过该迭代器修改指向对象的值。</p>
<p>容器迭代器的运算符</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">*iter</td>
<td style="text-align:left">返回迭代器iter所指元素的引用</td>
</tr>
<tr>
<td style="text-align:left">iter-&gt;mem</td>
<td style="text-align:left">解引用iter并获取该元素中名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
<td style="text-align:left">++iter</td>
<td style="text-align:left">令iter指向容器中的下一个元素</td>
</tr>
<tr>
<td style="text-align:left">–iter</td>
<td style="text-align:left">令iter指向容器中的上一个元素</td>
</tr>
<tr>
<td style="text-align:left">iter1 == iter2、iter1 != iter2</td>
<td style="text-align:left">判断两个迭代器是否相等，即指向是否相同</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">判断两个迭代器是否相等，即指向是否相同</td>
</tr>
</tbody>
</table>
<p>更特殊的，string和vector的迭代器提供了额外的运算符</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">iter + n</td>
<td style="text-align:left">迭代器加上一个整数依然是一个迭代器，指示的新位置与原来相比向前移动了n个元素，可能是某个新元素，也可能是尾迭代器</td>
</tr>
<tr>
<td style="text-align:left">iter - n</td>
<td style="text-align:left">迭代器加上一个整数依然是一个迭代器，指示的新位置与原来相比向后移动了n个元素，可能是某个新元素，也可能是尾迭代器</td>
</tr>
<tr>
<td style="text-align:left">iter += n</td>
<td style="text-align:left">相当于iter = iter + n</td>
</tr>
<tr>
<td style="text-align:left">iter -= n</td>
<td style="text-align:left">相当于iter = iter - n</td>
</tr>
<tr>
<td style="text-align:left">iter1 - iter2</td>
<td style="text-align:left">两个迭代器的减法运算的结果是他们之间的距离，即右侧的迭代器向左移动了距离个元素后得到左侧的迭代器</td>
</tr>
<tr>
<td style="text-align:left">&gt;、&gt;=、&lt;、&lt;=</td>
<td style="text-align:left">迭代器的关系运算符，用来判断迭代器间的相对位置关系</td>
</tr>
</tbody>
</table>
<p>使用迭代器实现二分法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> beg = text.<span class="built_in">begin</span>(), end = text.<span class="built_in">end</span>();</span><br><span class="line"><span class="keyword">auto</span> mid = text.<span class="built_in">begin</span>() + (end - beg)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (target &lt; *mid)</span><br><span class="line">    &#123;</span><br><span class="line">        end = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = beg + (end - beg)/<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="35-数组"><a class="markdownIt-Anchor" href="#35-数组"></a> 3.5 数组</h3>
<p>其实按照我的理解，对数组的介绍应该要先于vector的，因为vector毕竟是标准库或者对C++的进一步开发才产生的东西。相比于vector，数组本身更加基础，也更加纯粹，数组也是存放类型相同的对象的容器，其显著特点是数组的大小是确定不变的，也即不可以随便向已有数组中添加元素。</p>
<h5 id="定义和初始化-2"><a class="markdownIt-Anchor" href="#定义和初始化-2"></a> 定义和初始化</h5>
<p>数组是一种复合类型。其声明如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[数据类型] [数组名][[数组维度]];</span><br><span class="line"><span class="type">int</span> a[b];</span><br><span class="line"><span class="type">int</span> *p[d];</span><br></pre></td></tr></table></figure>
<p>数组本身会在默认情况下执行默认初始化，此时数组包含的是一组未定义的值。此外，还可以使用列表初始化的方式进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>另外，数组不支持直接将某个数组直接拷贝赋值给另一个数组。（即便某些编译器支持这样做，这亦属于编辑器扩展的内容，属于C++的非标准特性，在普适性的编程条件下，应该避免这种操作。）</p>
<h5 id="数组指针"><a class="markdownIt-Anchor" href="#数组指针"></a> 数组指针</h5>
<p>在很多对数组的使用情况下（使用数组名的情况），实际上使用的是数组指针，即指向数组中第一个元素的地址的指针，这个指针本质上也可以认为是前面提到过的迭代器，支持迭代器的一系列操作。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span> *p = arr;			<span class="comment">// p指针是arr的数组指针，即指向arr的第一个元素</span></span><br><span class="line">++p;					<span class="comment">// p指向arr[1],*p的值为1	</span></span><br><span class="line"><span class="type">int</span> temp = *p + <span class="number">3</span>;		<span class="comment">// temp = 4, 1 + 3 = 4，先解引用，再计算</span></span><br><span class="line"><span class="type">int</span> temp02 = * (p + <span class="number">3</span>)	<span class="comment">// temp02 = 4, arr[4] = 4 ，先计算，再解引用</span></span><br></pre></td></tr></table></figure>
<h5 id="多维数组"><a class="markdownIt-Anchor" href="#多维数组"></a> 多维数组</h5>
<p>C++中从根源上讲并没有多维数组，通常谈论的多维数组（二维，三维等）其实是由数组类型所组成的数组。对于常见的二维数组来说，我们通常把第一个维度称为行（row），第二个为称为列（cul）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a[2][3] =&#123;</span><br><span class="line">	&#123;0, 1, 2&#125;,</span><br><span class="line">	&#123;3, 4, 5&#125;</span><br><span class="line">&#125;;				// 2行3列的二维数组</span><br></pre></td></tr></table></figure>
<h2 id="第四章-表达式"><a class="markdownIt-Anchor" href="#第四章-表达式"></a> 第四章 表达式</h2>
<h3 id="41-基础"><a class="markdownIt-Anchor" href="#41-基础"></a> 4.1 基础</h3>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之编译</title>
    <url>/2022/04/25/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<p>虽然不像Unity3D那样以多平台支持作为宣传点，虚幻本身依然是多平台支持的，如Windows，IOS，安卓等等。同时为了应对开发和部署的需要，编译的配置也是一个花样繁多的过程。</p>
<p>本篇文章就初步得从概念和工具的角度对虚幻的编译做一定的总结。</p>
<span id="more"></span>
<p><ul class="markdownIt-TOC">
<li><a href="#%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F">编译系统</a>
<ul>
<li><a href="#unrealbuildtool">UnrealBuildTool</a></li>
<li><a href="#unrealheadertool">UnrealHeaderTool</a></li>
</ul>
</li>
<li><a href="#%E7%BC%96%E8%AF%91%E7%B1%BB%E5%9E%8B">编译类型</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</p>
<p>本文使用的环境和工具为：</p>
<ul>
<li>Windows 10</li>
<li>ue5</li>
<li>Rider or Unreal Engine 2021.3</li>
</ul>
<h2 id="编译系统"><a class="markdownIt-Anchor" href="#编译系统"></a> 编译系统</h2>
<p><code>编译</code>是指从源程序到产生目标程序的过程，是指从高级语言翻译成机器可以识读的二进制语言的过程，更通俗来讲，它可以是把我们编写的代码、资源，整合成一个可以运行的可以玩的游戏的过程。</p>
<p>编译通常会涉及到一项强有力的工具——编译器，当然标准的编译流程中还会又预处理阶段（由预处理器负责，是和编译器分开的），现在各种功能强大的IDE通常会把这些工作整合到一起在后台做掉，我们一般只需要点一下<code>Build</code>或者<code>Debug</code>又或者<code>Run</code>即可。</p>
<p>当然，虚幻引擎本身及其游戏内容都是由c<ins>写成，其项目编译当然也会遵循这个过程。只不过，虚幻引擎本身的代码量非常之巨大，属性和方法组成了类，类和类相互配合搭建起模块，模块和模块相互依赖构成了系统，而虚幻引擎中类和模块的数量已经难以计数，所以它也推出了自己的一套管理代码的工具（）：UnrealBuildTool（UBT，C#，编译虚幻的各个模块，处理依赖），和UnrealHeaderTool（UHT，C</ins>，头文件解析和代码生成，为反射系统提供支持）。</p>
<h3 id="unrealbuildtool"><a class="markdownIt-Anchor" href="#unrealbuildtool"></a> UnrealBuildTool</h3>
<p>UBT的源码位于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UE_5.0\Engine\Source\Programs\UnrealBuildTool</span><br></pre></td></tr></table></figure>
<p>代码是用C#写成，完整开发的话需要安装相应的.Net桌面开发框架，需要的可以到相应位置查找（一般我们不会去动这个工具，但是相应的，如果需要做一些轻量的修改，可以到BuildConfiguration.cs中探索可供用户配置的编译选项）。而对应的可执行程序的位置在：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UE_5.0\Engine\Binaries\DotNET\AutomationTool</span><br></pre></td></tr></table></figure>
<p>这个才是真正编译好的，发挥作用的工具。</p>
<p>对于UBT，我们需要知道的是，当我们去Build或者Rebuild项目时（以及右键点击项目的<code>.uproject</code>文件选择Generate Visual Studio project files时），就会去运行UnrealBuildTool.exe，并传入几个参数（Main函数的参数）：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UnrealBuildTool</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] ArgumentsArray</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的ArgumentsArray即是通过采样C++构建系统NMake的Build Command Line来确定几个参数，主要是项目名称，编译的Target（目标），目标平台等等。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%BC%96%E8%AF%91/Compile_BuildCommandLine.png" alt="" /></p>
<p>然后读取build.cs，确定模块与模块之间的依赖关系（需要去编译哪些模块，需要忽略哪些模块的编译工作，模块的没有变动的话会跳过）。</p>
<p>随后，UBT调用UHT执行头文件解析和代码生成的工作，UHT会根据反射标签生成相应的代码（如对应<code>GENERATED_BODY()</code>的宏替换代码就位于生成的<code>.generated.h</code>中，又如<code>UPROPERTY()</code>标记的属性被序列化到蓝图中，等等，详情参考讲解反射的相关文章）。</p>
<p>最后，UBT通过确定好的依赖关系调用编译器编译变更模块的C++代码。</p>
<h3 id="unrealheadertool"><a class="markdownIt-Anchor" href="#unrealheadertool"></a> UnrealHeaderTool</h3>
<p>UHT的源码位于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UE_5.0\Engine\Source\Programs\UnrealHeaderTool</span><br></pre></td></tr></table></figure>
<p>UHT工具与虚幻的反射机制息息相关，可以这样说，UHT是构建于虚幻UObject系统基础上的宏生成和替换工具（当然，还是用原文“头文件解析工具”更贴切）。</p>
<p>反射是很多游戏引擎都依赖的特性，像Unity3D借用了C#的反射。当然不同的是，C<ins>本身并不支持反射（原生C</ins>有RTTI，Runtime Type Identification，即运行时类型识别），而是虚幻在普通C++上实现了这样的一套反射机制。这样，便使<strong>运行时</strong>获取类的元数据变得简单，从实现GC，序列化等一些引擎需要的功能。</p>
<p>举个例子，用<code>UPROPERTY()</code>标记的属性，可以序列化在蓝图中，通过其中的说明符可以进一步定制该属性的特性（详情参阅说明符关键字相关文章）。</p>
<h2 id="编译类型"><a class="markdownIt-Anchor" href="#编译类型"></a> 编译类型</h2>
<p>编译虚幻项目时，可以是简单的选择项目，然后右键Build，然后运行Debug；但是此时可能就会遇到一些问题，为什么有些代码我打了断点，却无法进入断点呢？</p>
<p>这个就是虚幻C++项目的一个小坑了，关键就在于编译的配置。</p>
<p>我们可以发现在每个模块都有对应的<code>.Target.cs</code>，包括我们的游戏模块。其内容就是对该模块应该面向哪一种编译的目标。</p>
<p>这里这个编译的Target，我们可以理解为我们出于什么目的来编译这个模块，是为了让别人在游戏中直接使用？还是别人可以在编辑器中应用调整该模块？等等。</p>
<p>例如我们的游戏模块，我们知道这个游戏是冲着打成包给别人玩的，那么就有专门的<code>.Target.cs</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type = TargetType.Game;</span><br></pre></td></tr></table></figure>
<p>这里的Target为[empty]</p>
<p>此外，这个游戏模块还要供我们在编辑器内编辑使用，可能还会用到调试，那么还有另外一个<code>__Editor.Target.cs</code>：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Type = TargetType.Editor;</span><br></pre></td></tr></table></figure>
<p>这里的Target为Editor。</p>
<p>此外Target的可选项还有Client和Server，分别对应着客户端和服务器的编译目标。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Target</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[empty]</td>
<td style="text-align:center">不带编辑器的一个独立可执行版本，需要提前<a href="https://docs.unrealengine.com/5.0/en-US/packaging-unreal-engine-projects/">打包</a>烘培内容资源</td>
</tr>
<tr>
<td style="text-align:center">Editor</td>
<td style="text-align:center">在虚幻编辑器里打开并可编辑游戏项目，所有代码的更改也会反映到编辑器中</td>
</tr>
<tr>
<td style="text-align:center">Client</td>
<td style="text-align:center">多人联网功能中的客户端版本，需要在项目中提供<code>__Client.Target.cs</code>（参照<code>__Editor.Target.cs</code>的写法）</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">多人联网功能中的服务器版本，需要在项目中提供<code>__Server.Target.cs</code>（参照<code>__Editor.Target.cs</code>的写法）</td>
</tr>
</tbody>
</table>
<p>除了Target外，还有另外一关键字需要注意——State（通常State在前，Target在后，即[State] [Target]）。</p>
<p>State是用来描述我们当前引擎和游戏项目的状态，我们的游戏要准备打包发行了，就使用Shipping；我还处在游戏开发阶段，需要通过代码进行某些游戏代码的调试，就使用DebugGame；而若是只需要通过编辑器的反射来查看代码的更改的话，那么Development一般就可满足条件（这也是默认的状态，虚幻官方推荐新手以蓝图开发为主，代码开发为辅）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">State</th>
<th style="text-align:center">Engine</th>
<th style="text-align:center">Game</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Debug</td>
<td style="text-align:center">Debug</td>
<td style="text-align:center">Debug</td>
<td style="text-align:center">会同时去构建引擎和游戏两者的代码，是最全面的构建，但同时也会比较费时间</td>
</tr>
<tr>
<td style="text-align:center">DebugGame</td>
<td style="text-align:center">Release</td>
<td style="text-align:center">Debug</td>
<td style="text-align:center">以最优的方式构建引擎，同时保持游戏部分的代码支持调试，适用于仅调试代码的模式</td>
</tr>
<tr>
<td style="text-align:center">Development</td>
<td style="text-align:center">Release</td>
<td style="text-align:center">Release</td>
<td style="text-align:center">可以在编辑器内通过反射的方式查看代码所带来的更改，是开发和性能最平衡的模式</td>
</tr>
<tr>
<td style="text-align:center">Shipping</td>
<td style="text-align:center">Release</td>
<td style="text-align:center">Release</td>
<td style="text-align:center">最佳性能配置，用于交付游戏，无控制台命令、统计数据和性能分析工具</td>
</tr>
<tr>
<td style="text-align:center">Test</td>
<td style="text-align:center">Release</td>
<td style="text-align:center">Release</td>
<td style="text-align:center">同Shipping模式，但是启用了控制台命令、统计数据和性能分析工具</td>
</tr>
</tbody>
</table>
<p>这两个关键字大部分情况都可以组合使用，但是还是有一些例外情况。</p>
<p>编译配置——编译解决方案（有引擎源码版），此时是将引擎源代码和游戏项目的源代码一同编译，其可选配置如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Debug</th>
<th style="text-align:center">DebugGame</th>
<th style="text-align:center">Development</th>
<th style="text-align:center">Shipping</th>
<th style="text-align:center">Test</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[empty]</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:center">Editor</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Client</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
</tr>
</tbody>
</table>
<p>编译配置——编译项目（无引擎源码版），此时是将游戏项目的源代码单独编译，其可选配置如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">Debug</th>
<th style="text-align:center">DebugGame</th>
<th style="text-align:center">Development</th>
<th style="text-align:center">Shipping</th>
<th style="text-align:center">Test</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">[empty]</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Editor</td>
<td style="text-align:center"></td>
<td style="text-align:center">✓</td>
<td style="text-align:center">✓</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Client</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">Server</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>UBT也好，UHT也好，甚至于IDE也好，作为工具来说是他们都是非常强大可靠的，同时其强大的代价就是其内部项目的驳杂，会在我们希望深入内部时造成一定的阅读学习困难。</p>
<p>好在，一方面，作为游戏开发者、引擎使用者来说，我们不是必须要把这些工具的内部代码理解通透，而是掌握其基本特性和工作流程已是不错，随着分工不断得细化，我们程序也会走向不同的分工，可能确实有一些同时需要切实掌握并且具备修改的能力，但是对于大部分Gameplay和System的编程者来说，能够完全掌握本文及链接所述内容已是不俗。</p>
<p>另一方面，网络上也越来越多得出现技术和知识的共享者，本文的成文就是综合多方阅读资源进行总结的结果，这里也表达我的谢意。</p>
<p>最后，如果文中有一些技术性或者表述性的错误，还请大家多予指点。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/5.0/en-US/build-configurations-reference-for-unreal-engine/">虚幻 5.0 Documentation - Build Configurations Reference</a></p>
<p><a href="https://docs.unrealengine.com/5.0/en-US/compiling-game-projects-in-unreal-engine-using-cplusplus/">虚幻 5.0 Documentation - Compiling Game Projects</a></p>
<p>知乎作者 大钊 的文章<a href="https://zhuanlan.zhihu.com/p/22814098">《InsideUE4》</a></p>
<p>知乎作者 雪流星 的文章<a href="https://zhuanlan.zhihu.com/p/458435453">《虚幻编译系统总结》</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>C++</tag>
        <tag>编译</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻插件之Quest System</title>
    <url>/2022/04/19/%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/</url>
    <content><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>Quest System是针对游戏设计中的任务设计而制作的一个编辑器插件，在它的帮助下，我们能够有条理得进行任务的制定和分配，从而进行游戏流程的控制。</p>
<p>但是相应的，其官方支持文档言简意赅，对非程序的和不熟悉外语的使用者来说存在一定的上手难度。</p>
<p>本文就是为了帮助读者能够快速入门Quest System，掌握相应的任务制作方法和流程而编写的。</p>
<span id="more"></span>
<h2 id="快速上手"><a class="markdownIt-Anchor" href="#快速上手"></a> 快速上手</h2>
<p>资产购买链接：<a href="https://www.unrealengine.com/marketplace/en-US/product/quest-system-02">https://www.unrealengine.com/marketplace/en-US/product/quest-system-02</a></p>
<p>该插件兼容4.24-5.0的虚幻编辑器版本。</p>
<h3 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h3>
<p>该插件是以纯蓝图的形式提供，所以将其融入项目的方式比较多样。我这里就直接以插件内容创建项目，并导入虚幻5下的第三人称模板，后面的例子也将以第三人称模板为基础进行搭建。</p>
<p>为第三人称模板创建PlayerController，并将其父类修改为BP_QuestController（是Quest System提供的PlayerController，主要是继承了一个IQuestControllerInterface，包含了一个C_QuestComponent，以及相应实现的一些接口函数和事件等等）。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_PlayerControllerStruct.png" alt="" /></p>
<p>然后调整第三人称的GameMode（修改默认的PlayerController为我们刚刚创建的BP_PlayerController），并将该GameMode应用到全局（或者当前World也可）。</p>
<p>最后在第三人称模板中的第三人称角色蓝图BP_ThirdPersonCharacter中添加如下蓝图代码（可以从Quest System提供的BP_QuestPlayer中复制得到），这是读取用户输入来和NPC等可交互物/人等作交互使用：</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_InteractionCodeInCharacter.png" alt="" /></p>
<p>此时，运行程序后，可以尝试按下<code>L</code>键呼出任务面板，当然里面还没有任何内容。 下面正式开始任务内容的创建。</p>
<p>现在假设我们要制作的第一个任务是新手引导任务，其大致的流程是：玩家去找引导NPC对话，NPC发布任务，需要玩家完成打开任务面板的操作和提交完成任务的操作。</p>
<h3 id="quest创建"><a class="markdownIt-Anchor" href="#quest创建"></a> Quest创建</h3>
<p>在任意处新建DataTable，并在Pick Row Structure时选择S_Quest，这是Quest System定义的数据结构，创建好的空数据表如下：</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_DataTableCreation.png" alt="" /></p>
<p>点击Add增加数据模板，其中的条目我们可以按需配置。根据前面设定的简单任务要求，我们进行数据表的配置：</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_FirstCustomQuest.png" alt="" /></p>
<p>这里注意任务的Row Name和QuestID在规定里要保持一致。QuestName和Decription Paragraph里的内容将会显示到任务UI上，所以这里可以尽情施展才华。</p>
<p>这些内容只是用来提示玩家的，而后面的Task则是会进一步细化玩家的操作目标。</p>
<h3 id="task创建"><a class="markdownIt-Anchor" href="#task创建"></a> Task创建</h3>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_QuestTask.png" alt="" /></p>
<p>Task ID是用来查找相应任务的标识符，起的时候应当尽量好记易懂。</p>
<p>Task Description是对任务的描述，它和后面的Current Amount（当前进度）和Needed Amount（完成Task需要的总进度）会共同作用，显示在任务UI上。</p>
<p>此外，我们可以在一个Quest内创建多个Task，而这些Task之间可以是同时出现（即玩家可以并行得去完成这些Task），也可以有强依赖顺序（即玩家完成Task1后才能开始执行Task2），关键就在于EnabledByDefault和EnabledTasksOnComplete。例如本例中，“提交完成任务”的Task就只能在完成“呼出任务面板”的Task完成后才会出现。</p>
<p>到这里，基本的任务创建已经完成，针对数据表还需要一步操作，找到DB_Quest_Composition，将我们刚刚创建好的数据表添加到Parent Tables栏位中：</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_DataTableComposition.png" alt="" /></p>
<p>到此任务的创建基本完成，接下来我们需要在场景中确定我们的任务NPC分布，并添加任务的相关道具。</p>
<h3 id="任务与npc的绑定"><a class="markdownIt-Anchor" href="#任务与npc的绑定"></a> 任务与NPC的绑定</h3>
<p>任务NPC（BP_QuestNPC）可以在Quest System提供的包内找到，并且可以直接放置于场景中使用。</p>
<p>这里对NPC主要进行的配置是添加Available Quest IDs，这决定着这个NPC控制着哪些任务。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_QuestNPCConfig.png" alt="" /></p>
<p>另外，Quest Filter ID是该NPC的标识符，可以在配置数据表的时候通过和CanBeAccessedOnlyBy和CanBeCompletedOnlyBy相配合发挥作用。、</p>
<p>另外的一个变量——Quest Task ID即对应着数据表中Task里的Quest Task ID，这里输入的字符串表明了当你与该NPC交互时可以完成的子任务为哪一个。</p>
<p>当然，我们当时定义了另外一个子任务，其完成是在PlayerController里：</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_AddQuest.png" alt="" /></p>
<p><code>AddQuestTaskAmount</code>是任务完成的底层逻辑实现，即当我们完成某一操作时可以在蓝图里进行判断，并调用该函数来增加CurrentAmount，当CurrentAmount和NeededAmount相等时，就表示Quest已经完成。</p>
<iframe src="//player.bilibili.com/player.html?aid=768312475&bvid=BV12r4y1H7x4&cid=580259670&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
<h2 id="底层拆解蓝图程序向可跳过"><a class="markdownIt-Anchor" href="#底层拆解蓝图程序向可跳过"></a> 底层拆解（蓝图程序向，可跳过）</h2>
<p>Quest System是完全由蓝图实现的，其中设计到一定量的类，接口，数据结构等。本小节将着眼于其中较为核心的部分，主要是控制器类和NPC类，穿插一些其中涉及到的组件、接口等。</p>
<h3 id="控制器"><a class="markdownIt-Anchor" href="#控制器"></a> 控制器</h3>
<p>Quest System的控制器类BP_QuestController的特点主要是：挂载了C_WidgetManager_QuestSystem和C_QuestComponent，以及继承了IQuestControllerInterface。</p>
<p>IQuestControllerInterface接口的函数主要有：</p>
<ul>
<li>AcceptQuest</li>
<li>AbortQuest</li>
<li>CompleteQuest</li>
<li>AddQuestTaskAmount</li>
<li>TrackQuest</li>
</ul>
<p>当你想和UI交互时，可能会用到<code>AbortQuest</code>；当你击杀了某个任务Boss，可能会想要用到<code>AddQuestTaskAmount</code>等等。</p>
<p>这些函数更进一步，在控制器上，是通过C_QuestComponent里的功能来实现的。所以当我们想要去访问控制任务的核心模块时，就直接去找控制器上的QuestComponent即可。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_QuestComponent.png" alt="" /></p>
<h3 id="任务发布的npc"><a class="markdownIt-Anchor" href="#任务发布的npc"></a> 任务发布的NPC</h3>
<p>任务的发布不一定是需要NPC来执行，也可以是任何其他Actor，但是从任务发布NPC身上，可以一窥任务发布的流程。</p>
<p>本质上，QuestNPC只是一个Actor，其继承了一个IInteraction接口用来实现交互效果（按E键）。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BQuest-System/QuestSystem_QuestNPC.png" alt="" /></p>
<p>从蓝图中可以看到，NPC的行为主要有:</p>
<ul>
<li>在NPC加载时（BeginPlay），按照配置好的数据进行任务的加载；</li>
<li>在交互时，进行任务完成情况的更新和任务UI的更新。</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Quest System任务系统提供了一套任务定制的解决方案，并且能够较为顺畅得在项目中落地；但是相应的，作为一款工具来讲，Quest System的界面和相应的工作配置流程是较为繁琐和分散的，且并没有很多高级的定制化的功能，在应对小体量项目开发时使用效率尚可，但是应对大体量作品时，其开发效率和管理成本可能会不尽如人意。此时，使用其他解决方案或者在Quest System的基础上进行一定量的定制可能会是正解。</p>
<p>另外，如果有需要，本文后续还会更新针对Quest System的更多蓝图程序和数据结构进行分析和拆解。</p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>插件</tag>
        <tag>任务系统</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 119 杨辉三角 II</title>
    <url>/2022/04/15/LeetCode-119-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92-II/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
</font>
<font color=#999AAA >
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
</font>
<p></p>
<ul>
<li>示例 1:<br />
输入: rowIndex = 3<br />
输出: [1,3,3,1]</li>
<li>示例 2:<br />
输入: rowIndex = 0<br />
输出: [1]</li>
<li>示例 3:<br />
输入: rowIndex = 1<br />
输出: [1,1]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/pascals-triangle-ii">https://leetcode-cn.com/problems/pascals-triangle-ii</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>与118题一样，只不过答案更加简化，只需要给出目标行数的数组即可。</p>
<p>所以可以不用二维数组，而直接使用两个数组来交替换行即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getRow</span><span class="params">(<span class="type">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vCur = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vPre = &#123;<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vPre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rowIndex == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> vCur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= rowIndex; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            vPre.<span class="built_in">resize</span>(i);</span><br><span class="line">            vPre = vCur;</span><br><span class="line">            vCur.<span class="built_in">resize</span>(i+<span class="number">1</span>);</span><br><span class="line">            vCur[<span class="number">0</span>] = vCur[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                vCur[j] = vPre[j<span class="number">-1</span>]+vPre[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vCur;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="LeetCode119_result.png" alt="" /></p>
<p>复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>r</mi><mi>o</mi><mi>w</mi><mi>I</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(rowIndex)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻代码中支持反射的说明符关键字——USTRUCT篇</title>
    <url>/2022/04/13/%E8%99%9A%E5%B9%BB%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%94%AF%E6%8C%81%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94USTRUCT%E7%AF%87/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻代码中支持反射的说明符关键字——UFUNCTION篇（更新中）</title>
    <url>/2022/04/13/%E8%99%9A%E5%B9%BB%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%94%AF%E6%8C%81%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94UFUNCTION%E7%AF%87/</url>
    <content><![CDATA[<p>虚幻引擎代码纷繁复杂，一定程度上就是因为从UObject开始架构的这套反射系统，<br />
它在带给我们优秀的反射机制的同时，也让代码的阅读及编写有了一定的门槛。</p>
<p>本篇文章的目的，就希望通过拆解虚幻中说明符关键字的这一环，帮助更多人逐步消解跨过这一道门槛。</p>
<p>本文是系列文章中针对UFUNCTION中涉及到的说明符关键字的解释。</p>
<span id="more"></span>
<h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="拆解"><a class="markdownIt-Anchor" href="#拆解"></a> 拆解</h2>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/GameplayArchitecture/Functions/Specifiers/">虚幻 4.26 Documentation - Function Specifiers</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
        <tag>反射</tag>
        <tag>关键字</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻代码中支持反射的说明符关键字——UCLASS篇（更新中）</title>
    <url>/2022/04/13/%E8%99%9A%E5%B9%BB%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%94%AF%E6%8C%81%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94UCLASS%E7%AF%87/</url>
    <content><![CDATA[<p>虚幻引擎代码纷繁复杂，一定程度上就是因为从UObject开始架构的这套反射系统，<br />
它在带给我们优秀的反射机制的同时，也让代码的阅读及编写有了一定的门槛。</p>
<p>本篇文章的目的，就希望通过拆解虚幻中说明符关键字的这一环，帮助更多人逐步消解跨过这一道门槛。</p>
<p>本文是系列文章中针对UCLASS中涉及到的说明符关键字的解释。</p>
<span id="more"></span>
<h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>Within=OuterClassName</td>
<td>此类的对象无法在<code>OuterClassName</code>对象的实例之外存在。这意味着，要创建此类的对象，需要提供<code>OuterClassName</code>的一个实例作为其<code>Outer</code>对象。</td>
</tr>
<tr>
<td>config=ConfigName</td>
<td>指示此类可在配置文件（.ini）中存储数据。如果存在任何使用<code>config</code>或<code>globalconfig</code>说明符声明的类属性，此说明符将使这些属性存储在指定的配置文件中。此说明符会传播到所有子类并且无法使此说明符无效，但是子类可通过重新声明<code>config</code>说明符并提供不同的<code>ConfigName</code>来更改配置文件。常见的<code>ConfigName</code>值是&quot;Engine&quot;、“Editor”、“Input&quot;和&quot;Game”。</td>
</tr>
<tr>
<td>transient</td>
<td>此类的对象不会被保存到磁盘。常当与不持久的特定种类的native类配合使用。此说明符会传播到子类，但是可由<code>NonTransient</code>说明符覆盖。</td>
</tr>
</tbody>
</table>
<h2 id="拆解"><a class="markdownIt-Anchor" href="#拆解"></a> 拆解</h2>
<h3 id="withinouterclassname-configconfigname-transient"><a class="markdownIt-Anchor" href="#withinouterclassname-configconfigname-transient"></a> Within=OuterClassName, config=ConfigName, transient</h3>
<p>研究来源：PlayerInput.h中的UPlayerInput类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(Within=PlayerController, config=Input, transient)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> UPlayerInput : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** Generic bindings of keys to Exec()-compatible strings for development purposes only */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config)</span><br><span class="line">	TArray&lt;<span class="keyword">struct</span> <span class="title class_">FKeyBind</span>&gt; DebugExecBindings;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">/** List of Axis Mappings that have been inverted */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(config)</span><br><span class="line">	TArray&lt;FName&gt; InvertedAxis;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Within=PlayerController表明UPlayerInput的对象不能在PlayerController的对象之外存在，<br />
实际上意味着我们不能够随随便便在某处new一个UPlayerInput出来，属于服务于代码规范和框架规范的说明符。</p>
<p>config=Input表明UPlayerInput会对Input.ini配置文件进行数据存储，<br />
<code>DebugExecBindings</code>和<code>InvertedAxis</code>即是要存储的属性。</p>
<p>transient表明UPlayerInput的对象不会被保存到磁盘，</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/GameplayArchitecture/Classes/Specifiers/">虚幻 4.26 Documentation - Class Specifiers</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
        <tag>反射</tag>
        <tag>关键字</tag>
        <tag>类</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻代码中支持反射的说明符关键字——UPROPERTY篇（更新中）</title>
    <url>/2022/04/13/%E8%99%9A%E5%B9%BB%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%94%AF%E6%8C%81%E5%8F%8D%E5%B0%84%E7%9A%84%E8%AF%B4%E6%98%8E%E7%AC%A6%E5%85%B3%E9%94%AE%E5%AD%97%E2%80%94%E2%80%94UPROPERTY%E7%AF%87/</url>
    <content><![CDATA[<p>虚幻引擎代码纷繁复杂，一定程度上就是因为从UObject开始架构的这套反射系统，<br />
它在带给我们优秀的反射机制的同时，也让代码的阅读及编写有了一定的门槛。</p>
<p>本篇文章的目的，就希望通过拆解虚幻中说明符关键字的这一环，帮助更多人逐步消解跨过这一道门槛。</p>
<p>本文是系列文章中针对UPROPERTY中涉及到的说明符关键字的解释。</p>
<span id="more"></span>
<h2 id="总览"><a class="markdownIt-Anchor" href="#总览"></a> 总览</h2>
<table>
<thead>
<tr>
<th>关键字</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="拆解"><a class="markdownIt-Anchor" href="#拆解"></a> 拆解</h2>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/4.26/en-US/ProgrammingAndScripting/GameplayArchitecture/Properties/Specifiers/">虚幻 4.26 Documentation - Property Specifiers</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
        <tag>反射</tag>
        <tag>关键字</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 118 杨辉三角</title>
    <url>/2022/04/13/LeetCode-118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%95%B0%E5%AD%A6%E6%8E%A8%E5%AF%BC%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">数学推导，动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
</font>
<font color=#999AAA >
在「杨辉三角」中，每个数是它左上方和右上方的数的和。
</font>
<p></p>
<ul>
<li>示例 1:<br />
输入: numRows = 5<br />
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</li>
<li>示例 2:<br />
输入: numRows = 1<br />
输出: [[1]]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/pascals-triangle">https://leetcode-cn.com/problems/pascals-triangle</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="数学推导动态规划"><a class="markdownIt-Anchor" href="#数学推导动态规划"></a> 数学推导，动态规划</h2>
<p>数组的每一层都可以由上一层推导而来，简化公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>+</mo><mi>v</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo><mo separator="true">;</mo></mrow><annotation encoding="application/x-tex">v[i][j+1] = v[i-1][j] + v[i-1][j+1];
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">;</span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>为行数，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>为列数。</p>
<p>此外，注意边界条件即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v0 = &#123;<span class="number">1</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v1 = &#123;<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        res.<span class="built_in">push_back</span>(v0);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(v1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numRows == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; numRows; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(i+<span class="number">1</span>,<span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; i)</span><br><span class="line">                &#123;</span><br><span class="line">                    v[j+<span class="number">1</span>] = res[i<span class="number">-1</span>][j] + res[i<span class="number">-1</span>][j+<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="LeetCode118_result.png" alt="" /><br />
复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>R</mi><mi>o</mi><mi>w</mi><msup><mi>s</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(numRows^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，基本上是数组空间大小这一数量级<br />
空间复杂度：开辟辅助数组所出现的消耗，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻5新特性之AbilitySystemGameFeatureActions</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BAbilitySystemGameFeatureActions/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻5新特性之World Partition</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BWorldPartition/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之资源处理</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之Slate</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BSlate/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之图形编程</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%BE%E5%BD%A2%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之OnlineSubSystem</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BOnlineSubSystem/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之Actor</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BActor/</url>
    <content><![CDATA[<span id="more"></span>
<p><ul class="markdownIt-TOC">
<li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%85%E7%9A%84level">编辑器内的Level</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</p>
<h2 id="编辑器内的level"><a class="markdownIt-Anchor" href="#编辑器内的level"></a> 编辑器内的Level</h2>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/5.0/en-US/gameplay-framework-in-unreal-engine/">虚幻 5.0 Documentation - Gameplay Framework</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>C++</tag>
        <tag>Actor</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之多人游戏与网络复制</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之调试工具</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之性能分析</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之本地化</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%9C%AC%E5%9C%B0%E5%8C%96/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之行为树</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%A1%8C%E4%B8%BA%E6%A0%91/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之数据驱动</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之原生Input</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8E%9F%E7%94%9FInput/</url>
    <content><![CDATA[<p>输入是游戏交互中非常重要的一环，输入处理本质上是让机器读取、理解人的某项操作。这个过程是否完善，是否符合人的直观认知，直接影响一款游戏的操作手感，从而影响到游戏的品质。</p>
<p>虚幻引擎内置实现了一套原生的Input模块，在多个版本一直沿用，同时在实际项目中，又会被具体项目组进行定制，从而衍生了一定量的输入补充插件。</p>
<p>本文的目的不在于那些衍生的针对输入的代码插件或者蓝图插件，而是着眼于虚幻底层的输入部分，看看原生的输入部分的代码，也为以后的使用、改写和扩展建立理论基础。</p>
<span id="more"></span>
<p><ul class="markdownIt-TOC">
<li><a href="#playerinput">PlayerInput</a></li>
<li><a href="#inputcomponent">InputComponent</a>
<ul>
<li><a href="#actor%E5%86%85%E7%9A%84inputcomponent">Actor内的InputComponent</a></li>
<li><a href="#playercontroller%E5%86%85%E7%9A%84inputstack">PlayerController内的InputStack</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</p>
<h2 id="playerinput"><a class="markdownIt-Anchor" href="#playerinput"></a> PlayerInput</h2>
<p>PlayerInput对象主要负责的是对玩家的输入数据的处理，是虚幻接收外部硬件输入并将信号处理后转入内部的一个中间模块。</p>
<p>PlayerInput主要是在PlayerController里发挥管理作用， 在类定义的时候已经用关键字<code>Within=PlayerController</code>进行标记，表示其对象是存在于和PlayerController的对象实例里的，这意味着不可以随随便便去创建其他的PlayerInput。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">UCLASS</span>(Within=PlayerController, config=Input, transient)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> UPlayerInput : <span class="keyword">public</span> UObject</span><br></pre></td></tr></table></figure>
<p>PlayerInput中，又声明了两个数组，<code>FInputActionKeyMapping</code>数组和<code>FInputAxisKeyMapping</code>数组，分别定义了动作映射<code>ActionMappings</code>和轴映射<code>AxisMappings</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** This player&#x27;s version of the Action Mappings */</span></span><br><span class="line">TArray&lt;<span class="keyword">struct</span> <span class="title class_">FInputActionKeyMapping</span>&gt; ActionMappings;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** This player&#x27;s version of Axis Mappings */</span></span><br><span class="line">TArray&lt;<span class="keyword">struct</span> <span class="title class_">FInputAxisKeyMapping</span>&gt; AxisMappings;</span><br></pre></td></tr></table></figure>
<p>结构体<code>FInputActionKeyMapping</code>，其中又有两个属性<code>ActionName</code>和<code>Key</code>，分别表示的是该输入绑定的动作名称和相应按键，其余属性均为组合按键的选项（如shift + 按键，来表示奔跑的指令）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Defines a mapping between an action and key </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="built_in">USTRUCT</span>( BlueprintType )</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FInputActionKeyMapping</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Friendly name of action, e.g &quot;jump&quot; */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	FName ActionName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** true if one of the Shift keys must be down when the KeyEvent is received to be acknowledged */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	uint8 bShift:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** true if one of the Ctrl keys must be down when the KeyEvent is received to be acknowledged */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	uint8 bCtrl:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** true if one of the Alt keys must be down when the KeyEvent is received to be acknowledged */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	uint8 bAlt:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** true if one of the Cmd keys must be down when the KeyEvent is received to be acknowledged */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	uint8 bCmd:<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Key to bind it to. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	FKey Key;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体<code>FInputAxisKeyMapping</code>，其中也有两个属性<code>AxisName</code>和<code>Key</code>，分别表示的是该输入绑定的轴名称和相应按键，<code>Scale</code>属性用来给出具体值（相比于Action的离散触发，Axis则是连续的监听）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * Defines a mapping between an axis and key </span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="built_in">USTRUCT</span>( BlueprintType )</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">FInputAxisKeyMapping</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Friendly name of axis, e.g &quot;MoveForward&quot; */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	FName AxisName;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Multiplier to use for the mapping when accumulating the axis value */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	<span class="type">float</span> Scale;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Key to bind it to. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, BlueprintReadWrite, Category=<span class="string">&quot;Input&quot;</span>)</span><br><span class="line">	FKey Key;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个结构体中都涉及到了同一个类（结构体）——<code>FKey</code>，它的定义位于<code>InputCoreTypes</code>中，其本质就是硬件输入的定义。</p>
<p>如图，经由虚幻内部的反射机制，将属性<code>ActionMappings</code>和属性<code>AxisMappings</code>序列化到Editor里，并且可以自定义，添加映射等等。添加绑定的过程实际上就是在对ActionName/AxisName和FKey写入的过程（还有其他属性如组合按键和Scale也在Editor界面里有体现）。</p>
<p><img src="Input_ActionMappings.png" alt="" /></p>
<p>上述，基本可以描绘出游戏按键到行为的建立映射的过程，当然到这一步，我们也仅仅是将映射的概念建立起来，接下来就需要为特定的映射绑定具体的行为了，这就是InputComponent所承担的任务了。</p>
<h2 id="inputcomponent"><a class="markdownIt-Anchor" href="#inputcomponent"></a> InputComponent</h2>
<p>InputComponent直接继承自ActorComponent，对象可以对Input.ini进行写入。</p>
<p>PlayerController里是维护着一个InputComponent的栈，而核心的处理逻辑实际上都在PlayerInput里。关于这一点，后面我们会细谈。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implement an Actor component for input bindings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An Input Component is a transient component that enables an Actor to bind various forms of input events to delegate functions.  </span></span><br><span class="line"><span class="comment"> * Input components are processed from a stack managed by the PlayerController and processed by the PlayerInput.</span></span><br><span class="line"><span class="comment"> * Each binding can consume the input event preventing other components on the input stack from processing the input.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>(transient, config=Input, hidecategories=(Activation, <span class="string">&quot;Components|Activation&quot;</span>))</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> UInputComponent: <span class="keyword">public</span> UActorComponent</span><br></pre></td></tr></table></figure>
<h3 id="actor内的inputcomponent"><a class="markdownIt-Anchor" href="#actor内的inputcomponent"></a> Actor内的InputComponent</h3>
<p>InputComponent在Pawn和Controller上非常常见，但实际上，其实Actor上就有在维护InputComponent相关的东西：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> AActor : <span class="keyword">public</span> UObject</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** If true, all input on the stack below this actor will not be considered */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditDefaultsOnly, Category=Input)</span><br><span class="line">	uint8 bBlockInput:<span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Automatically registers this actor to receive input from a player. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category=Input)</span><br><span class="line">	TEnumAsByte&lt;EAutoReceiveInput::Type&gt; AutoReceiveInput;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** The priority of this input component when pushed in to the stack. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(EditAnywhere, Category=Input)</span><br><span class="line">	int32 InputPriority;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Component that handles input for this actor, if input is enabled. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(DuplicateTransient)</span><br><span class="line">	TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">UInputComponent</span>&gt; InputComponent;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actor上序列化出来的属性如图。默认情况下，Actor是不会接收用户输入的，即按图中配置Actor是不会响应PlayerInput设定好的输入事件的，但若是希望此Actor响应用户输入的话（在此Actor上使用输入事件，并使其实时响应），则需要修改<code>AutoReceiveInput</code>的值为<code>Player0</code>。</p>
<p><img src="Input_InputOnActor.png" alt="" /></p>
<p>相应的判定代码如下，该函数是在Actor生成的时候去调用的，主要就是在关卡一级进行Actor的输入管理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AActor::PreInitializeComponents</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (AutoReceiveInput != EAutoReceiveInput::Disabled)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">const</span> int32 PlayerIndex = <span class="built_in">int32</span>(AutoReceiveInput.<span class="built_in">GetValue</span>()) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		APlayerController* PC = UGameplayStatics::<span class="built_in">GetPlayerController</span>(<span class="keyword">this</span>, PlayerIndex);</span><br><span class="line">		<span class="keyword">if</span> (PC)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">EnableInput</span>(PC);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">GetWorld</span>()-&gt;PersistentLevel-&gt;<span class="built_in">RegisterActorForAutoReceiveInput</span>(<span class="keyword">this</span>, PlayerIndex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="playercontroller内的inputstack"><a class="markdownIt-Anchor" href="#playercontroller内的inputstack"></a> PlayerController内的InputStack</h3>
<p>PlayerController间接继承自Actor，所以会有一个自己的InputComponent，但是同时负责构建和维护一个InputStack（通过Update，Push，Pop等操作）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> APlayerController : <span class="keyword">public</span> AController</span><br><span class="line">&#123;	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">TickPlayerInput</span><span class="params">(<span class="type">const</span> <span class="type">float</span> DeltaSeconds, <span class="type">const</span> <span class="type">bool</span> bGamePaused)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ProcessPlayerInput</span><span class="params">(<span class="type">const</span> <span class="type">float</span> DeltaTime, <span class="type">const</span> <span class="type">bool</span> bGamePaused)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">BuildInputStack</span><span class="params">(TArray&lt;UInputComponent*&gt;&amp; InputStack)</span></span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Internal.  Current stack of InputComponents. */</span></span><br><span class="line">	TArray&lt; TWeakObjectPtr&lt;UInputComponent&gt; &gt; CurrentInputStack;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Refresh state specific input components */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">UpdateStateInputComponents</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/** Adds an inputcomponent to the top of the input stack. */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">PushInputComponent</span><span class="params">(UInputComponent* Input)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Removes given inputcomponent from the input stack (regardless of if it&#x27;s the top, actually). */</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">PopInputComponent</span><span class="params">(UInputComponent* Input)</span></span>;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>ProcessPlayerInput</code>被<code>TickPlayerInput</code>调用（<code>TickPlayerInput</code>又被PlayerTick调用，故是每帧调用），其内部首先会调用<code>BuildInputStack</code>构建输入栈，再去调用<code>PlayerInput-&gt;ProcessInputStack(InputStack, DeltaTime, bGamePaused);</code>，即使用PlayerInput来处理InputStack。</p>
<p>这样基本就构建出输入处理的流程。</p>
<p><img src="Input_InputProcessingProcedure.png" alt="" /></p>
<p>图中的InputComponent存在优先级，即如果前面一层的InputComponent接收了输入（PlayerInput在处理输入时的逻辑），那么堆栈的下方将会无法访问（不会相应输入事件），这个优先级其实就是由<code>BuildInputStack</code>构建输入栈时的压栈顺序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">APlayerController::BuildInputStack</span><span class="params">(TArray&lt;UInputComponent*&gt;&amp; InputStack)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// Controlled pawn gets last dibs on the input stack</span></span><br><span class="line">	APawn* ControlledPawn = <span class="built_in">GetPawnOrSpectator</span>();</span><br><span class="line">	<span class="keyword">if</span> (ControlledPawn)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (ControlledPawn-&gt;<span class="built_in">InputEnabled</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// Get the explicit input component that is created upon Pawn possession. This one gets last dibs.</span></span><br><span class="line">			<span class="keyword">if</span> (ControlledPawn-&gt;InputComponent)</span><br><span class="line">			&#123;</span><br><span class="line">				InputStack.<span class="built_in">Push</span>(ControlledPawn-&gt;InputComponent);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// See if there is another InputComponent that was added to the Pawn&#x27;s components array (possibly by script).</span></span><br><span class="line">			<span class="keyword">for</span> (UActorComponent* ActorComponent : ControlledPawn-&gt;<span class="built_in">GetComponents</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				UInputComponent* PawnInputComponent = <span class="built_in">Cast</span>&lt;UInputComponent&gt;(ActorComponent);</span><br><span class="line">				<span class="keyword">if</span> (PawnInputComponent &amp;&amp; PawnInputComponent != ControlledPawn-&gt;InputComponent)</span><br><span class="line">				&#123;</span><br><span class="line">					InputStack.<span class="built_in">Push</span>(PawnInputComponent);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// LevelScriptActors are put on the stack next</span></span><br><span class="line">	<span class="keyword">for</span> (ULevel* Level : <span class="built_in">GetWorld</span>()-&gt;<span class="built_in">GetLevels</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		ALevelScriptActor* ScriptActor = Level-&gt;<span class="built_in">GetLevelScriptActor</span>();</span><br><span class="line">		<span class="keyword">if</span> (ScriptActor)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (ScriptActor-&gt;<span class="built_in">InputEnabled</span>() &amp;&amp; ScriptActor-&gt;InputComponent)</span><br><span class="line">			&#123;</span><br><span class="line">				InputStack.<span class="built_in">Push</span>(ScriptActor-&gt;InputComponent);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">InputEnabled</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		InputStack.<span class="built_in">Push</span>(InputComponent);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Components pushed on to the stack get priority</span></span><br><span class="line">	<span class="keyword">for</span> (int32 Idx=<span class="number">0</span>; Idx&lt;CurrentInputStack.<span class="built_in">Num</span>(); ++Idx)</span><br><span class="line">	&#123;</span><br><span class="line">		UInputComponent* IC = CurrentInputStack[Idx].<span class="built_in">Get</span>();</span><br><span class="line">		<span class="keyword">if</span> (IC)</span><br><span class="line">		&#123;</span><br><span class="line">			InputStack.<span class="built_in">Push</span>(IC);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			CurrentInputStack.<span class="built_in">RemoveAt</span>(Idx--);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>这样基本上就将Input相关的代码进行了一遍简要的梳理，其内部的细节、流程基本已经清晰明了。我们在日常编程使用时，接触最多的可能是在Pawn/Character上使用<code>SetupPlayerInputComponent</code>来进行InputComponent的配置，底层的这些流程被封装好我们基本上是看不到的。</p>
<p>有人可能会认为我做这样一番解析工作的意义不大，只要会使用就可以了。出于使用的目的话，确实如此，但是当我们希望更加明了引擎的架构，甚至范围再小一些，希望明了PlayerController，Actor等这些基础类的架构时，一点点的模块化拆解可能反而是更加聪明的做法。</p>
<p>我们当然可以仅仅看一下官方文档里的相应的介绍，但是其字里行间隐藏的机要，不真正去到代码里，只能是看个皮毛。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/5.0/en-US/input/">虚幻 5.0 Documentation - Input</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>ue5</tag>
        <tag>c++</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻基础之Gameplay游戏框架之Level和World</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/</url>
    <content><![CDATA[<p>游戏中的虚拟世界是如何组织的呢？</p>
<p>这里，在玩家中流行使用一个词——关卡。玩家们进入关卡，探索关卡内的迷宫，击败关底boss，然后进入下一个关卡，周而复始。</p>
<p>在Unity3D里，这个关卡被称为是Scene，作为游戏内的一项项单独的资产而存在。这些Scene可以单独存在，也可以和其他Scene组合使用（多场景加载），同时，Scene和Scene之间又可以用SceneManager来做跳转（加载和卸载）。</p>
<p>在unreal engine里对于关卡的使用更加直白，就直接是一个个的Level，同样对于关卡本身所应该具备的逻辑操作（关卡的游玩，关卡的加载和卸载），虚幻也实现了一套架构来承载。</p>
<p>但是什么是World呢？单单用“世界”一词似乎太过简单，我们在游戏开发里做的一切——音乐、渲染、物理规则，这些所有都是为了让玩家感受到另一个不同于现实世界的世界。可以说玩家将在游戏内体会到的一切都应该是属于这个World的范畴内的。</p>
<p>虚幻本身也基本上是以这种思路来安排World的角色的，零散的Level将玩家的完整体验切割成段，所有的Level流程组合起来才成了对World的完整体验。（将World切割成一个个的Level的原因之一也是前一个时代机器性能不足而做出妥协，我们没办法把一整个游戏的所有东西全部一下子加载进来，带宽也好，内存也好。现如今出现了越来越多的开放世界游戏，正是业内的能工巧匠们利用硬件的进步和自己的各种奇思妙想来越来越妥善得解决这个问题）</p>
<span id="more"></span>
<p><ul class="markdownIt-TOC">
<li><a href="#%E7%BC%96%E8%BE%91%E5%99%A8%E5%86%85%E7%9A%84level">编辑器内的Level</a>
<ul>
<li><a href="#level%E7%9A%84%E5%88%9B%E5%BB%BA">Level的创建</a></li>
<li><a href="#level%E7%9A%84%E4%BF%9D%E5%AD%98">Level的保存</a></li>
<li><a href="#level%E7%9A%84%E6%89%93%E5%BC%80">Level的打开</a></li>
<li><a href="#%E8%AE%BE%E7%BD%AE%E6%B8%B8%E6%88%8F%E7%9A%84%E9%BB%98%E8%AE%A4level">设置游戏的默认Level</a></li>
<li><a href="#level%E7%9A%84%E8%B7%B3%E8%BD%AC">Level的跳转</a></li>
</ul>
</li>
<li><a href="#world%E5%A4%9Alevel%E7%9A%84%E7%AE%A1%E7%90%86">World——多Level的管理</a>
<ul>
<li><a href="#world-setting">World Setting</a></li>
<li><a href="#ulevel%E5%92%8Cuworld">ULevel和UWorld</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%A7%84%E5%88%92">总结与未来的工作规划</a></li>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
</ul>
</p>
<h2 id="编辑器内的level"><a class="markdownIt-Anchor" href="#编辑器内的level"></a> 编辑器内的Level</h2>
<p>在虚幻引擎内，Level是作为一项资产而存在，也就是后缀为<code>.umap</code>的文件。也就是说，Level支持所有文件一级的操作——创建，保存，打开等等。</p>
<p>这一小节快速的罗列一下Level（或者说<code>.umap</code>文件）的基本操作和用法。</p>
<h3 id="level的创建"><a class="markdownIt-Anchor" href="#level的创建"></a> Level的创建</h3>
<p>快捷键：Ctrl + N</p>
<p>键入快捷键命令后，调出如下的窗口，ue5中给出了一些默认的关卡模板，这些模板（除了Empty Level）会提供一些关卡所需的基本内容，如基本光照环境，基本的天空球等等。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/LevelWorld_CreateLevel.png" alt="" /></p>
<p>选定模板后，点击创建即可。此时编辑器会最懂打开并加载选定的模板。</p>
<p>但是注意，此时该Level还没有被保存，资产面板中也还没有出现对应的<code>.umap</code>文件。</p>
<h3 id="level的保存"><a class="markdownIt-Anchor" href="#level的保存"></a> Level的保存</h3>
<p>快捷键：Ctrl + S</p>
<p>键入快捷命令后，调出如下窗口，这一步就是要选定<code>.umap</code>文件的命名和保存位置。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/LevelWorld_SaveLevel.png" alt="" /></p>
<p>此外，在切换当前编辑器显示的Level时，编辑器也会弹出窗口提示Level的相关保存事宜。</p>
<h3 id="level的打开"><a class="markdownIt-Anchor" href="#level的打开"></a> Level的打开</h3>
<p>快捷键：Ctrl + O</p>
<p>键入快捷命令后，调出如下窗口，其实就是相当于加了Level过滤器的资产界面，只会显示Level类型的内容。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/LevelWorld_OpenLevel.png" alt="" /></p>
<p>当然，直接在资产选择界面也可以选定相应的Level资产并且双击打开。</p>
<h3 id="设置游戏的默认level"><a class="markdownIt-Anchor" href="#设置游戏的默认level"></a> 设置游戏的默认Level</h3>
<p>我们的游戏打开时会加载哪个Level呢？总不能什么都不加载空荡荡吧？</p>
<p>相关的选项可以在Project Settings -&gt; Maps &amp; Modes -&gt; Default Maps来进行配置。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/LevelWorld_DefaultLevel.png" alt="" /></p>
<ul>
<li>Editor Startup Map定义了当打开编辑器时默认加载哪个Level，这是为了方便我们的开发编辑；</li>
<li>Editor Templete Map Overrides会去重写当我们调出创建Level的窗口时所现实的模板，我们可以将一些自己做的模板添加进去，方便开发工作；</li>
<li>Game Default Map定义了游戏的默认地图，也就回答了我们上面的那个问题，游戏开始时加载哪一个Level；</li>
<li>Transition Map定义了当我们从一个Level向另一个Level跳转时所使用的过渡地图；</li>
</ul>
<h3 id="level的跳转"><a class="markdownIt-Anchor" href="#level的跳转"></a> Level的跳转</h3>
<p>那么既然现在已经可以创建一个个的Level了，那么自然而然就会想到去做Level间的跳转，即我们游戏的主角结束一个Level的游玩后，通过某种装置或者传送门进入到另外的一个Level，这个跳转往往会需要一定的时间，甚至于某些情况下需要做一些跳转过渡画面来等候。</p>
<p>最简单的方案，可以使用GameplayStatics提供的了一个静态方法OpenLevel，可以用于进行关卡的打开。</p>
<p>可以利用TriggerBox制作一个简单的触发机制，等到玩家角色进入范围时进行关卡的跳转。</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/LevelWorld_TriggerBox.png" alt="" /></p>
<p>方法的核心部分方法的核心部分是GEngine的SetClientTravel，目前为止现在了解到这一层就足够了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">UGameplayStatics::OpenLevel</span><span class="params">(<span class="type">const</span> UObject* WorldContextObject, FName LevelName, <span class="type">bool</span> bAbsolute, FString Options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">	GEngine-&gt;<span class="built_in">SetClientTravel</span>( World, *Cmd, TravelType );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="world多level的管理"><a class="markdownIt-Anchor" href="#world多level的管理"></a> World——多Level的管理</h2>
<p>从虚幻编辑器内的安排上我们似乎并不能够很好的看清World的存在，与之相关联的最直接的好像有一位World Setting的存在，那我们就先来看看World Setting里有什么内容。</p>
<h3 id="world-setting"><a class="markdownIt-Anchor" href="#world-setting"></a> World Setting</h3>
<p>World Setting面板的打开路径是Window-&gt;World Setting，其粗略内容如下：</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/LevelWorld_WorldSetting.png" alt="" /></p>
<ul>
<li>Precomputed Visibility，预先计算出的可见性。动态遮挡剔除相关的优化设置，可以为某些硬件性能较差的平台节省运行时内存的消耗，尤其是当关卡内容较少或较小时优化效果会比较好；</li>
<li>Game Mode，游戏模式。当前关卡的GameMode配置，可以覆盖掉全局设置的GameMode；</li>
<li>Lightmass，光照。当前场景的光照细节设定，主要针对静态光烘培、ao等相关内容的配置，是配置全局光照的位置；</li>
<li>World，世界。一些世界相关的配置，主要是游玩边界，寻路系统相关的内容；</li>
<li>Physics，物理。是否去覆盖全局的重力设定，以及物理碰撞的相关内容的设置；</li>
<li>World Partition，世界分区。ue5引入的新特性之一，主要负责大世界管理的相关内容，是一套全新的流式关卡管理和解决方案，相关内容我也会在后续做相关的内容提取和撰写；</li>
<li>Broadphase，Broadphase碰撞的配置选项，是NVIDIA的PhysX系统提供的特性；</li>
<li>Foliage，专门针对于世界分区中植被相关的设置，主要是划分的网格大小；</li>
<li>Navigation，关卡中寻路网格大小的相关设置；</li>
<li>VR，对VR来说单位对应相关的设置，虚幻中使用虚幻单位（Unreal Unit），该参数主要还需要参考虚拟世界构建时所使用的尺度；</li>
<li>Rendering，配置与距离场环境光遮蔽相关的以及动态间接阴影的配置；</li>
<li>Audio，设置项目中的默认音效配置，如音量、混响和渐变等；</li>
<li>Tick，Actor的Tick行为（每帧执行）的相关配置；</li>
<li>AI，AI系统的配置（开启，以及和核心类配置）；</li>
<li>Cooking，构建游戏中的其中一个过程——烘培过程的配置；</li>
</ul>
<p>从World Setting里的配置内容来看，World Setting更像是描述单个的Level的设置（而不是对整个World的配置），即如果将之成为是Level Setting也不过分。</p>
<p>事实上也的确如此，其背后原因从代码层面可以一窥端倪。</p>
<h3 id="ulevel和uworld"><a class="markdownIt-Anchor" href="#ulevel和uworld"></a> ULevel和UWorld</h3>
<p>ULevel的部分核心属性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// ULevel本身直接继承于UObject，所以本身也具备垃圾回收，反射，支持序列化，等等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The level object.  Contains the level&#x27;s actor list, BSP information, and brush list.</span></span><br><span class="line"><span class="comment">// Every Level has a World as its Outer and can be used as the PersistentLevel, however,</span></span><br><span class="line"><span class="comment">// when a Level has been streamed in the OwningWorld represents the World that it is a part of.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Level is a collection of Actors (lights, volumes, mesh instances etc.).</span></span><br><span class="line"><span class="comment"> * Multiple Levels can be loaded and unloaded into the World to create a streaming experience.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">UCLASS</span>(MinimalAPI)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ULevel</span> : <span class="keyword">public</span> UObject, <span class="keyword">public</span> IInterface_AssetUserData, <span class="keyword">public</span> ITextureStreamingContainer</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 前面提到了GameStatics里的OpenLevel方法，该方法的参数虽然是关卡名，</span></span><br><span class="line">	<span class="comment">// 但实际底层的SetClientTravel函数的接收的确是一个FURL类型的参数，而ULevel也维护着这样一个变量</span></span><br><span class="line">	<span class="comment">/** URL associated with this level. */</span></span><br><span class="line">	FURL					URL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关卡本身算是Actor们的载体（集合），这里用一个容器来容纳所有的Actor元素</span></span><br><span class="line">	<span class="comment">/** Array of all actors in this level, used by FActorIteratorBase and derived classes */</span></span><br><span class="line">	TArray&lt;AActor*&gt; Actors;</span><br><span class="line">		</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 关卡也存着一枚指向所在世界的指针</span></span><br><span class="line">	<span class="comment">/** </span></span><br><span class="line"><span class="comment">	 * The World that has this level in its Levels array. </span></span><br><span class="line"><span class="comment">	 * This is not the same as GetOuter(), because GetOuter() for a streaming level is a vestigial world that is not used. </span></span><br><span class="line"><span class="comment">	 * It should not be accessed during BeginDestroy(), just like any other UObject references, since GC may occur in any order.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TObjectPtr&lt;UWorld&gt; OwningWorld;</span><br><span class="line">			</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 关卡蓝图（level blueprint），也对应着我们可以在编辑器内打开的那个关卡蓝图，</span></span><br><span class="line">	<span class="comment">// 它本身是一个ALevelScriptActor，继承自Actor，所以拥有着Actor的大部分特性（包括接收输入等）</span></span><br><span class="line">	<span class="comment">// 自然地，既然是Actor，LevelScriptActor也包含在上面Actors数组里</span></span><br><span class="line">	<span class="comment">/** The level scripting actor, created by instantiating the class from LevelScriptBlueprint.  This handles all level scripting */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(NonTransactional)</span><br><span class="line">	TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">ALevelScriptActor</span>&gt; LevelScriptActor;</span><br><span class="line">			</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 关卡中保存着WorldSettings的一枚指针，正是前面编辑器中的那个World Setting</span></span><br><span class="line">	<span class="comment">// 自然地，既然是Actor，WorldSettings也包含在上面Actors数组里</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>()</span><br><span class="line">	TObjectPtr&lt;AWorldSettings&gt; WorldSettings;</span><br><span class="line">				</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Actor是我们已经比较熟悉的类，现在我们知道LevelBlueprint本身也是Actor，这也是属于“不可见的”Actor之一。</p>
<p>而LevelScriptActor直接继承自Actor，当然在Actor基础上，做了一定的补充和修改，比如说关于渲染和碰撞等，但是又允许继承自Actor的输入相关的接收等，我们在蓝图中使用时基本上就按Actor的理解来写即可。</p>
<p>WorldSetting则是继承自AInfo（也就是常见的允许存在于），不同于那些可以拖进编辑器场景中的，AInfo就是那类为场景做贡献但是不需要进入到场景中的Actor。</p>
<p>这一部分代码的阅读也着重参考了大钊的文章（参考文底连接）：</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/LevelWorld_ULevelStructure.png" alt="" /></p>
<p>除了其他零零碎碎的成员，还有一个比较关键的就是OwningWorld指针，它指向该关卡所属的UWorld对象。</p>
<p>UWorld的部分核心属性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相较于Level，World更像是一个管理者，Level的管理者</span></span><br><span class="line"><span class="comment">// Level在它上面可以自由组合，可以流式加载，从而作为更庞大的世界的基础</span></span><br><span class="line"><span class="comment">// 而且最重要的，World同样可以不只有一个，游戏的世界，编辑器的世界，PIE实例世界等等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * The World is the top level object representing a map or a sandbox in which Actors and Components will exist and be rendered.  </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A World can be a single Persistent Level with an optional list of streaming levels that are loaded and unloaded via volumes and blueprint functions</span></span><br><span class="line"><span class="comment"> * or it can be a collection of levels organized with a World Composition.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * In a standalone game, generally only a single World exists except during seamless area transitions when both a destination and current world exists.</span></span><br><span class="line"><span class="comment"> * In the editor many Worlds exist: The level being edited, each PIE instance, each editor tool which has an interactive rendered viewport, and many more.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>(customConstructor, config=Engine)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ENGINE_API</span> UWorld <span class="keyword">final</span> : <span class="keyword">public</span> UObject, <span class="keyword">public</span> FNetworkNotify</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// PersistantLevel将是我们后面一个小节的核心内容之一，也可以看作所谓的主关卡</span></span><br><span class="line">	<span class="comment">// 其主要作用体现在关卡的流式管理（Level Streaming）中</span></span><br><span class="line">	<span class="comment">// 它本身的话代表了当前世界中的核心关卡（代表着当多关卡之间的设置有冲突时，优先以PersistantLevel为依据）</span></span><br><span class="line">	<span class="comment">/** Persistent level containing the world info, default brush and actors spawned during gameplay among other things			*/</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">ULevel</span>&gt;								PersistentLevel; </span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 相对于PersistantLevel，就会有StreamingLevels，表示那些动态加载和卸载的关卡们</span></span><br><span class="line">	<span class="comment">// PersistantLevel只有一个，而StreamingLevels的数量就很灵活了</span></span><br><span class="line">	<span class="comment">/** Level collection. ULevels are referenced by FName (Package name) to avoid serialized references. Also contains offsets in world units */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TArray&lt;TObjectPtr&lt;ULevelStreaming&gt;&gt; StreamingLevels;</span><br><span class="line">		</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 世界的类型</span></span><br><span class="line">	<span class="comment">/** The type of world this is. Describes the context in which it is being used (Editor, Game, Preview etc.) */</span></span><br><span class="line">	TEnumAsByte&lt;EWorldType::Type&gt; WorldType;</span><br><span class="line">		</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 当前的GameMode，当有多个关卡加载到世界中时，对应也会有多个World Setting</span></span><br><span class="line">	<span class="comment">// 那么以哪个配置为准呢，这里负责维护着对应的指针</span></span><br><span class="line">	<span class="comment">/** The current GameMode, valid only on the server */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">AGameModeBase</span>&gt;						AuthorityGameMode;</span><br><span class="line">			</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 同上</span></span><br><span class="line">	<span class="comment">/** The replicated actor which contains game state information that can be accessible to clients. Direct access is not allowed, use GetGameState&lt;&gt;() */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">AGameStateBase</span>&gt;						GameState;</span><br><span class="line">				</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 世界就是关卡的集合，这里就是关卡们组成的数组</span></span><br><span class="line">	<span class="comment">/** Array of levels currently in this world. Not serialized to disk to avoid hard references. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TArray&lt;TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">ULevel</span>&gt;&gt;						Levels;</span><br><span class="line">				</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// PersistentLevel和CurrentLevel只是个快速引用。</span></span><br><span class="line">	<span class="comment">// 在编辑器里编辑的时候，CurrentLevel可以指向其他Level，但运行时CurrentLevel只能是指向PersistentLevel。</span></span><br><span class="line">	<span class="comment">/** Pointer to the current level being edited. Level has to be in the Levels array and == PersistentLevel in the game. */</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">ULevel</span>&gt;								CurrentLevel;</span><br><span class="line">					</span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 该World所从属的GameInstance</span></span><br><span class="line">	<span class="built_in">UPROPERTY</span>(Transient)</span><br><span class="line">	TObjectPtr&lt;<span class="keyword">class</span> <span class="title class_">UGameInstance</span>&gt;						OwningGameInstance;</span><br></pre></td></tr></table></figure>
<p>这部分代码的阅读同样参考了大钊的文章：</p>
<p><img src="%E8%99%9A%E5%B9%BB%E5%9F%BA%E7%A1%80%E4%B9%8BGameplay%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E4%B9%8BLevel%E5%92%8CWorld/LevelWorld_WolrdLevelRelation.png" alt="" /></p>
<h2 id="总结与未来的工作规划"><a class="markdownIt-Anchor" href="#总结与未来的工作规划"></a> 总结与未来的工作规划</h2>
<p>本文从使用层面总结了Level的基础用法，从编辑器层面罗列了Level和World相关的配置选项，还从代码层面了解几个核心类（Level，World等）之间的架构关系。</p>
<p>其中尤其，从Level和World的代码中，可以清晰得看到Level是如何承载Actor的（包括一些看不见的Actor），看到World的组成又是怎样的。当然虚幻中这两者的应用远不止于此，这篇文章仅仅算是将Level和World相关内容破了个题，相关的内容还有World是如何组织Level的——Level Streaming相关内容，大世界相关的优化问题——World Composition和World Partition相关的配置，等等。</p>
<p>本文更多的是对几个基本概念进行拆解，对代码结构有一个基本的认识，在此基础之上，还会再跟进Level Streaming、World Composition和World Partition相关的内容和文章。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://docs.unrealengine.com/5.0/en-US/levels-in-unreal-engine/">虚幻 5.0 Documentation - Levels</a></p>
<p><a href="https://docs.unrealengine.com/5.0/en-US/level-streaming-in-unreal-engine/">虚幻 5.0 Documentation - Level Streaming</a></p>
<p><a href="https://docs.unrealengine.com/5.0/en-US/world-partition-in-unreal-engine/">虚幻 5.0 Documentation - World Partition</a></p>
<p><a href="https://docs.unrealengine.com/5.0/en-US/gameplay-framework-in-unreal-engine/">虚幻 5.0 Documentation - Gameplay Framework</a></p>
<p>知乎作者 大钊 的文章<a href="https://zhuanlan.zhihu.com/p/22924838">《InsideUE4 GamePlay架构（二）Level和World》</a></p>
<p>b站虚幻引擎官方视频<a href="https://www.bilibili.com/video/BV1xx411h7Aa">《Getting Started with World Composition》</a></p>
<p>虚幻英文直播<a href="https://www.bilibili.com/video/BV1Py4y177ZS">《世界构建新功能 | New World Building Features》</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>C++</tag>
        <tag>Level</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻5新特性之EnhancedInput</title>
    <url>/2022/04/12/%E8%99%9A%E5%B9%BB5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BEnhancedInput/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="375f3251e49765dede40f4c2a42d899f85d3e706d49e288a5db0994db4f00850">fa2633a7d743470e974359ef9dad0234f30774894771689c244dd76c90a00c707e2b0b6b53c70c9116e6c04f325fabfebe5d967d3d9c14599e169f7aaa1570c3c38240daf1ae1532d5afb15dba8aa3ea55f48ee2c31074acb32324f723d534391770dae3a38b10dacae7795948a51bc4ef3b82a09dcf012941212b52d73266488abccda326ce4a55ac0bea4373a86437aa624a19c90b06bdb49b63dd79dba9d6fdf7010cfd779e498422f63a46bab23040634b2d5bb42e219d1e09f74b1043951dfa02b06ac6874f39015805d80c561c10351d68c48d8f23fbaa8a3cf95f3b310e3b26d18ba7faac9ecaf4195e8869770541103fd396aa084991018a840f4959c03f7efc977b1e2fdaa83b3713f6195b54859d66e4681fe6175820d9b444ce30abee77bb9101dcef8e2242e6b1a6da23b2b33c66adf3b910c7e97ac3637274196a379cdbf65f6950fa9ca5ee13640763b062b638722851bebb3d619d1c5324ad25df4fea273b02b99e34bbbbc424aa42cba1e5f11e11da7ddbc74c12bc671ad1f27486707bbeceaa025abe1a02de92f298e2220460373913035a1c5e2febfcdb5e4a360db269edc9d3bc7c9a9ff55e27ca780d875f4721fb184c4fea8b2730b55274fc94e153f0f41cc8b5beaca140add99144792934aeebeccce6e25ee77fc3047d81bee22d853443461d008a9a3f625be879b3a24883739d69a382d5e349d4ab8fba7f31fcddca0ad098f4f1129c038fc0fd99a24f55d63a92d01df9ac4b975411e852fa823a26c9f2dcec2cb089878ce62a7ae862a2342264bd00b25eff896a916b8ca07e9d9e8348e61b7f909faf109f7ffc035e09f8fd0b89553787f72f658a1711ea01497941093f834f05757069d9f92db3b0e1458fd7d104b2f2cbfe9db1a1dfbaf80b11c63b9228315647057959d5d7570106c5a8d6d1961da0551e6237892bcfa9636a535633c687d58baa37deb32ac674d5191dfbcb85b7ee29036efb235ea451a1484752a17cae2516eda26646b9da5d83ebe07752d0a0bd1fde1c9444b7072215b126a51368bd400d2ea54c3ccd8863399a0fc12e92e6f47b3bc5622a1023c970af7fea545cc9c519f135215f9184e55eec63cab81eace9dc433b7785daa8bfdfeeb0fbfb0cab6e3d2603d2bc386dd6d793677de2efdf57db81099598a11516dcfbffbf6bbb561d4bd7a41825f61f8e17197bd9d9cefe334706ae5acfdaf3211fa8a8251efe6be238bf5d9f5db9872f0bcffa8c2cfef5f02c74bc766284df600ec31857006ff08851fc24f860c262bc76cd932d587455a6e766e6171e888b0f369e4f8d6cda6bd44c39e2e78b05e3220d684f7bf5a84e27fb8dec55d60521c7b8df2ff3db61ffbd2070e1075b9cef5623f30584068879bc1a292374392a08333b1a581b9cb4c15ff14f3d508bb9b240ce6d5769b7036be2268cd234e33dbe09ba809e69be91ada2950e7f2377d81454634514cf0a814d0536a23619e13c947e32b3f30042bcc3cfa2db217f9af39fe0b6707bc7fda96223f52bb5f4495b2533fe386fc28a42f022995b342078915d72dcab0a93ecf7af6552fc2d6fbcd1bb8aa34ca841fd64f58ec118cfe8def98d15db5376b993087f4cf4b6918fb4158dd92bec1378ceea7604cbefa67e335d0bafde192e3c73a752ebcb9027b5841a38a16ce83ff8eb4ae947275a9648bce5e1c681464d5a5195cfb33a8ff8d5284c39f29883070bc227a6a0b9b1fa191a0afa19e9dc48444449a6dfc9e5aed2ba7c401ed3cde2b566fa366192f333d9b58089eb6716e163c4f817c9e2d96d0a7fa4800d67da334167752426cf69c82ff870a704176763c7eef6f906fd67b5f4bcc7a7ea9dc20d1b4d701bee9b935c65a65374a184dfb284f185eaf883bc8d66135d3f46f26bce2d2e8b9e98dca1f67d0039f9ee36eccbd0cded2ac116b2ee8807446d6898b343d801b1f1d9d1626c5dbe17044848ab9b082e2d2edfc20e9fd2bf356e86d294a296a46a8782a1b255da6d64b81b5cc85dbdf2388a961780d25fd259026f080e7fe8a200d250eca79728dd3b84a5485203283d3ebec47cfa6e16c846c08c3dfc2f195c1439f8da49896df258a05b996bc7104a7108c1700bca4192b8fad7dae860df4f660621e24be6238bd24b414945866263873f9d836d37a3b45eb185f5a9d04754b715a41949d66e860989f4cb69dfa3bf80741b9bcd8d4ec92695434f5cf123ca3cf27fb84dd07cd26ec3054bc63ec435a3551b994f2d33a65fc14282aab589c860d470c4436c99767709e28a4abf657489f81a61f4a9e0ae113ae9572fa8b6b75a6ca720dd212f048ad85fde4ef853bc3925e9dd255fba607b835f5c8c65dfe1bb3739332411da5b5e635e21c6aa8102755e717bd18aa20c6d132680382a7596a848e839571319518efb32ad20fdfd31c530a1050111afa4136dc2589a12cdb125696236c095fbbd6008d1fe29964295c8e1a00c2bf5e6d493cbf32c55ed062662ae2a8034af9fd4e12d053e7ab1a77795aec24570467f018ccfdacaac28af48a61d34c875f5bdd9f284fc5712a1b26eecc9a81dc4fa767425897426daf2bc773000d27fc6df7f22670993b3608c3787011b081a3d0b6918aea2b2cacc80468b37c459c420068841c0bc46256a9993f7be1a111578fbbab18f0fce4d142bf7029e840aa2ce523263ea6ebfa51f965dd5055e9fe014ec129d2c8dac4165145bf8df8a32866b9c8995ce28d594a763c7e5a6e3efc63b3de8dedd153567ce627698fea48c39046f517f1a5958084af1b60e2ca13329ed53d28637862403a76934a1facb1cda30c36f5b720d6483a0f70a013088387e32d07f8556257d414795c58f46cf7651032778a641ca8675978ef47fa708c3e016c6082f82f1b6276504a11ceb3832bbb442f2b194060deecce85a46e9fa4befa59d8fd48f3afa4e3348e25bfcef0fd26617186ac42570c8aa222f2a52c9bbf637e9b38e6c5728390b691b0f092d45aa278bfafc1ab517a5cd8791b3bd67b18737c803646c72fd4605451dcc661378dcb1959c4c0e65935c232226e072bc34b80f60dd623a6fb7d0c373351141c1f4bb88d7b1628b3947c9d711d80eb40fb72df335c828cde418747201047d777e7bb288f550a5fbc50683c708b9a82b1dd0ff5bfef3ff54f50b3290cbbc20c344dcc70ca1e2fb72e52a5e68f028dcfeca2d29c498773a6524a0100bec4dcc5877ff89000f282ac1092def2c5d4b11b608f8cec099a1adb53204cd5d38678a6f98326ccce035495161c090bf66411416d5a1a1754873524b619899e9452ad8b8e4c1f3593fc56e2769322cfbe66e37d6836420c070f23cd96ce685e7a604257d8f0f3c02a0297276322dccd979978f65a7cb1b27a91943ba62c6d74de710e1b312bd2c78df7d0a79887c0f81810cb171cec08ede1016b32025948e4752c2958b95d81175cde022d2c16b707f748a67a895d43cdea403c8b7871ea9e890f5bd81703d5ac370880948b83b555fab035cf59aaf9ca33506251c4e9f513a28c86d171df45caa7d6f465b9b4394ab41faba378e35669b427d9f81af32a456ac32d85e848504c898c096dbc641c1147114bde469f95284896d319e0884081b4bb45c67824f2ae399abfbeb57dbed15853a30aa77f7922cd842093955b4ae55384cfea6c25a01f0f9bd44c47b27de3d4f7daba821e4556ba64af3a5d058193a0c0c57174d9392dc348e950a73307eb005e7f76eeddedf55b0850335f97535d0e039da1af925618a57daef772653bd872f0f2e88f743f70d481976b9df1956968709b3189d02cd05e0907fdae65f8f3f6bad7f99f55e4c5686e904d104d621d352669e0560292ed76e0f055e7aeb052141f20ec90fe2871d51dd7013136edbde62cfff899c65480feb0e07e30056e3a0963ec7de407fe365f2903b03bd059049db1ad51076672178b3b86af8bb9a10d7176fda6920d18f0a12d80ccd17ff4084af2bfb3735342681a02f040d1f51a820b8350e566a23c68bff4988a8461053d03411b1c67a81d0b8c00bbd6e8844f8c331008224e59bf4bbccecc7b71d12d06237e8fd483e84f79db3ce1d249f00a629179cb978935d6b44a386ddbb1803e2679f9c27ad1a432a2b1996625842ea654105d59b86751b51e5f02de7c2097baeb71187a2073cff5877eeb7e9cb7049394138c8814f19923eed90e8f7af7b20094c95cbcef54cd57997d44ab5da4963e676e1011669056af3707fd9d658f0c713a6d7a130e1acfe89f4aed2b96246d2e0428d1d8413906d2d48d34344d07b262cb8f44188c9f53acbf8bb0d90230dda51d0e1b3a057aa028b0f26a262f2db2c2b570bb5d9aa2a537255c4b4fffea61a00e21b5a86845bea048b133a86b8ba2d439de7bc70bdb90da0a048bf87c785b7eb85e95aa1408cfe2c2e4284e524320e28e60d9825b77a38d9c930c573f34792a9c7a4044255aa6154baf91bf658f08ece08a3825ec887c2b3064038dccc6ba61378e87a0523bbaee062edd693ba0558e3de9d27379dc76519eb12b95e2ffdc1e9a84164503c9ddee2dcf4842ac0cc4a7b592aa58173d6f437a391a9e4d934f144cb6f5c3aa194fd15d249091638d918bb9191b7be5301f64c2def008674e969cb168cbdb279bc6ba6707a799866ac48d90ab52c8a12fb09ee7d8a1452ca116b4ded74dc05afb83bdd76466b8387f23d2ab67865b3fe7e59e958a233d283d8a8ee64637b7b5d2644af0d8f47ee52eb05dcd35a79f9802495cffd3c36a5882073a580c8d0a1bcecafe38f28953e39aed69bc166acdc7a8c4b7a20e7c1461803d4f8734f3f48e4d540b988203f9166d18b5b86cf151b19ad0abde667c91d3a71437129a42db37590385817bede6dd282c52e17c0b34c848d503cd91d88e48866fbe94c0e2e4edcdefe37d40c4e9fa38275721b58d6a70ad8d8e7257dbd267328f314e0fe173034e6d234de81bd0c15b39a5dfcee6eaaea2f5b42806120354f913d4fd2f3badb0b4d2c545ed9aec3b261f760292498a688f23422ca5a3fe5b07199184638c04fee9c97de33c9bb8814cbd7e809616f99079839fee04857be33a619cb02d59aa452ea61334f1923194c78f4386fcb4bc49253010c77fc7dc06a674d2ef0dad1f0060b866d32fd6b5c86006fcb679e48b3382aca300f75a6b817e9da6051ccd02a4d0f04b68b3e39680bc771098b87782a4a86d107e610509c7b3be7722fedac34b1ed5b48a92ac75ebdb28dec500fb27e5179ecd89b867b2a7deb28dd9572c28e0327fdcfacb9b04e9115458b9691efc29fe6aa45731c7b23c4fda1768be636db1d11b5d83863f561e9a7cccb02ecd3e5b6f3bc5b6fa2ac0bbc72a9a43172b183892b715e09cfd4f8b10e1dfd84be80cb4f80eb75428ac0c32682338ee51797f4c8f7181bbd089ad77ae6195f59705f157dd53980b48ddfc582034799d46f88ea7d3d44f58a7dd989e03f801b40a0c8c85cb03b072f7a581d3ba8c9f8aade1c0ac9b63e9e935ff4e7509b0eba3237903b27421f0134d31485c27b596c77d9dffea351ad6e235af62fd6566c99ace3fa5840c2678e21d8f966b722ccfc702b888392f9a6b5e69017ea0fec9876e87c8e2cc12ffc4b01aa357bf5300dbf5e4a769fc4da3a7d31dee9f4f7e45d2981968b579ca25cb948ee87ad87c9485c751e230d98af9534fb54b9309a5ec80ae13557bae807cf456ee50bba7e08af9182f21f539d7e3a34a8d56b2e94290b91f931cc9a292627bfb5a0da2f63ba40b982690218a95eb3863b9bcc8f88d766a6fcb74214726308c20ee35079e3554c4cbc20d2d07da30a6cad1b0343cad73860a66dda18cb4b8d1540a5e2290097ef81f8cbf56b6a3ddfc87921110c57fdd46ef0e05d05f913beaad2093977334e08883c05f0826135edd9a0beb3eae3a32aa6abafa0f664e7c1dd32c157e263371302a3b70d8a89d5833366abc7920756dd74ea5e81854876d9ff8c823f509253ee54b27d943e483c396f06f0819cc9f5db28ee68f2411030df21c688d75bae6aee68e507ebd4b316188b50541af6928b5ef0839343b60d8c1f3f6e0638cb4614c5ac9b0e043ac905594f650def8a1efe87b7a910e2fb584aa2f2364a5b0f10061a1d05838c4596222b95a8afc52714cd7c5fc69c1548ae680e4b4e1d155922fc4b7cc7d7cdde4cc15625f4ab3a069c9be9cdaa38bc9b83a55a762f8fcc5c4a3f90a1915e2d998f81ce3d1042b1f84cdbf7811f54d51cd55a60ad99dd6d8138b58197b09c075b2dd6961fa050ebf35109329c5ddaa0f4256b1e563cb2e64e83f6d9c78eed0c7b4e2a35c204bc7086eb92f7736a090556f3f716ff20477b88ba37916d789f1588e5cd7795efc1dfa6274a2f7652c1dd447ff10d4d8591dc3376673253771e3376a59a3c8051083acf7b0a3c9d26cb4213419d33df3ae90e3363017a13a8fc36d51c1a7d5e779dd5318028516b4ff0dbebd2626445923cec366255f754598e10ede94a134054d26bb2edffeaab8ddcebcfa741c6c9f315a43db316846809adc0baba64be07a96cb390155556dca2a76f20a7dddf3a520cfe56912cd04fe91889732a006c9ce22251d7b91981709ed7feae0933ba3fb9e5dcf5c0fad326ade83ee2abed94c09a06cca0833f4a928da5c51ad811f6c9ce9f3a2b10f356df45346079c689643d99284738d06598e4d508f8c835e596d73987e828454861f7cfb00ff2b1a877131b7af3682554b86f1e58abea24b8d8775a537985b54de6414c56276c5a6a77918afb19c8edc620cbc88077172b06001fd2ff12dca489253064dd64bdc7d43e3a902b1a974b1ebaa074e437a586f539bd421f9769904bbc5448adf94467514a2ff89d4f7f8270ac427e0f359480cfebdcd3744673a6472c74d372e75df2225be23c5123107607cb3ac7eadbf5784cf20c3a8f11281e610a0b834012d2a4202a8e0e499f2f9d85cbe21576df0292bee5d75b90bd11410570b611f713b6ed83d191dbb46f912f85acd81a56ede792cb854fd21a270b46d6c4923d61e3ea125c6e04945e56aac241a88ccee6e4e152518a80dcefb77ac16948966023835aaa8ad842a87db76079ef09784dfbfa8c61412d49a704bf7a4e75e21400eab9fbba0e2119bc8be67fda8fc10bc4952dfe85409ded080b546ca6b242485cc8ca7969997c598159d4fb9519742aad63c01d74d0c534a7b6c0ff5bb8dcf66447424a746e2a98c1d0be72d3bb07f8ef8151dd1fb7f05e78e66aa5625aa9e6c30fc1166866e8bb801b545f0427e5195240faa7443d707d9eed6cbff28548bcac908c731630173f95b0559f9af9777bed1a59dd17e9844e57d25575b0563ac44e026f3334fc0224fc49cc71c12ca3322f6b84b89cd28a63d16eda2b75b384d612002691bb6fc99a0865fa6016ccda798b1bf16a977df54d2de918c0789eb4bbb0813d69b34386a55a249c66dba1d600166b92cce79b02bca3a6d58fb930c80e8e8939b9122cd4bced73b11c4a2b319319d19254dc06f0ec61951a7b52e778c0110bd1202c5f6662533bdfa0edc9d4c598c66cf0a69f929b0d1aa2ad6cd94094f4e68c45ea4e9d5a4e417046222b4202acca1cea3471d8daf9c7ecbf278de35021804deb1a2d95ea2d02c877be1cda65d16773aba707c68a99b987683ce4cc1162a17f91266e74cc3faa9c203de8f5a80e640728abdb06c60e8384abb459535c1bfa081f6095df89a20162702a1dea1a20c5365759ca2077fd4d5131dd34af812b1e78832a974347c4870f911212821be8ab2987c746566954322b5773e3280e22c09aac64349182c90904f87bd7ba647fd40dc70e222f9857c3fcd5fe9ea1bcfa3bd51703c1e0c02da5b6b644d9a124c060b476b3cc76071a01cf5588d85f12840a5e0819a9b1278906ee21c3e56131e116e35fcd97019e778bb2637daed025b7f4069eaf6949ece7080101d00a39c0bf5a7c7d052cf5405282029fc1b14e085a0030e6fa50ca556c0e2cfdfb2a5125d2ca53610f8744017228c83ca69722685335af5072d93216bed798c930bb5c25d4e59f72a341a387278909fa8c6669f13326d6ad9becb6cc651c0d91ce454af71101537ff42a809cb42f54bdfb3d4fd331652cdf44b749de4206abe1c3f17f8827bfd3f9b533b228bc1618394428c97d68c744157ff670240b8d68e86928ba339c8a3ea525bcd2d9d15a5a52c9ea8c1c1fbc886bee8c43b9aa080dac6446970011cb7856e4d59d6e94b9ba676861752af2398f5f9facc0bdbc4cd41feac6f2e3b8350ddeda8e9cf7688310cf28ad795c1988072e904a4a5698bbb50c6677d94cf7242f349b9a7a6ec991c8de06c58e179e1e3ebafac322cbcdcd0ce0fbf3d347540faf5a5e1f602229c51c75e5b3e3fee5fa1222da793cb1cbafad469b8dfcc8872f8b12f38e7c6d5ab1a02ec293fd2c8917befec50c06ec2dc1e9b3173d4394c231dd675cee0e0c9ac74b4d9835389e21e67a8eab4ba47d7687f06b6063d00d7a21f1b6ce74fddc8d8bc136619b529a3fd08e8853d2dc16a946377b15821d3616c51bd3255de6837beaf83db5e4be682577b0405e3e4ac61d7d78b8d2581f6eeaf7c9c7c0be2cfefecad980d5df3d0a9ff66e797ba1717b89644639dbf0d39ff93132b82e8f6caf9b182306adac117cb01eb129c5092c9e7a3685f8a1e37323a1a5a5c6e8556fa1f6a8101b5afe3a2e7deed27622c8dd296410e5a230791c85395c7040bef2ca38616daac266a3ff257f4ef0b19defb69308945b8dbfc8e846d27adb33660932469392c2982e86aa84fae09f1a90cf0127819be210614365e2f1545ea9735b070d5786982844d3e7cd2e8197806f0325283eb3ef1c40ae7fdbbd606ca905e413b561251678060eee189c97a353ff54f479237df4381dc2d90e8c2dec1d57c0f0f3a8b6136545a7aa6547d71203940deff3c9d3d7274b76b736dd03e3b2545b44574f203247bd192003f10a4a43b68568d368f6a53a3071844314b20709622d051849c87fae86a7bf6e0170726f585fda7f4fbab506da6bcd3f2799eb56c14d16d8f6b291e04ce4daeea73ad329a17567aa0cff80f4537514b2cb5ea77ef38dc3f71118c9db260fffa15e8bdfa233464da6728fe3817623debf1469f4deda8a031d0a9f42e76353a371839d5f88cad88e6693024906b9391ec2f832c9d840cec850120344b990909ce4cfaa3c8888b8cf64d0c7751f8218cc65865ac617bedd250174722e192d9ae427eb6fe527261d1474a585d91b99a153784b7d5ad85d28822685b62174587444360cbdb9546671bf56db7498de9b08c7a0095ed964475321f1be38f3df59242a2b5dc4502aab35a3f8bf73ecb935fabd72551c8a4246d8132b1c046ac567f3f10f67e77ef94777e94cfee42e997bfe807437f00cf593a96801ec835687da7f016039fc4bae5918a7066c563d944f54ac3a9e530cd4807a49526a84fe748cf1757c0997f110f13bc4f4c02d13b5abf314dedcb3861daa881770a5342d84ca50501f7424e199b585cffd1181d385825d5878a96d4bd6dcc4dfad00196ba1a211fc48d838957ec56659a104e13cc84ea7211ff678fedf51a6020d7bc9db400b8a085271fe24c63400fe20f27bcf33b83a96de23f6ebd8c06f07f448e2507cc0ede936e46ba4ea6e8f3a59a7c3b2c730afb6a4bacbe2e73000d726a8940f6844c109a2d825f4cd3297ee8a62d6c3361e30af117ea5a96e379381078660fe71fd91bd5e594114c0aadc3ba479df48357f3f6194f88cad86779e02406ab771f23a87a281d7f45174a41c40cf07d5809848ee4ee3de9666513ee407d6d4ac01dfba1b8cd0f66ca2c9c4f96dbcc962982060034989c28d1d07d8b093ee870b424078b6cb562e93920c5e2a4e308d14c54ae4f61bed34edbf27c6d56f7ca34e2eed65318970df7a417ff22d2e393ad75d120db3ea5c54cd2686f14651995e461903bd0b0500175cebe7e33c664bee5b813fba5d899eca6351c5f2c0ebf3aeecb166ed717df76217b7e598d97e2be2756b9de8ce9ff758fd72b4ab169674f12f9064606d5583e0e952f06ae665a56044e7d4e4af0b2b57254c9972a6641e766ac3fd116bdea9206787627bdfddb1dd78a6d770d966eb3c57d3b5e925e7f7ffb684c518601d634fe5475b413fd4d7de16f7a7f2d2fca897ad487cbc82f16921d5f802875d67dd7275f7a73addbc07a6b9f7d832bb853fb2e1d11536762313f2c7001df643b628db596b4a4866a9534c8929f3f92d2c37ed8f43baa339d05139c5c00b71772c2af47b8eceb2227c3b6be0bee3f40811ec2631db21a1541ec6886890e268a7057ea19c5651d61d378c413200f80eac650ed1f7210bfd04bd91a1e95cd716647254774bcf5224ec7229de75a0458f8a3d0710796635a3501af991a5e95b7eee7e1cfd6d1d319e9f490ee3db006ebb83f40b0644dc7c675114e267421717f7eab0363368e76cb1c7a368d646b071b3032f17d6c3f7a034db92e43722cfeec5e473d8aa48b3820eb922349b056b16c3168f458ee0ab1be694ec3e930e6766afd1a3b3bf9d649890d555d62d3a2897bed5c453565180be87af5ae2aca9a8b90541590e4d23401ab340f8280a98ce78439d21aa203af348e0a2bcde7aea3b1e09091ba7ca2086bd27bfe60e8a71fe58d80514d0ac938b1b28fe617846a729ead5d8647d03fa66c8c6dc1fa1599907bcf60f585679027e8436e2a0a2530ca22abc993c0ce2ee6f1b6f2af9ad2f8c0835e377ae0b7ffc508190c10953b3b4eb5c73e0971f640dbdd13955d6067a3d214654f38af294016fdf50c7e6cd597f6da88e5ffc86e30a34698818398a364c7a8e9bbd130c80f63b1eb1fda646ddd8b6c85528e5f31cd592ee15590ea6a4063400b647e7ed894fde67a0dcda3c9a44e457f5d2f01aaa3411a1217c310f76a606c6031f82245313fe1a0453a1783282c1f5dc273abe55d700d1a904e76017fe62e5b65efa6990581e1ece3686e394f2cf3fe2e8a533810fdced67091d93c0a4dbbb5e1a7c083bef4ba674726fc442f8fc9616c1dbe3c0587ab17f06d73128f3bc5d9b045a7526fc6b65867a2eea3fa31d8088de2727fdc29ed91a4e398ef5e6fd4f4d3122133fcf4e3f8e5a43540edce9bef64196360e425e746414e34017875c1350e3f1778501714ee79ef7f7916b7ba7ffe14137dbb8663cfdc3dd46a9ef337f06229cb591f6481dc24f89be9bb3b9911c469c8669dc92f487ddd17c0c180be3c17864f2cbb736ed7370c12ced32d59ffdd0054f58c89bf0af9c067875a256eab39ff2802557c598064e8bb97de6ebb12c36feba41ed6c8068c720b2f91d73edbfbd023ca7690d712e7b7cf18f67bb2c581eb4d598169f8607425095d314e19c2c73005718cf51822f207f1f8c959dc5d1ba27995e8db560d4341b90e95ef89977e7f64af0a3a7a4be0e94909f9c07e9c792217aece3c3606789e479e8018404eecdf21bb3d3f76950374595079bc31aef95a900e0b0561e1970acc7b2c4e42c23bd1b08df051d587dbc40f8cf0db18b1f078274f40fcb00e354c12b4c372bd685a6de8d3113cf578626bc5a7473278dbc59df05f8a3a2bf9197e989147d70a9a07d2950e54eaa78f86a379cf854188849d77d440a4075c580a57337b540df97f8301d031873ba2d6cb27e1ace1e5a4407ac7ce1c3db8751f253134fbda9cf6bd53d06f809e98d8f78a8f6d3733bbbac062a5f0e205fc6251427dae229debe742bf9e2bae9451a1e9ac55d39101416f7771eef4d1d9702b01bc4a967df541026d8e4c40d4205b565eec3c429a7b7f93f53458754f117b7acde8227da97a4e156f35d50732f04b1d036ec7be057bc7ffeb9bb1c98d7ccd02800a04a5456f16b118b8abba112dc287d914dec5a99c689a4758ab9925dd1b2446cd28a03cfe5c93d6c211d91191f716226218e2b0d992d7d10d212598340d2918b6ff5ef59f194e517ac5175b279d11e633b7b7ac924d04c234f162b5f3157eeb5ae0dd35d731c08f42db1893a2c24f6d4f6a9b57fd4441e4564d1046403295da53265a34ab9f61fbe59e24dfeacd85da6b563a680f807f8930649acfb733a8f577b67f639182b6b995632966fce3df8a1adde637fa6a5e3106124b5febd2e19201d063113e35ad43b0a12b85d7628e5b092d4df9002b8f2abeb0083ed82dc8b60f9d98f9cd0cef0f321e627ec1ca048f23d13906a7c751eccb44bbceb33db64d6e5b17dbefa69aa5f75c6cd6655f7a76031dde7a944ba84619fc38dc8c61d5092024380e62c82e21727f80d9808ce83a10aff57743af37268953309e0d47dbcc12954998575c0d4a0c37f59a25159d2967b33bdcf5a88e92b9ecafe4f0984ad653d853d7e20b5ee499be2ceec2e7b67a085bd55bd93a42bfc96fb59b4cf913216c17177724305ece034ff442c589b8c44a2b252005c90a16fb6d9f4aadd586bb2a97dc3c38468febba6899b8502a97d8d77ac968caf7c7a969c61ecded22afe3108c0deb7ba384c8194aeec89e0d06026beaae3163636e1d606f5f896a93930d6d431540681334bdda7d02db9efd44eb5c421c0708440985474e34852362cb329e4ff7482baa9f29f7cd109302ac9c36cdca93d4351c55b6414631ba5f8570ecd351b9a25a38fc2b406ba3c208dcfd17c1b9b6eb5b974ba643c845b379a5b6c1e5074b72bc80c9a38d22a9bca6cd5480b252c8653893dfe5999812b3cd64d0f0d8e8f85175bff497ae31f1100fe844625741d4655c4e97a14071a857e555fc9d5805e2c1f60cf039b0241ef36b54144a9b8979f1d61d439ae80984f62aefc2edaa8bb77ac9af4d1f579295c31bd32bd69afd6bec563ad3668e55a9c3cfb7fe109a6d28d38807efdfd82f4801eec2faeb05f1e775247044a1066883b4bd20d133cf2934b51871be2b16f49efe7f6619365feb7cd441c0be9c1d8609f1d31002dacd4f924de612b30c95f064f42f19978273e9a134e5c4439482cb2e81bc4bdf0b613039eea1566ebc3e0f3bcb6c9c4d05ed578997c69916afe270f99c0610a8a640fffa84dbc399b5a4d8cb5d50bc1086dab378ec8eaa942b5ab2de55ce46c2490a7248969a5b570514b7c32f1d83ec8f9fec0a66527c9524f0bd43f87a2167cde8c28931326e7b127628fba74724378f686cce8f526640c63130e0600115d75f5ed1542113c5f4dbec02d841381bfb70245544e841f1f8c1461dd210ecf05b179c5ea8bd47a75663f98dd589baf8043b9fc3a92fd410ab4c9d5a5c3fa1f80e85c384fd96240c2f7d584469730a00946795017f9e3aa19a19055ca2a840fa63dcae730b7fe587a1b52982b8a3e5e8770cee0ac80f64875f998c68252ec599dbc6598b411cf1df16c45b821f6239e2b3194ae17aec522ebf9b74280617bafbf74fa5d88377dc8863982d8be190fc43fbba0959749bd6ee359b0fe9fdca3cbcaf42ff400a1a102926cf8ee02a5b4d78c26b580d63b81e282cc9ae27155d8562dc1a7292a740ee78a20b2d88d054f8f881beba594bee64a4acaebce50b4aabbbb1c76317327c69765a0dc2410917d211309c2452f8d88d65e91edc15b22a00d1370739aba9669285f361124e1f73834a0abaadb9fbc67026a8f653896385d8296a2a025b423a39a602d6bf82bc74129d4a5160c138722cc61dd64207989da67f53dcf5dda3859362741ee96d60a30eeec0c3d599b325992a170b39b4fc62b09bc664899888a28fb85fcce652eb7ad4a503a15b567ed90d2c7fb1296798ed347b58a137f9973b945b760e8e5dd057088d38a899546579b331c1614f17351001881c8a8f25f0bc3ab3d9166914aeaee352a223c03ac772ac879d898896412a28a9e577e4a3c950bc9038cbce3dc0e154c7dc1163dfabfb597b12cdb62d5edf729645343e0a96d138de72b19dae08e936eb8f37283911d59db91545aacb414f5bc6997b87999b515bb4d58f6adc706f313d593aaef6193e8c435eeee19b4a6a8d1d8459cdc88040dd81b916e6e7ca7c514dbeb8afe9967d3601289a7c83df7fd92861f10956c4ed08935b402c9a42e1570080de2c4d9c26150a5792bf883c604acdcd5577a59f455efad78b3407534910cea9bc90d7514153fe6a54eac6b60c14466be9ee1ec6e23f05bcc63c7bdaecdaa2e71fe7880a5778ce5372e8ca3cc57bee92a9f888e5bbd978d0b383a0ad03042b5cd794bcf7bd8105b0692c35daaec209ef95059675a4df5ee6205aab25ebbff36160d1610721a105969ecd9f6cd648de1ff5089735dfd52c2ab02b7bb7d1568f9190ff75527a82374119d51a6369d53642daeaf07f2bc96fbb972bdb2f930cb5e852bb4713c5d23eaa987c0806fcc9980a68cbec9b8a063433eadfcba4f0a33f22accc546d38e5235b4957836e46493141ab779528e87608b08c353b0c40a51267737c3474e6799a44068cb4034cef7597a4b469be9c19b11c19101c97f31c61134efa3af0e8f4a1fe57ccc3c2ef90a5cda119f672dc362d818686ba8c8c6987a23248b3e2235cf4daeebb515e5669aac85261cdb7b6b18043da7d0ea8a8f743ac19f82180de4fd8917f0252c3051f796d6a78de943230e5791aafafe2d306708673bac9cf0b9a8ab9a91203d93868a1e5cfc2427af80a7918b57b2e71ddb5d599fb797b0e229b87bd4da653e4c7dae483aef6f47cbe76bf10a0a196c424ec290e46e5c05fde6cfc4918968712d2f6484c5bc5f69a7ab6ebe9c806468202bf20ed1c539afeb070d7dea884f2975db933e15e5f17fb16f67091e3efbdb2938cc6ee858b4c30593806cd6349c9718c6d82c12699f3569c4699da7db903ab45c8c1513c90276598aab289755d9addd044c7398a37a5dfc0d8730afabb086312815308ffbb0059edbdecef498eece2b04818c2cb9ff8ef4e2f6662454d5e596b8c79e5444acfd4745df6e6533184b1a85966cd5d9563f02b9fb2794ead9d9d90ab539155df76256f3f4a580e87d9fa92df082632edb76b0ff4bcc6e082484305eec1b26d2a6f950c234a91cdfc3142ace99f17c3ca562f96ee15e172c6ac5832e0ade354a5aba5df0f15ac8dcad0455c06cef13863cac287a0896b3a85bd4306ddee83c2629b814de2ee170329609431c25e258d01332b1993147b16c5df6d7d28c1d2e79257019b7ae378369f43a765889db89cb6baa15c287b4c0abde7c1862bc3f0b29c490da579e300ae147e3b546212ea99e4675cb314c298e2ea5ff3126c29deee4778ccd2124de822a1ab25b42e683549e9b8d02b3fabe2dbe7bfc1a351f3aa6804ccb296f116139adb1a6d4210d53b31246dd884b654529c811ec6649e2ef9108ac0936166ad5e990d587b1de398d1b90e9ad17e1fcfd8cf59a3314f579db55981c27877a057bd1e4e4d999498a0a7e6c9d5466cafde42ed62b218f9955e9223d4a572c080d0032af9db776a184128ba06efcc6e20231707b9b4774c2f8ebb97263d80df27b6efbd40f67414fdbefd1e6101d6d4d8733e13f2c38bdd7bfd4ccc7179b0c5b56b302d71762140eef96ecdf0934223fd454fc3629620c687a36839b2979c593fed37aa29a6ec4c9c388ef56afab14c4df86946a7b4eb109b0b3720595753d83052e2bfbc865823f628af12af3a1d7181e050f52b12c2dd8fc066eb244f3cfd9bd9b3a968eb8f192daac299b0e5a23971e0d31d924ff88d2b6d935a32eeddf2238c32282ef01ee8587d029083f89948b880c3797f0beef4ba2051bb9bdd8e3b79caa6cef726a8df1be5ad6113671c3bc0108addc3ae14316c9a893b99b2e5e608d94299f96cf7d3fbad434bbfb11515d46d05d44e635cbaf5aa9d3e8352ce975f6276ce527f8c259dfa0f4bc3145e6d1525cba93a02df09e46d4a4fc73100b4d02ee4d71391a2389e6bc9434feb7aef9a88331c7741f340bea16fb37aeff8a8b9d36fb26e2003acb50f619f69da7d136d24f3219ff00f2d4566525842f5a5eeb7567b69c4123e1b82dfc0609c1e65a8c0de77c12e4d25ca429ceb038361d774c0807df1565b0128e91726efe450155fd1474580ccd362080ace098094eefe33a93711206b069d03434eed2352795c1c0bb3ca8d94632bafddeb8be43c1e72ef9d6a13ba57d21f2ff6f4452017443ffb9ef3f716f8867a72aa3ed9a25b73dda15df620b3155725733931c4d71bfd20a4a67939257c8b9f7a761fc9214752864e40cd735ffecc8b3cf5bf390b787b40cb1d0cd03727ccea4b16b06ed3688deb25eca8cc77319b1390b7a05c87444a82d0c1f3bff0a6f67603cf19302c978cd7664b4ea1b4759638a68cd211e9fae44305aaeac06f3e4155510856958e0abfd9e4866488c4711376e0bcf072090f143ef6d2dce4db61474bb25b3bdcfca59fb7d6f068cb1b8c7ebadd1bfe9b4a45016e85feb35203970bcecbd9d4764c4aac43cb8d7d8cc901a384d3f0e46e487567802cd3f3d0e1d587a2d340b2376b9debe715fbe572a39b7de3526ae0faa1686ef6f4b0a182c3e1c3129a72f0fa5ae63e8112aa1f7dae22e7128e93dc2b95e33fd12c56462c62334ef0f66802aaffe03c1e41cf256d0fedeaf4c3fc0e54320a8ad492f678f1c5edad151dadfc43c4fd078cae26afd24d8f4e07eece54b6a0f6c44d8d423d29b3c50423250706becc8eaa1b4099419285990b94e2ad5899d883d02795d855a9217c36ebe2ac360b7b6d086250546732a01c18d737145e1cbeed5a02aa3d737b33336da3458ab6f9cc090c5b6b0e2c636f16093061748af9d95e7881f8cb3fddb5cedb9ebc9625da31fcedbf10ac6ec2efaac6dd954befdfa1b1fac050587c61de497065a2e57d444fd30afdc8e8cb4bb9c414f8b116c8b6caf80e2025998116165becae59586cdd14df4124a4db5e59f5c779e29b74f876c5957843892315e95650a4dea0c9015c6cb908bf840e66572486fdb3ac9db3683e6d72b226c8070d4df6a584d8e54fac656a2c39056af2a180234e62bdd883c078ab12ec4e6c045319d29ac568ce50249d891ddeef957cb2d351db1ea296538002f96dee651d069806e8c4b29c7a896d1f3320b9e7d749d1990eace981ca7d0f04235d4d97e7ab9dd7a1e4bd310e4edaa0ec62003f47c2fb581fd572bfeccee4cdda2dd0bb01bb41ef3c719b9fa6ee60111fb17678d3586d1c7b36816d91985d04e5ab98b90ed58ec087a61fc9100ffc4d25fd6db5966943d29f869935040001d9e1e723d79fb337d6ef2ccc9734b1774768139c721ac82a386a2c5449f5091f0bca5d8c8a48b4c898623da9d83e6d9578b9050146dd71e17791cebe321340b7bfd723f243797fa8f98c42951399ddeba0a298f2c9215b8a4f313c8115f49a04088b8ea43c3c200e4df0be40f531e00efc1c7bb47d7a1f4a9ef75e4e6a4d7f42a182c97ba1c5b8d26cfb43ff6146420ba1c4ec4519feb9a7fe11172e59e56c1bdb78da2716123905b2864d138d56dbcd2b9083e1ee418eafb0464b9cb6b9d3783b6583978fdbb88133d9c8db3ba599c209f5a36403229da474ca782a93996563ae1ebc91f376ce1a20e05427414983a5065c50a0b436bf938da1e45e5c354a6b18031d9fd69808916fd86e9762161d0dba3039229d50db85d01fed3a2d32a1ed9ea092e4b8eda6d488a47faa7b3e8d6520ebcf5223159254c8ac75b5183073abec80d07e7dd0793701789bd9f8a9611f47df1026ca4500c18c59887c87c06b97c3a8481c6ef590a45411b46d532698cdd51f22a0006bf3e7352b26e711ec346daf18d0ac06bbad49eae14f344d2a35a671f2a3a9d9dd77a0a45ca5a35ab337aab95a2989b3e612f297eb5605e37cbfb7493284b5e83aabd4cd903b5fa86314eda45854182f5069f8ae16b0c1e4129115b4a5d1db405aab8436e63acb049ca1cbcb79acdbb356a8a592ff60db9952211af4419269752a6ca2d8811e7e9f5445088e33541af8147197f8ea91e976605b887448104b172d60db80f6c882685b82f9ed5901d329e95cfa1ab2dbc1c955cb55362f96eb39cafbfcc1647dff6f97c6e36508b29a98346c2037627e8b23742260a90239058733daf1811fc645ab1c9a38c1759da16a907c120326df64eca8bc2a0eccb62a765701129cafba41b72b9b77beeb1fb7297899b8ae881a5d63ff056bc89e003da5c1b1af498d07054fe953b700422122f2c8b21b20a50c16a65cdd614eceb0007b9b835f50a9cd9e0de9203550afc3abe8263fa1f3ca2a9d85f0f40af8523c5c17760f1e01c50b0d5981d39ed55c1893b4a1fbb4b4e8e976cb6e36a88a320f7fd28aef6bab653c3f803f90ff8670caad9a1665d8ddc0ccd453d45a2b2aa1f2d8cbd0da5bc62f02d5d72bacf266be9bb031feaced4ac07722976e9226e8dda1f81bd82541f19187ad8144197c3b9732ec3ef9d93d676915fe790d39f6dd12402ba0881aa36c1452a9bcbf3835602e29a66a1a3da4863d4d917fbee1fbbec98e457bff82f5999c02bc9df509303d00f9af3d6b3338f46095b828112abb4eee858835799d48011a5129a45ad099bac710d7cb38457aa51ad37a2788e1575e7763a5600fa99c4b74ec4ec176d1f9503cdab35bcc84c2bdd0a14df04bbdf0b0bbdb159d6809f234b9ad2579c230ff690ab3464aca75c5694b36f881912762f97e021533c01ec04caf1c096cc265cc8f11851150010c27d00e093bca9cb4edde34efac2675b68e536e76f0a90adf6c4ec10dd0e43db03a9e0b5eee2497c7878605993ba9546b0e4da6e8c6dde0f442b4e8571df2d7456e07fbc5e428dfe67ef9326d47e17bc652fdd07ca944945f53df487a493ceaf40e1136046119d3c6eaa729570524c9344550454eed8401bd0dcb9d8f682a799d80843e8a3546e246d616d9296d2e6c5b31db0699bf998bffc3059bbc48d4e6bf1d248adc537873ae5141867f761a4e198d506950bf16eefa2f79fa69856b7edacf7d3c488dfce368273bb0302c726b8dacd94a260b0d20fb8b640dfbd6b1030ab826bf26e6f3a26ca1d427360ad3a381b3466d9b56e96f0f6d653569911e661807de93af3c9bca2b59ad26cfdf006a96685e0c29496395864d5dbc0a13de520f205c1fa0ef21b19d475743032ed036001f4ca601b5b8182e247d20e069226818c14d4344872c16ad720826ce87bef37f44558d5420b00b8c4c0ec0c37ef59c1d01baa916b5931d4bd73886ddef086723358f492559c10bd61b567877c46c451a2355c32553eaeb28c4587cd8eb8cbe3d18013101a95280bb20f904d01a35775720f56a9af53830dc1568f3bfdf53cf8e65072b555e8045a0c8b129717565670caa0c129e8b3f5fdbf925b08be5c783208f44cd992d4e54b00d65b82da2b5f411a06dd0c015345bf84f8d02b8dfc9fdfba4b25744354bf194e97f458a4677b8f102646a769a585309da48df81e49971830c7797b6de031ce05762886136dcd50613efe9626d40119cf83e16490148a746de392d021f5613f471bb397a3db91327e8ded7232887008197ca31de59e3a3d6bcfe0b54c73cd2b25b9e655cbf3750d7050de7dd91b795366165490736593746d8012e918c5383b24454f035a4ad45563db15495f3a282d4f89d0c020ee407b1567bd176247615e5c6c488378fd0016b321ed67e9f82545da758e82a61ebe55adeb1cf1bbace79875398805a2ed47b402953da8311af0e9e8556a7be3f5d424876fd9fdf49ea35916429b4fd1b601169f4b67d79222485220a819344bc5ba629c39af8a5ed657648c719e1fd9f42634e31e0a7b9e3e4ddfd8efb5aa59395b330e0cb5f385321441bfa1d910f5df4f5cc04f6e6b9993ba9555a112448e722983c300f1564b5c0d2910d50c94d84a0db85b7d443ee5e58be2a290ca0e298dbd5c6c9a68daced0355563c0f387d9c999ab1d19c85af26c32a773f6862976bdf5c54b069c5c7fcb94141b495d30385ae75a3b751b08fb407f02434e669842640e9c827cd910edb7fb7ead12bb71458509c8ec1811cab1dcf2e512ffc3d8e819dbd70baa50b8b1476023eda9e1d5e0cad5b0ae0c7fe8b8b10339a0575576dd02a38d71a9ddc43352fa2f4f873499c421d2faa594a825c583c051049d98f7dc65a42d9522db9bec054bdf556cb56e2bd37b35d00c406583fcacea60cae09b5b9875fcecaf25817ae594d69c16419c5ec448813668a04a8bf4e652f9ad75b0811f0165a24e105f48be973984f3899f0bf74b13bf72b3d42d4fab8f7858cfe6d3195d4c840ba9c7336bcc120f9c08eb7885bedb76747b78f9cadf1504f1de2ec92b93d7cc48dd01497d6cff71aa3d464b96994463d5ead96349284b1dac4dc3a6524f24158c07d0b3b681f8b6467b4526fbe18a9f0398f00037a3ed7b2869ac67a41d5aba60f742cb6a7f550408beb2a4aee48b187ca377df2e7f9d6191db95150c988fb21c42e2546d9b9ccb7c4cca4bd76298b21f1366160589d0722bb84f9b8ab521289f9456290a9442de3fd5b4632ca67627d17cdfff423c6e49bcbc0a2cb09106d096f71325ffb1a32fb7cb5d7c129dee783899086afff25fc49233d2a4342bea385da4dcf1c4dc93762b3e9f2fc75a0d6f0e3b1a26be09d6afe756677fd5450a4cb534db45c68f49d17eafde3e698d1b6ad4a572fa0d41441e4be5910c69436148c1a46ea3824a103939d66ce8955f799f6cc1c072ac8afb7c6d9cf5574321e0b1c365e4044f4e062ed21c188b4a4cc96c742a0649c4f1f6d80e83a7820505cf9c6f85d8964cdbd6fb7d4669d9c0e98147b4a2592e323b510e066bbf43834b88c387b3248e572acde09d4b6d3d3475c14fc363bdffb62a6f21d528c341ca8e4a1c4fe53c4f2177da6e7e06913917e46256f8431d3e8acbdc6d0dfe86196056fad950a230d638e08d8f80fedc8931ccdab58cd083797becbb0287cc224dbcb5eb7fea207da58ba943727d68b0d483f1e896c1f6b6f62f46ec822d78bf72433a726721069a183036a8f4ea82e84fe8e9a4a7c4e30223763e2d2e97cbc8ce96a9265c607c94f5ffa08d4f2a7c81bfa26c168c75b2212328f92c484f18e781a5fd2a698be031d4126863c1a9e89e5e9975e7c53de9659a0ced715435a169b683283f83f9ca68c797ba2e0083b651ddde7fa9293efd388b5f212464cc52c07a5b9787919062e9484668ef533ee73a875b38126e96d27fdccfb06d500f72565582792d24b98ddc12511f647a222262ef81f191399c1304a2dd496b502ba9497f9b223e3a1a0f5fa1f755c42a77b8da24b2056128b8095c044941131044c915268042d3516f2f6ec4cb303bf7426b7b57b4aaacbb708bcc98990b685a5ea0187c0b5926fa04b1a1db3df6588d3c980af5466def3a562a85be5b31944bba4ed431e7b416381a08193eae030b733535569be852c30d8ee38e521335bf7b0c2b4eb7855eeabc6b3bd65a7f96d6a1db0045e2709f626dda51dd97aec9843c3a2a81b2381f91bbc79ca268803f6c059fdcf6c5b7db885b29778123f8477f8f78e9222930c8f2e5f310fb1afbc5bd858e70ff2b71fe7680c3e5e5e981755709f7039d432ff2b501e9172c0d45fde4d585c3868c84e3843f7ed6f149cbbe9c751ac642f9d93a78c7ad26fd4ec95d3539704b3e8d4638d2751ebac7bd42f0ee73265009a3453cd586c6c7ba0e8375b78ab71f1b61481dc8a1e082f0d5a221e7252221a0cddc1fff06246a55b1775ec5ae89919bee723c1cac1af3e43a54124cd2ab5f11a5b7fc259b3ce86235df6a9fe3477fba54311285577f458b86dd06050672ff5fd614d91492860dded85b4b913174470d0a63a50382c18de6efe06a9f9bb4f8766089f3d4bf539005c0795fba9e0be0fdced0f0a27a82f14f12921578f1cd1b2dc2fae439941bd51a128d433869b7ddcc0bc6b0403845805d2ff3ae33ca3c789f9702c597fe1b2b5e2a60fe8c1f17b788be2fb5aff9802c341f5f4f6d75fceecc73e1d687f843c1aedf6163d696a7c99477547f10a889426a7cf1d8b1f567a5658d08d1d114fe6da46fd313040ff872bbdcc0854e74a814c757ab7e792bde78032c9b4209c5a26c65663657c1014b3dcdc238e8ad45ead17a7df0721406f8f263e2c0a8daa71aab55a4280467efda774843eb5e2a06fed92bbc3b003aede01ff51d2fda9437ee5c4727bcfce551dbbc1db40cc8a10e74637f94bb59021ed5e1ad699c8f20a9227554be0ede563d73a62dc9a1fc304540a96994e7ed5a674914d87bfe9522e0247cc2dc2f1331655feeffbdf4665faaa111244bf1ff56875c2e644b767386c7eb3cf9c9834f2a862ba8b40004ef1f16cdefd83dac15e5812ca4787c8a48693f1796b883556cbeaaa04469e461ca4ea8b5e0d81e452b973d050a30a35ba604532963af57fd9e89ed1cfee8a0d91f8d0895f88256f8293550decc8d152d6cdd49f81b71c489ee3616e8d0a2bda950194ebe89f9efc2ce65f51a4292c38b52b393086e30b77774dfeb3447b47bf50e04dc44fbf4e870b75dbd4fec2e0f9fef77162ead11165e65bf4445029fd9c263cda63c2573d98ea587b98ac28ba67d65e9b0666a5c440f85618b87ddbd099e3ea79a61f49b47f1cbe98d98987b590406ff338c6a9868042bb5b96eddf18d4945a8744139fe7bf2566d337a516b30e6da042dfbbbaf39ac3b58bf7070a6492a0138f5c88cf3bdafbdf326dddf7072b5f543248ff638037e713fb6bab4535430cd8845f2964396363d056eb938b0df2b37fa2fb82e8bf47343ef1dec0a9bd1d70b96c3bda4e211e243ba4b08991378037b46bff5ca7395ea48cef3573ae56c7810270644dda90991df7fae07b63b914f294f4ac63a9d1438839b86a503a4f791cb9ac486072055b4f00f537f22e22460a78387243b194e6d196b1e16182ad3b6b2b6786c4485f27b1676a03bf5f47fc278b3b36f2b1099ac7c5c5255d4d1d55b2f70bf596b0313f1bec028ac909165f4f41b21aab011bd79a2c01fdde9c4e76e9a1b08cb625e49d24de57e07ae91b2a6668afc01ab06d76d8af2342c7eba57fd71acf49cf35814fc6adfa3157e650996aa809e6ef768d73b821fb3f3eec57576d9de8cfae48be3229a37c4e2051ad3f1801626a18a811680a8075f67475039aa8982cf2d93a200b9d870b4f8e434cb421b496352d504667e638dba1801d5bfacb187e63092044649a833a4a8fde4378410faedaab387f15a802c7799430c9678caf9f2dbf2c8d09dc16fae78f98914c823a3dee8d2af6aa1fabe625c96b8edef76513e408d0d17f0221ef9cf009c14b95c28474ee710ca0ac851338dccf2483d8585d491e828170adc3f744e67ec6d956103551382870ab28f26f3c407ba5538afa8c943c8ae1fd7406962ffe1a405a297d505416347256c77ebe4752c60a8fe17f8a8cf54cdabe3f06aa45e3da085fb02f8b6877b7924cda5abb7fb2b9c428979b202d5a98facfe6d611db9de1d52babc4cd713b42327c187f787783a25e18e256bc45df4740e71c232f0b6bb57a220560fcafb04a3521adccbdd94de57626944956fb505319386e0b683fb05ea8924baf8999d558e84279d6626671c0acccc9398cce61a219b125275b8104214a3a1ed82d5507d4b37d11b5f65aa0e62fc9469a34728d082959cf7365710632865a84ad86a3795de4cc5361ee74d9934f42af5e222827eefed3436c308e6fc2f93a0f07ddb0227e9c6ca2c4c93c668a8219301266c4cad3cfffbac851b0f2ea43475a970bc4afb5b18d51c3afa5306f3906901f7077aa87d255d66823e35a8dce6dfda82116967a4706797721d7b0b0483347c1f80c550a60952cacea26c49fa4eec78c435e944e158c84bb55bc48c0ebafeefa7d4087ae62bdc977f0d816e087f65bc24ab1102645e5563b41cc29bc12fda72d923b2c7d54c9ea4a2efbc5a5be1165dbc59e1c7a67c4e3e3f4058b056caf73ba34a87ac27f8ce2739dc094f42a8dbc5182d036501ed2ea6d04335d0017fb1e073fdaf686f277a410b2605572f410511e12fc71653dadc454bb242445a081c13c801bf94f75b7e323a7da631b8d8626addeac4831951560f140aa31282bc9c5dd125ca860694ac427f9b660d59894f450afcc13adf0b8471c81f67e4930dc8e32485c576a9745c5e9f5268bcf3599a3b6288f87cbb5570ccf45d6ede184d977d1b77790d705545021b8ddf4d72939862923e995200fe2a3f584571aa8f9fc632dea58a69ee8d8202187158e8f9b3d105771eeabffdf55fd931a88e67f4a9034d68c9b0e46f86bb772b0865656d17eaa63015de7c97ace0714461058865722729ff64a8914b1fe58f743da30ea04babd67e1139bb6731615d39774da1f193604bf00f3290eea0610923fc7ec41609dd9353ff904b0260cc48be9a9757c04b114e3b7fb920c32f1636b91c9363669da56aecc94a9f33f03a756b874217397634cbde0e3de381b67152d771533507f057279519610a97114c322003564d5f086ef0de09a76e6233c3b7a2dc62d2a0f4a0dd8386152602ac65237758f93e5c888ed30beb178985e19c01e621482b30c49c2ac19eebe59dc4faf77488457691b70f566f3c470ecd7e742aa51a2de8101ccdb69f9c1200dcbe7f2df52b37a1757ed4b9c3e47f4a997a61b50cacffaf2dc6ba64586a88d5374631904e3f4118e273119fd9682b7f5d91932de39b529e1b34d0f83a097d11159d8aeda39b3ea72aea447a5b9d76340661c4ef04a71bbe0276cd0d73300377888c7424822b26ced8d1570dfe6a894843f024537f39ff41f41f68d91b6241ef3390a57b00ef9db68d77bfec341e053d99786c1de6452c96400fa444053b9121ccef108ae2af72236074df4c514f68d0338c5720c461cb81dd136aeeea46fda046902d866b6342424f70516e41066935ecce28221a7415785db00f9ab015d9d5e69f2680996e814fa211d0b8720b12df45ce26d8085f612990da7fdda7d3e406b402203cdded5de7cd8cdafc97d035b18a13156c70dc6cff83a252d33d7f6c305b47c9508ac16de8b85ba918ef2470b1bf8fe8d7c3950b190e234e42051c2af99c3a48398f343e545455fee45e19ee3f9b1823313dc2750f81c6b4aac4c5e78d783f7723565d52f994445527278f90bc592c78dbb260b1f529e3f3367bca6e21391b219ea3d48c09531e746ab0586a5ade1995225153751f6aef73d747045bf2271b2c343eaf4c461b687a6420c30a8d05dac6f904b67d09e1dfe5c5c02f8ed1283c551085616e096c3f58921af339c29c6a21d3b0991a2939b28d137e865f4fd20afbef6926e6d38068cbe706cc2e4b35aaa2d86b3e1a4be1e5e0a77399e6f76af930236de69b2a79ef78b721d77df9f83e64257a18e49dcb6ca8e332d0178e69ba2eb8ab07347c651a858561e7e0e661329ea5c53ade733677a7beb25829a9eae356a9502b2c6b108f254cbe5f59951595926dd78fb6e8c413b9171f555ad25ea3efbb34e33e822ca5f8344ae4f6475cb1e4590775ac1d6d9a632ab8f9c100b1bfb5124cb8cebd9da49badd1d8ad80282d26e29f1881b7b8ce284d6b8dc3035a86f06f00dda7782b3f4ad1aced5e2073e24f72a5befe8cf0e26a116e05010ed374cf36567882ec6ef60ab76b2cc155d13e4ac61169b73c51a8e9e213b2fa95bbe4960fcfc62fdc418c39e8d2c3ba763dda6e753b04fb242df2c2bef0fbaacf158662daa08dca4dffcd1557694f2051003d2ab865fcbf15342b77fd20bdfb7ec6f13adbda92f9d64f1d5e065f1477edaf1ee7830d1bb19c21c1ad4243f50341f01bb447d73ff9f6c22c19351120f26925030480b98970308dd7022973f4c4dcf7020b5556c553a4960ca1615fb759ba458a3c20c2e4d91c4d3a78ea42fcea2026e830f1959cf91d3162594291037fcc5823232299456f2bc611efa1709e8b9210b05036e77f42babb5b85c9954963f5d4e19abacb18088861ab4844db4b1832118fc153189e9c0905430ff671a1eea9a6b0ed251b88d70fc66ba3d3f8fd0c7353761381b955b8be986d93217409515c4fb29472127d32604505f6070e058d6a4635b62b7ae315e7003292970014f4fbcc70f7b0a79e524b568c69110ef7f43ed72b2c3ded15dab70571831702d7b0c939aed2306d518902d9dc17de2c32e8355b1ef090769fe409af1b26d8be2bbf07c7b4d3d877e92187dddd9ce6a039627307acef1cdc82a1fb325d6a0e9e96e995ae0d12e93be48e07b90f96688e182091a0ea008a08524d5b4a9881124cfb4401bd63eb3a970564db54d51019752dc4844298cf2f38e9b5e84894ea665291dbeafe735bf6dca82502ca141d9eec7ed6b4d538f26f5c60de9b95dfee7415cc25b71110773125169b4e2adcf1e9ce3d6a3af5d9791408c4b1b4660192fc4357c741ef20f4656aa10a097f8a2e608b89ea39a7b2ea5e322d5fca5a815d37129cfb1f6b28824d63a0322c3090e791891ebe395a0feb5b4163ea8eb0efe26a76286a755591b3404d28ce3bda3a77391d1a6ff104edab34c46bf2d84e568db0d2213521d820f296d702011732f16f3668c69978618eb4d4ddbf3660413be87fc516b24e69a51cc6036f8ecfb1e9544840bec38707201739c00ff7e473e7f4651d18d4bd860405525531d48c865bfad888762b3272f43b5d356ba5efb56f5813b290f8cb5bcfcbe3a4bf56a83d89fcc5a82ddd78b12db221f58039ef9318e23964550c1352117f4603c427f6f0d5fe5d85c311b40fe81c22de9f481c72afafcdc61ab09fef52a54fcd677bd2e44e204dd4db9b6fd8a3980e366f0c46bcf32c5259d996dec11ce2e1755959f5761f2893a91ce281e30f6a07b353ebe5b1595bc213808890f080430fd365955d9ce7f732e94a85f007504cfbfa844d85e75a4b120424d413aa9f99802d6bc70947113010f01b837a9180e1baddb11c94db8cd6fa370620cf99b72fe8451fa4008da122a7a52905ab8c33f8065cb02bb7e92ed18da7dd2ebd250a09e13777cd3f3af92c92b672a3e5489d10da48daae340346163c6a0f27edd8adf57021254edc8188872db95f60ea38c65bc0c2b78539e200aeda66919816e99a747628e306c1da2cb7f4c5cb555ffb2e83bf0d988b281c6796f5db6db6a05179194bb203dd048c542a99a2cb374f956dc4fae9b04ce3aa07eea94c2db564c841266c604309f54d6ea30607e48908b51a1676d9e0819c76a287dca3306af1f576db00df5716e6450f73b2456f6460d4c10cd20eaf093790a3d55dd5dbaf9432135aba5738443777e699d807ae2092677a79241f4b8ce92620038464cc16947b4465d6e7eebc16c25ec10642306cf8f91049b76e43bb6ecb05896589f98d453d993d4a7a27882a1cd774cb5ebb26f68d90ddcaf285f5bd1441f1c7c4323fde334ff89d32196a1e727b89c0d1e209d4779d885da663f4571cddb473aaa987dead8946b9b61eaef5c1e71f8c4d09ab7a8fe04883a5b7185f106e0e8c2363bb835c76c1bb7a0e4db421fd4005e4dd6ff91295a8ea336f93339efd9907f7ef74d6a94a4ed5e6044f0be350e0197a47f8c9b5b5c9d9d25f97363c37d508d12be744a5205fca2b44f28a7d317d4ff183d0937146ea11461ff52d5a24f7ced9ccba8b165fe0f4fda862d649434776f1b6e9e258a12699771a0bf660d88d9446d4829b6e7ccfe8688a38c28bc63fe45617bc4084174a791edcb29da1a673727267fb0333a13520709e948180a0b650a5713c6f3a655df10204f752062746486aaba864bf17a6524ee719b5f2802a7915eada85eff444005ef16db7fe231ac8ab26271b16d78533c327e8aeecd5775aeb36eeb1388cfd005b7e5153c026e0862c51526c7188bf29228c65fcbfee2385ebaa5294858e0b160549da27d0806c95d94c6af222e9dfbc941e3e960dd3c2bc1d582c1b12ed817ba6c8fab29ced774311e37c27d9afea074af6ae55f1c5bb28c6b9e4904c03323b9db4a05c83927544ac68637bda87161bc5d9427ab5a90b3f9c49b1ac6fff56a87dc507c5e9d491527a81be9b527a7d80c15cc8545e7a88697c646ba7e111c5cfa3ba1c07dfcb28825d71bf625b7fa0dbd9dbb9f155733a576b0a85ba6902ccb913ba557ef60841ffa07b3f208bdf1a7db80b5e8f9b9ac1e4fd71b661d67e91704cbdee841a78697903f9ec9a7c01433993347de068720a107e0aa87f9af88231e44010c417eaf62a905788feb028106c6910bb49ccfab6db6ea28f49d5a949101ecf8cd8e0ae025ec231a4bbcc9c801485cb8044c31a082776ca6472d37f6b1f4886dc839133d533c0e065b1cb5d575d55c7c51080461784ea36302ac9e6e12a61079ab24bcb9e48078d0e1be2cbbdde4c220d8ed99ee7a76fe9e6eca34365e1efaf97868c3ca4807e64e6ae3ba37f35d52beda7f4b086205be78c45d2a08a325f72c76078611b7045976021e6ab0db8d7ab709da6f89550bca0319eaf66a7bdc242f771a69879680d9931257457152b641059e5c1aed8c108474a6a07d5cd2df5baed6a4eb29d1bab5671e53edea407e07190a1b8a71ffcc23c69df1a555864b072d9669fae363da8eff426cd0436b615e8af9ae54c079dc3f35018b76fd19baec457379ca689a12b0e624782ee950f7839d1a3df5afbcce010463a91d55d323c85ff0b0415341f7a334a7ff674f5c2d405192182b67a786964976e5e28b00065d6d7bcaf57b3b3c91181b7d2c820b2b60f756c42ccb3097b6ca20b0b68b325d6ba18d8e92ca93f65d749405450558fa28c1190b16f3d96ce64f26e45889e5202a706c489736c84ff1e3364c89e53a4ded62698cb3284f56b7aec81ddd1724b484e818ceff91b17deed68366e946da8508adc5555f73630d44847347150d477560183723f423bb96f5e593a8d7ad973baa5e40b13c1101f93baa31c7e491ebd64f8afe9143cea19281f5a77759ba470f74cc7d53ef1d2b2dec62fedbc9669a7731046ded14c6199d42e0559076ad598a61c5292ae25edf2d22ae62bd71e431110015ccd55fe9017ec6f80927e616dd519986bafab282ebc9b727daf0c6a0b68586b59a8cdc0b81b44789523866c936fec0c538228ac6fff00ed4f26086cdd3c59bbb637452ee0db82bdd5289f88f43d028ab609c1b4f8d276aad69107e57af9c55c281fe03e74dc6502a5b4c3c1bb7da0700dfbd17e1aa84e95137197ee9da6591b98ece0795d06431bdd6e204bec4fbcf674df0316d2eb1dbd71ec6173e7475abcb89f351dc729b8b5e257a36d33228e2d2ce1f6a19cd6bcf955ee3887e7a4b3b401e7a7a643a12bf57776aa270a6c63748c57d9767e47d44ad90e966cb8c4a1d29d7fdd520aa11dead9eeab075ba7db979f55e7dd3b98477a91204d91484845d7ef40880519dedbe4edda4f348c236722dad1a42c23288813c5c3f99877b1961f1f9c692eb81af5f8b7ce85088eca9e35f22545419199617eecbcac0438fa7fab2dd9cc876d93e293dc18f35f10f67e1b545278d0f21091b996e6f1605be838d60c064aea416b886aaa0f3b3a68c591f7ae8830e9ab3f4465cff7f24c548808e36032cbccf1fb29ed9612b680d8696c4224011e012590d58f13c01409f8ebe31e3ecbe65a20b2c7e1fdd58d25af4e2d147c897b78374b19d77661bdb2415cac06b077b2a460e5f584fe043ff70e46e5cce0211d8b5e06e976c7584688244ed2e6e9ca4006574b9eb98d43b4d6a7510e3c227fc3a875ef166601dbd3a880315f3eb650d4d8c434e842a80c128b7c75c1a0fe724ccd37a44c7cd508d8e3aab7b33c58df6d7207902c05f9d73fd2af1b8b15622a57bb175003c8e3ef8076a944bb0b0603ed259a736ccb9236a035a4352f5e61ae9874f51e34f32fcda9a7c31c19c5e977c4de63edbed561218ed4b4a44af4e8fc876b85872d395dbb56dfe019bf4ae7127e6e88992f2c074124f869d25ef7109398f5f674d8cf1e5cae61c80ff9b4488db0e28d49366a3b5f72dc36a3250b4971456b922e2eefa340b5305d0213c17ecac468c98351ab824fb20bcd9a83d8b166f558332bdda98e790cfaa8bd39022585ddcc6658e733cd16fd0cc0fa70277fa270a049796d66f2bc5f78a9fb827cdb72f5389f5a4d681384a3283c8ecd6fe18d7936fbc706783c279a11d128b7da8f1f8735b614774257daff9e83a36fb98ead7b45d379e1577ea34171e4f4b593cb1f11e1ff37a2f0da80f741d188cd550e0cfcb92509874c9612fcdec1d873e82a77ffc491e9148ad4e8e64564c802a90371622a6f50a3f942745b2cc27f6295e11bfe270839f8ce56f35e724f2d3ce179b122191bff2c880a44663872ea7ea44ec9e9ef2275881842380299b70749518697bf8fc0c9f99b194ed4d6cd769c1e675e7ea02e8b7a7f233a91cee4a5b5bd6b7c62a95c900bd30976d7ca2080da1c7576f6bb75b85856b15d02ab099650a01bb0332dc944be35fb1305dbf94e70133e4007e70e03f7fcf7079f4591a3ef3910494f362a5bab45fcc8b1cbd900e1bc6102beb3679783d37b30be76a597c9b3371291590b389087dfed4aa9bc001138448d48295754f06281faaac66bd80e9a9ffd8ff2860f84a5f15e37834ded3ce38600e4596f4a27650a3184cf64a0e5aa9f59b4cc0491f7dd3b698b6171d179cb42f2bdd932cc342e95b33ea782cfa8d1d2e568d7516aee8bdcb212b20e47908e419ab6243f956357f7f4c5e1ae75f35edf0391d887bfadd10bc1ee24e9c31c5d389ab0fc595cd64b1de192b9a192e4c3e7be3a6252c9477c29308fa7841587d1a5be42352ce74c66eef99dfdcbc64dcd893162c58a9ff0c0af3e1f1b9cd98cf4be6f4e92336b2fcd410ace62887ee65698cff5b688af0628158d5988e7b667d8a4dc20442570918c4f4916206b18c5f081328f324e8c02d90f0933d4d78e9a4eb3b83d224225c9530ae8883aadeb613963f6a083fecc4f1c5b942833c4b12556a46406e8ef8deac200dc25b4069d72f6b857735de1f10eae795c5b57c1aa91d91f15582b6066508243cf9349ed29358d999260983eccdf4bbbf71811f032dbcd5e9d24d8d66930aa058d01c16d99c13e96176618cc859e3f1b94487135f14524619b0856db70bb377b1da76883728da12b8dad206925bccb0f819df204b886b6bfa6f2b4309bfbae529dca746af4d3fc89ebe9520cf0f86af0a8e38a2567f0aa5a56b6170ceef557ab5f2b2f011aa7c2a1d9e0cc1aa9c54501e94f5b07998e61f7f6dc3d74fba875ca401a4346399b86802ccfbf5788d794657cd8c13b46acb11c517c38c3d3b35969a2498643b3eddcde77b301e2a1572618b373ad719e63cebb7ae31b6ff37bb9eca02543ffc97b1a8e9518d2b8c8f0f928c0e29c371121d902b2c88ef3fe9b3b9921725b26747724b536494dadda1d9a45f89842706f6d9fb95adf27dbc709864a9cc3fd66dbaaa9b7192e7b46bb93d85eca00840599cf80c743b5093f0a8fe88c961192d38c9f3644f12c62e9ca41a7d45bfe825b4e8f3444911176d6e89f0928e97d953e767d73700029fed0d334a6400a7943484bd35fd00043a9b778843ebe354c22888a884b24ef7442b364c19772b602b5b272fd5c3c2448a6e78f7b1cc3c9537f328f0251a306d021ebf318d61901b7f03f88a51087561073c64e15ef22a3f88ec852ec80e7077c1aeae2f90fd9affeff9d4042915d2d3cc0a48408923dd25a343c905c5903d860dd210c2f092ed9d12ecc44d97250ecd16c0228f3a98ec85ec387d88056896d575a64976e5c281dd49566f1c295f2932ecfdff807026f3f778f2077e580dec3d67e69d1bc8d54893b3e6918c4f4c058d00b5139f4a941f57e86b7cf47280ae9d11f033b0e6a1553b185132932424f72f4856314e65481d3c3f95a8ae5c3313d063a0947d8b171e040a95b07b16428700b0185d0ffaddbcff3f6deba3496152dd78d1fc46c6f363d54bb0aa311b1b759338c6299dc4ce45f9a893b0258db30a37d25666c5dc197bb421ff0d00e6171f26c9e441f35eb760811b1d70a9116fbf1831d2d1aab6f1855a8f85997d7d7097a2b3f91de2f6caeb5fbca7e1875779b39bfcb2e4a63a85c94a1b7e2f518f31a86a960e5ad5f9bde75bf0a01da054c0eee09c803f05dae44dc017255b00844f65c42d596c32bb9b8818184fdfef7fd7d2ea11988b63ccb0f9a32a2c89f94d227e1a9d7f19d1700e34eeec57fe3289ef1980a241f6025d2ef6a6a0d1554c8677ba2f62ee57afa526fc6739c70f60900d42f50c01020db36dfb6f8339c41b362ef9a1deb0df1d12aab3afc48bddb4a76dc009e4a3ed23089800635626f5b1297258c85359b1d687fc78ee4051ce1893de52046d8910665187b9502b5988c49da7d1dae941fb580a13cee299d90aaf24a3cc7dac03952dd1238fc370f1f986c1e7c48bf9f5b0a3655aa728d266bbf4894db2831037e17478f653dd050d553562bdca18e57a40e0e041e34f5cc0770539009916eb3101c5267826118af4d4dbb9b5eb97283dbdd450f40bbbc2e8261b1f4637f2eb37e1be6552bc265e9b0b845d047ff285e64e6dcef8d907975a0d126b8b2dc0202e36f878853ec60664ac3e9f6de249bc548522b56da3c433a148403b37dda0d19041596ef9c17bca8ee65469c38d207d8839f7d0e9574fad2d4465e52c64126e1580bbd5ed7aa16531d22be5adb9e86699b66f7a39a5c67d8fbbde2f72ea3dec3de80171c131565aac4d2431d6f0183afc08a60bc6d813a818ede3c4b24db418ce235bd49bd7f4442cacd685ea052d03bbf1a98e8602a4d6407f4a75f71aeaf2509e3ec3c0a79dff84b4b35da6604ec998d79e12405f0f1d7b38a10e5cb3507f1ecf6c4a075ada1365bb1f86882eacd3eb6fbf144335fc8d672920ac88dbf81a6757bd5150620c5ccd8080cc6ece00bb0298d29e75ff82f78fb67ae2bec26b94394b985bec01d66d45c31377c05919faa930e67d45307da756051bc4881f556b6e33486d59f60749301ab52747e5514f199652b372d2e9b720a7a3e1d1a3bf97029bcbbd0e6d226f2f63b22eda3bad9f3b7981289a068bd3306282bc4991a9f7799dc4fd09ede4f1a8cf5afabf68bef4ca989206e68e8aed60de6822d6a141f0174824d7b1ae7fe8c0f42e460844585aa6900e4f449581a951e13f6477d2c2843ffeab683facfc9bf9e0914d31b8c3945b25e5d4903fa5e5f1ecff0d3abf40e19c38063b5f8db908423b9b0c1edc090af09808e3198c81fda2034b436c8b81fcfa41e1125ad0017a2f0ffc9b8add31218d964be839f9898e70fea5b462f446f3dd15cbc39b328d78c19e00d5a8a115f1e2b8111237680e6840facaa71c9ffe022a3815503f1f5eaccba9b1e0f605aa15ccaf7ee57c8f715b9b41839233acc95d4fe62bc40d42b069705e4e6f4f989d1cba95188eacbace472dfe8a083a368a379f635130d2dcda2567b8509ee1e5515bd77077b15e652e2f4f6e12fe89b38ec07d15afab9b1927bbe31883eca75a1a9244ef79f9c8cc676b020acc19051d6638a07fa0a7fb9765235b9bb75ce75d99803197fa944c9697866feed4939c962353a650ddb3386f3c7d8efae4d47a8dd0498a7f8f049b125038712f08c6f71858e5a1acf8039d7b55b05166faf2b9b1d9bfc8fa2f921bd6fddc4f7d1321dd706f38bdc0b182a0a2dbf8acabfed5c6b7df0df47984d4c9618b63e56da76a231766db40bc27ee6231669367cabb0e514d313558b0ff848b5eb76a9a3946171c762b0c22f69c08e84104a02865921432de226255c782b637a72265aa4fd0a345ddf967cdd96c3b16fe9ccc758d4f65b2a0e5ca39816c6c2c249ac8e3446f5923440de979f35195a22240eb8407f8c45de07f4dc50e3f44a22f822cda4e34c503647f499c92eba11dbf72e4db7bc05714609ab516edee882b2aae6b730c069b00759cad8df89355ea762870729b4a7b6b926509e5b6064ef0a1fa61c40d6a7c03db013ece3c9acb9fb1870bb5486b0e87b65fdc325ff51e3d829599be9a89a59c985ec36b506ab86efc1f8cbecc907145568ee9e06463b7089877e77550496aef11ef467558c88c98a1c74ded4f4450c817317451651077d88bce2d19663a94bc07f2e7e3ae790c28c6aea17578941fad8d61222956ccc616af52a28180394e848cb5a943058970aca9380797b828638f40605940ec0452d6114b5329b4c18ee5d740661e8f305f4262bcd7d08892d1def895ea7ba76e9fd052195359de4e3165e8c520cb2aa04a35bd923e63bad297671c5723ad274269ae5be7f7b0cb61932572a64d27930aa0b0c2679a45e57060d90866ca1e1ecc496a0eff5fc92151ba91aa161189aa247597e52f58b7b32f4f70dc65d7aaa771d385552850c2fa3cfde9a5a6d83a184e5e413b85d5dc88ac45caaf38a4a4ba6224a14f0821e5ab15dfa0a14b8d64c48f3d55649fc34e5790fe5168f93083ed9d12dd0128f4c33eb1da1cd21f28081f1177bb7d58c2b58779f9e2954f146b92e810ff38c73ee739e5a12c11b6a885a420308d6dd83b5d7cd16b51f2c8687877d3529ba61aff3d1963f854f57b2b365078db5c77c46d63067133c1541cd82277d5b217189ce1cf1d3205ad0ce3da0bcac6c3888dbca24d1f8848fb34d846f580721efb8456d2e1c3e7161b27c8a05eb45a4d61c0f1e305d4d3f6fa35be1c92fd5502b346e45890394628c23f901cd989f758dddd46350ef64093ed4693c995074d0a70566ade790bf8bee0668acf5d03ab38d5e2c89372860f6c0f0beed605351aab1fac3bc18da9c8a3e66cdf5b80220a5cbdb472423ba2c572835072fc862a8a56df3a7d6a047f74d27afb1258e4f0705d9e64dd4f0371ef308e4cf8ceb0c034d16f4bf0c35cdbcae8dbd7f05b7687c428d723e961322b1f4f421f57253aa32d2b8f6097fc6f3265daacb73b7d870df583db9a13fd17128005ee00f92fbc506d7c23f5479b47f7f7d804d8e5fd92fb1736280570508d7d2e418d3a60702dadb4c995b7319cce88afc14522f069a91d0e8c6931ee5d6a08c6b7d7457f50d7d70904ecca392460162be94f20db0acf4f8f3aa70f183470035fbfaf7efc022e407671a172adb898eeef8a4894c4e14bc6b1128c285ad1e40b230101a4334b3d686c36df63ebd52d056c1cb70a290a4e66d186d9d4fe3ebb897f184c28190a04af18d4b37919323545d9fdee739923c5a6e33436aad355ae771924c1bd3da0ea1338b6c25b8d9b6a607b7c75b5ae27f2c0aa9e0990eda82f3336b919c0575e8ff883079f4a033087d824106515b26232d438d5c443b5be3b89b873b682c1f00354aa187d881ae8c1700a27af7d50d3c38ddc98cdb107b416694c6e1f97d8f470586691f0143afb9f9fce4cb5b9b1f537e93a8a447cdc6cdaea4b707b6af18ae381eb69dd58ef7de10d641a962a61a23f3f5bdf9e9a56f851c6bc35e5187f313bea11387c802934ec756917c76f3b80c0ede9134e318a3bdb88aa783b1c8be605b9edb40b5061ffb12e1601776dd7f048b9eeb267bb84d4880c00836b6f30ebedb86959bad65b5ef4801c8a839cd874d0a1add98a41c1e359e732c16f262e60d2c1e7af230a712d7c481b470f0e0886da4ec2875d847989eb670c16abb789a209ebb26dda6564649448207e44295f7b752f56f63ec23122175bab896046ac1b03298ef1f2f0f87ce7d94e42c708ac2a0715f6c5ac946321d27b659fc29cb3f8a83ec7995043361857fe17438972806a1d9b836df9b0e95324018f3167d71262b1e1285c548d995f22680ff6f56c238648a99078acadf3ef3d959166c671adcb128a1d79f89c7be6c3e0ca918f60837a653f91837bd8835164f8f51d53eafe7e3b9374333095d7eca0fe0d440e195e24dc1e4a55da3f31aa2f08a2e6333084b6400b3d0fb4f740979c9ee6478984703ed0c4afc970c0ad1fc7fb4a57633bf669dfa7feb76d87e574af420f761e8784c521e43a6a732a743f003f21aa2168dcf4fab027275012c085b8f7dbe297cc3bc4d9d6f0511ad61b24f39754a3b769e38a5f8ad276b234eff9f97649a3ae2645a2069b1ad4fcbcde5fc7e28cbbfcadf2ff3a8f36bc909c4201702b1427c6cd5e69c409ab328323d315fe9c9946d180a78acff22ff0f260a9fa9fe80f6827202bed9bf6429d2a772785d8e8c205220b67bea1814c75fa23bff22197a774cf70ae92af2c3a2416da31440fa25e954af2425e9d946e87fda96dcfb2f09cb438044474f136c350cca038d90437de4961e9d3244b2e4304b9dd2015cc00f663d211af0ad356684a5bdac8e04c17502b9579d693977508716ec54dd4b08b1829897af463f057ecb3a48d6b73e15f459caa3d10705a702b2da3ee187835961149873a96c09f34866ee63381fdb444643a2f6ba2eb5b202ed1636de2bf1b727065062e3f40444e9a7f195b3aecfeb8025e8be2e6b821ce0bce96062b660008354ebbc017dfcf0024add2fc91df29ffb52e9adbb12e46e0ddedbaba829f97d29e7d50f3c2da13a60801b2f93c34bbb89d08afce3336e81cd76cfa08379374083f41b2249bed34e5bb6798c83e0d99876f917f7c3da9e36ec4050b2d7b5f9865392d8bbeafed346eecdf1ae38a37f50e107064501ce0ba063fc918f959cded475154f87984a9ce16582a564ddaa9c9f5a76a64b498f688e42e872659591dc4a838192c2d2a7f0c1043ac7e6fef7b49e4d6e2b52ce06e0f7483caee54e5437d04380ffc5da5fbd2fbb8c3a0d3eb0d02051fe57f0fcd6102fde3c48d1edff13ed7ebef53eded4c034c49d559c9832cbf0b6676178fafb8fa529b1e54b0f7ae1b42d5c0a829d6c40595bbcd14ea5c0168a22e1a2223f99b297d8c93c7a36501dfdad76ea08c7548ac727bbb0e1229f508c3fcd00d6974afb106b93764c7c0b033c9fce80341a9ef2842ba211cf9142ff5e3b0213a28d45f34095a86cc93c70ffdadc9eb14d6dfbeb7a103ad9d99cfcd0bf682f2f615d1bad9b346381aa09bd33a98b3f72fefc31e7639625af94be615cd11714a61d3ea0364e26fa643d7a860dca5edc443a49b47b0e524bf9eaf914f22b88f0b6d5fa539161c6e3c3b56d4b9b1455e752cb4b0b44759e14d4ed98fd474e40889019d995597ea35afcf553c42ae25d448562ede37b40e3e464f71335f22714581e495554cae91450c725c2f3cc9186c9ffe403694d8c46ace94bbeb9840bea102a0e6d95079da8453cdea390cd5eb5827f8f1f5fd1a4925045dfaa296e9b90551a064fa5127ee4edf68836e6d51cd2f1ef71da99d81b786a968289abe3ff35e7c764ba6d0563d29060c67ec3509be049b3f67eff822c7b4e12366584d461bf4c72f76890f96313fafd31ec626d528c33e94e8a8bb173bad5dc3e05347e6694352fc25a7a59fae5363bd0d08129968059a6a2273b1c04a4fe4e47f4fefeafd650edf272aaca9e91e6e80c3afb1fcc750f527126c87b3c64d007aa8e1e3a82ee4f67e690251212d8e8b73fbd18df483f01f4347524c59fed1ab71451d32295011dd6ef349fa109ea14281a8cd774f761371739b7ea4c3b07c141df1db09d543d8c9640fbacbaa9321fe7ae065dc5441113a7001d66c40c78a43d3ea4212229691673e1c1849f38f02d5de3d44c5cfea02017ed0767c9c1d03e63f999ec54f6dc1212c4d52dd68a0c8c73a21446097512c793ea71a96bd1d25cfba13282deddaf566a9c0b328a97315a428c75ed0144345517e0977523d7988bfe7be679ddd73bcd84941ebf293c3cb006967672af44855fcc6010c7bcced64132601c0b21d60aa691abfe9e9837e670ffa26cea761453b0cc977553a02887d5879301299f199e2195829c68f9920f9314cee49357f6a59e033e27a85e2e8dd08ed18148cc66fa2df463e6e1357fb8eda30e91b3119c4e0ecd514e5544de732f6286f557a72622ef5a936a715505994f39c783e850dddf33825017d998f1de615e7dbeeb108df59e87822e5b5b601b869413624b47595fa390220458a0e17fb72288f76259521eba8e06baa15895f4182fcce85ae8c4f4da2e6455c777a31478dbd7312a29bf4abc490e3a57a497a2f2fe17393c96739246b9ed6f62751ad544afcfaba25af4a66c09c9e39d1b91cd118e3cad4e8a82c51f23f41dbd5ef08bf107081c4297854ad1f9ebedd38bf0b9d841321ea9649eb4370d89a3b724e6b06cdcb2fa3791812b1a0c250a09e08eb33ca25f7e2b8c7adc94d23503cf77806d16deeb3c626aaa67e74292438bd140d09e2da7d573fd713e836c05e8d8718c58b100b5e7738e7fba85e80b1a8db84816dd9b953f6e65417885c6a15fe709841246187c56814daaef5ec10838eb018858e379b19a4d3ce5d0f386228fbd6ac328b64675e7e513ecd77aa7fd8e80486d7788415aef243ccb5f7e694f05fb4cb666291c026518e8e719f16b36c715247b3aef7fe48b9f0a6a673242b48a7d85ee48e4bfe14ec3eac11ae6b863d86b9795c8b2adf3ccacc077d356776cf53c9fe74138d0469d33ccdceb5ece7e016301f9ae0fba191eeee86fc6435a9bbacb301c46b8d7eaa6665e2da696f6e9ce1d9bdffc68c17d67ce3de07230590da40b3bf5e0c4c4dbc867492dffad774fea779d79eb16437ce7411328276ebf03831a706de15c951c2bc40e091db0f0905404567b77c6336f124444f1a139b9f67fa347ba28bbab387e734e072b4c83815f32d052d85bbb5d86569866aa4f041688830df846023e853cd3990d3e063d29180cf9f9b97c1ccf6d89212faf96e6230f411a306869cc0af4ddcfc7d4a250f2d15086efa6fcc4769fa3048f1a2b5d9e8e1c69d8b2dfdb49293b51879ee8b053cc5655071bf4b36c726e37f5130e10337b66e203c7af14ae062a18d152a261e0d6911091d0e145a4a83377244ee80f21c636e5a5909c394df79d35eef638805e132e88de80b99a88e745e30daeb69b1fce61c15ca6cb5579f373ddbfc4561746772e8dace3acc529466b957cd2071d8223f072a4df326221d4d13cb6b42cf895d45ee7a5e39574834fe5f070407e62701b6d6c91069a79d47334b8ef2fac9025737db947032a65c0c4db858c422b203b7ccf226637528ac0326e5f366f5a8131bf6e8c4f4b34c398302d452f32602b1c0b4af4b16c78cda991d4f34933ab32ae83e2cb092b9fa8dd3ca16c312af9a8dfd598a52ff2243cddb3291e08a18968f96a462950f051807ab198b98c9a39a0f58dbbd2633836faf3df78e74988c3197e4e4ac5abb682968749a07f301022bc75d5d0da1564f1c7d6f8139cb4d209c54f86e80886ecd3a4c97aa937a920473194a25249880fb40262d28f831103f9909d5e32826481851970999c8a2fe8f5fa5eb99323ac2085da6ae2b10c5c86abdfbd7e6e7aa2d7196258a868df0c6cc76a25167cf6993fda3fcd59d35a3a49ba8748504556865d76bdb846e72c660e068aaa1664d065ce9d370907deb439dad14c9ad15b7a1636dc027cc354a654ef347cd672150faf8a62fda6895139053e8964a33c67e023deb9a9dcc6b3288d076c6a19e77f1c3096037be1677674c8824a465915c60f2b244ae22f2d82a76a2e8d9f8430f81718f2482f2319553aa394bf935855d0b6ade75a886f3b4c1f0b0d5ab1e7839a12482f46e382dc7b36c22f8989a6aae7099d6e32c2ebbfee014a6a4f4f2eca2c2706d335e716c67570e05d2f70481ec1fe2191183834b2e8264729c1ce050b025179178ac6541a701c92010467f7d88eda91bca85bd0f812e9f4607c2566df79f13687dcbf4bdd30a655e3e189ee2788424b3756e013f1287d5ded8c4e8e2e296f58e5f4057f4c0824c5b31d9fd1ebc8ac4d46cbed96af233e708d628443f21352c60c9b95e353c85e69cec434d4534eb7a238fd19ee45203a8e88062839996d5e63f53ac5d44f63a44758b1144b556e2e365a783e8a35d3e1d9c49dc26e5e73968eb814d63ecd2badfd274a5d53dd6cd7237c77992bea33ce7c856fdc096492ffa6d446737bb54d21c454e4d0f16062afbb1fa1f0ad96d67c93efa501e3914a8fcad04b6de66712345bd89488a1116ce596a390a6c0840497cd9a7a2e265b03970b54ff4e3bbd4a9638e6f6a4e5a37f982d39e53509f6e3eb0bface94b9146fd48e3b7e211482aea72bb4651451f99de13752f2464654ae522a4d4ae1cf4ba5d5f317322930dbdbb1d938a1b71c0a41d2987b38270cc89e4c40a59a269ea1c84d45a16ce461e29293524ae37eb73f3ccdfc9bd6eb39bace9ba018a3f17bb79508865e8b472b022a59aeb4fa1e4d2c871c1e9c586ef9a423d480807fc339818f5c3334257cc2071d5f30f19669a02323e05cb55441589a5588755d8dc99ef350bf86a103b94f8cf43da57986b19bd6e8a2ab6b1409e2111ed3e43390639c6059650c54708ea4659cac210fb6d1987a8c5044a70c7e293c33964b777c4e9c3b3c9129cfa2e05a916a0748944357eb9a28b8584981a3baf2a6c4a0e08daad06a3c3d35cd1d85f485d220d06dda04e0407099d7f622880f928eed3644e4db3978029254ef4dbe430074402551a398d289d964a7f3f0928ea50fcd82a56f525680f6a212652cdceb2b7bd50d411123ab1096dcfefb8c4a28e3126e5361ec870446ea05d299a2a9e7ac094956b9609e4ee835874fcb7a8bdba17d936107fd8281f8ca309cc0840a5145c0d2ad312538956d2eca91a621bf4d137c5a8cec785d67f232b1c570211a5879f051a78d0bd127478e2ab92e6e6bf0e1b3468fc2b7642c760dbc6b47e87c9bd46c95e11061098d0a06231cf9bbd3335a423306d585f8d658e566f8a352dc243e211410958e321c9013e68134be229300502d772a9d14439181da6a577a606f355a09460bec991628d3282b2a325c75b7b95b58e1757926dde3b72b3b985c6d28f9712034c58087698b04c311e77df9a3903cddc39dc0840ed128f94355213ea14c4424f1e17cf8f4278b2b25f035d14eaaa625d04d2d5653d68cd277c5e5c3fbe0df8725c35636d03edc93a284f3b5df9458208605eda67ca9e5fe0ddc7dc6c613873c3500dd4af1c8db14974433ac81a6dc111955c5b8462c485a221e04adf9446aa30d150807a2fcbe4d5ded034da3a75ec278c9b403585d3db0f545626de33471596be9aabd684153bbd9d1c98e8a2e58086af88878b861e9e5af669b5c41adb86e684322a54c9dcf8fb3928af757b6ba1bdb540d46377e8a27f32766febf5b1f277a1c367ae395386857048e0f990650770579262af64c9f70178b93145e162e9568f2c6e3d7ce53a8cd91f3dccf45727752ed46d8b2984276364ed10fe0105ed09abea04a97e13c0d2dbf796507a33ea311f054dbff599bed5dc7765ed874130592719b78b5e141d79a4396da50c81d4864a108e7644c2de3e41100a5d29ee1e3650bb10aa1cced7b5c9a02e88625d994f2d4648f8b9309306773fab8f7c182402fa02af50e28a7dc24a497ba0966a68e90d7b44d56415d9b366d509a509157ed11b2aa9499eb2cafb56fde65d33835c520af44a25068d525315aaf2030a3a79d5923aef49f361a89fce104b0c39bf18707ba0ba65c49393104c6f7ef1ff6850a91c960bbeac631d6de61d598b35434fa32ff23790940f2e2b9428f5b3566a7eed2529193e844ebd91be9b63af125c52400593c87b0e8031e4ac7b202d92614fe5d9ad547f4c0e5c4604d8ece6f60313df72f0856d6aad1953b3c42ebba589cd9fefc93b89590d5335bef9b579ddd49f166719247d585a544fa152444e9298cd396496397db98a9d112e90a29c120e3c13cfdaddbd80ac55388e4684c4e7af1cf127f2fc995d98b91b993aefd03d169e86ffbcec888716d07aaf25514fd2604d10dbc1e12cac2874b49f2e1b38c4aba7559b1559e0f729d0ae25a1575e640b1f0d7ecb063ef593137ada7cbfc915689fe41abbf185e10e5fe1a201abe1a698f75859a3cef35c30d284e886096852a6e96c76eb4b84457f2b4a9368e7ff1acee9dc18e81a83078c323584d7a12821e810068b2baa9774ee54423b474b61b3f14aa10cf228dc78f33a1d99fb09ffdb77146710d271fab3f152037c603d61f82b69c8dd1db38b1d79e93377e4f6e763f5a89438037d987ae5963f79e36a91a5c4ebaaad52a2d96b004aa6060aff6082323b62f0f86429954e3dbe8f6eb8b934e3806ad42f92b8e34dabda283ff5496dfdac6638bfc16867581ad264d4081d440a84b856afb1394f93cbc700aa692fb39e73c9aa505bb5febf8676d50a935a0b7b61b37c918306a1b7f8bb45d7b2e15f06349e6889fff86fe65c0f8b266bb5bfa1d8959543e216a1242d4392a328f9fb1c6a485ea5a2cd355bf7530b363023835fdd77048cfc62ed3126604fda9dc6e269635fe475143980dd6c852d783818f7c38cc11c82cc441daaef086670c63100680b7212b9aaef41fd71aa853dee1db3d02008f78ddac4347b1075f7ea61636dc61efaa1bd97d7aa6c1c50a3c1de2c3bae03297bb068fc772a385b4fa52d510b5ce4a232b05cd7974edcb7d45b9f5377ea071eab040d5fc677e038dd4388ba7c93375a8f040ff70d6e63015f039a2684ca19619421980d98793b188d09f29d59f2a2b0c17f59d95753963da4646c95314cfdd4b74281a0d962c7fff8509c48eccc0ceb478b84cca0f528edb092011ea217cb77783ef981085986fc898644373c8bae3abd180c8ee5b3de86fbd2cea4ad6015819320e55db6ee6c23024e18b8827759fd73811304e3767a12a87dd3492a4192812ed19a0f0bf60b372131ed62ceaecf810e9b514782f0b6859ebcde526254f9ec5b319353ff4a19fa9623ddaca216f497e3a12b345e8f85ca6bc652a8c6cdb3ba3b8be9b0b75b3ed7d1c8fa627ba182e88f8ef2f5e9840bdf9ed1b64c76069b43faa42c03b9d148fac40654c702947a283f750ae0374bd45b502205e6749edd68634d4446e609e13a28aba195cb619477ef293c9f12e7558b11241f498bb88ea1f6963346f653af3a091031a1d4ca6c8e6f0e9da4626efec82d4658d1c4d27c2b3142cca3a0b4654e611af3adfc15785527392b0a37eb908f6c7197994f77c06e7039f750bc55b973bca2e3cffca25b4c49fe04378de2d5586f9f6adc0982260e6b21b6ecaa6ea87ae1b7ebeeaaa74ad986d88520a64e3140a7a9b774815bb650f80a6a6ba3a7773180a19026d67a3e4f50e1e553ded57d84060d2fe799d839049521ac56f91bee51f60d50d57467a2eb19cc3401c35afe065b04920d66432d443471d64b80ecfbad4100fc552743550c6062ac5103981547d606e60217f117d5655a44c24358824fa50f79cec0eaa845197f0ae69fa729dcfde9a2c42ba61b5c9085321b1b3b9217ae17f2023b0507047e6593d28d304d24c14cc8dd983af1f5aaf41e29002f8e415b2d9b14dffdd5b14a70d06718c8e882a769e9075c0ffe372cb6474182c50e18f2dc78114dd4b29d54d4a8e578d29b434503ca3b4ca4847bf12f3ff8ffab46babe2d3405947c6e7ef9738071b82ef7a6fbc83c8b41ccc0ed5a2c6e7f4e86b9eb0636f86130ced3e3be801c78ff55934fec6495e27c1b820f8e8e71c2bc57835aeda0212897787552893d3669e58ad84c3193aacd23f78b7985c6a2b15342643134406c51b184e77ef866bd2f8ef0e9a687e539e8274f919d80ef57119e61b9a20b4a7b53848ca84fdcc03f010d2b345a4e984477874f78e078e52d1844c9874b0ec99adb675d569053e4d9a8f414f296900e36d9cb1cad989dc45acf31d475b5d09d540929980f0a90bc66259df0dfbdb8e4f0f3369127e8e0678a31ba1cdf8452843bc9edda12b2bae888282364d23f2be3694a78491c44a7d15c567f5c59eff7cef773c0d9dda4e8919bdd8eb4ad90394061a1945c5b6d5d94879371a0797032695093763f89c34f1a32aed02d6459c2fd1a1d6f4e237f4912a9e8da3f01489dc52b6404dd224964d9db4444ec058070093a239f064fd7db4141d883c745cc359102abff178e91af07b6ed814bd757a62c00241d374c0c1abf78b894a27f30eb10519bc2b961942f5c259613f84293c8bfebcfc87690b187c899357c6a4d893f3ac56084e843bd8ece6e1065ec0c95947f30b2c79800fc0487427b36a798b9b2e51d7fe23f73c1c10c2b347e6ca5a02f013c8cacddf2a4b446a219b45aabc348733c7235bd8512b03025c6d02fb7cbf93f94d14009015d9ac031400e8269051372334b0bc1b495510bde5b6af8102065ca69686fd269fd12d96f246e7f63fb456df45ae19f9d865ea0b2dc2f0fe5539e8b6c6ca92131f6c1b937677f5ff15df9b3f4827a4f2fdaf2a5f05d1d2ca87aa23e1c3fd646efa61e8683cff93e877b841b2abb4d241395fe94675941fb5efce88238056ccf045b6a894bb492a01535a9b63f5b4c2442230a16cfc1627ddcf9a8f4524611c725cbd06bcb0c5996b0ac15adf869f4081f31b10330d9080c6852129e44f74c21643d4aa6c4d41ce4b0513af3094ba890e442e7395e663361d3e26d26ca720e7483173614af732a03a5e87</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入邀请码阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>Gameplay</tag>
        <tag>Input</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 112 路径总和</title>
    <url>/2022/04/12/LeetCode-112-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
</font>
<font color=#999AAA >
叶子节点 是指没有子节点的节点。
</font>
<ul>
<li>示例 1：<br />
输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br />
输出：true<br />
解释：等于目标和的根节点到叶节点路径如上图所示。</li>
<li>示例 2：<br />
输入：root = [1,2,3], targetSum = 5<br />
输出：false<br />
解释：树中存在两条根节点到叶子节点的路径：<br />
(1 --&gt; 2): 和为 3<br />
(1 --&gt; 3): 和为 4<br />
不存在 sum = 5 的根节点到叶子节点的路径。</li>
<li>示例 3：<br />
输入：root = [], targetSum = 0<br />
输出：false<br />
解释：由于树是空的，所以不存在根节点到叶子节点的路径。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/path-sum">https://leetcode-cn.com/problems/path-sum</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>先将问题简化，看看最简单的情况：</p>
<p>树为空，即根节点为空，那么自然返回false；</p>
<p>树只有根节点，即根节点的左右子树全为空，那么就判断根节点的值和目标值是否相等即可；</p>
<p>再进一步，根节点的左右子树不为空，那么就分别去找左右子树，看看其值是否等于目标值减去根节点所得到的值。</p>
<p>依照这个思路得出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> targetSum == root-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, targetSum - root-&gt;val) ||     <span class="built_in">hasPathSum</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="LeetCode112_result.png" alt="" /></p>
<p>复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：开辟辅助数组所出现的消耗，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻插件之MultiplayerMissionSystem</title>
    <url>/2022/04/10/%E8%99%9A%E5%B9%BB%E6%8F%92%E4%BB%B6%E4%B9%8BMultiplayerMissionSystem/</url>
    <content><![CDATA[<h2 id="概述"><a class="markdownIt-Anchor" href="#概述"></a> 概述</h2>
<p>任务系统是串联游戏，为游戏提供强力游玩驱动的有效手段之一， 在传统RPG等游戏中有着非常广泛的应用。<br />
任务系统编辑器的意义就在于能够为创作者提供直观的非代码的界面，使其能够快速的创建一个又一个的任务并合理得安排其顺序或者逻辑， 并且在引擎的帮助下能够快速预览其效果。<br />
本文将就Mission System任务编辑系统，介绍任务编辑涉及到的核心内容。</p>
<span id="more"></span>
<p>（注：本文主要是对任务系统中涉及到的概念进行拆解，结合插件内容演示任务的定义、提示、开始、完成以及日志等等。同时，需要认识到，目前该系统是基于RPG类型游戏进行了高度的定制，所以任务的制作中包含了一定量的RPG要素，如经验等级）</p>
<h2 id="资源获取"><a class="markdownIt-Anchor" href="#资源获取"></a> 资源获取</h2>
<p><a href="https://www.unrealengine.com/marketplace/zh-CN/product/multiplayer-mission-system">https://www.unrealengine.com/marketplace/zh-CN/product/multiplayer-mission-system</a></p>
<p>本文使用的版本是4.26，其他版本可以自行编译使用。</p>
<h2 id="快速上手"><a class="markdownIt-Anchor" href="#快速上手"></a> 快速上手</h2>
<p>本小节内容是为了让读者快速上手使用该系统来进行任务的制作。<br />
本文不包含资源的安装，这里假定读者已经安装成功。</p>
<h3 id="输入模块"><a class="markdownIt-Anchor" href="#输入模块"></a> 输入模块</h3>
<p>输入部分，系统使用了第三人称的模板，所以基本的移动可以参照第三人称模板来操作；此外，还进行了三项操作的扩充——攻击、交互和呼出任务面板；攻击对应鼠标左键，交互对应键盘E建，呼出任务面板对应键盘Tab键。这些按键响应都是实现于PlayerController，并通过核心任务组件（BP_MissionComponent）中定义的事件来作响应。<br />
（注：任务管理器组件也可以挂载在任何位置，但是为了方便访问及网络复制Replication，放在PlayerController上是一个推荐的选择）</p>
<p><img src="MissionSystem_InputResponse.png" alt="" /></p>
<p>UMG的输入提示：</p>
<p><img src="MissionSystem_InputTips.png" alt="" /></p>
<h3 id="任务制定"><a class="markdownIt-Anchor" href="#任务制定"></a> 任务制定</h3>
<p>DT_Missions（Data Table资产）是用来创建、配置和维护任务的核心资产，其本质上是一个数据表，可以直接增加或删除任务（Mission）。Mission代表着一个大的阶段性任务，比如新手教学就可以作为一个任务存在：</p>
<p><img src="MissionSystem_DTMissions.png" alt="" /></p>
<p>其中，除了Mission名称（Name）之外，还可以配置任务是否是可以重复的（Repeatable，影响着任务是否可以重复接取），任务的具体描述（Description，可以反映到UMG上），需要的玩家等级（Level），任务子序列（Sequence），任务完成后的收益（Finished，经验收益以及新增任务等）。</p>
<h3 id="任务拆解"><a class="markdownIt-Anchor" href="#任务拆解"></a> 任务拆解</h3>
<p>假定在新手任务（Startup Mission）中，玩家需要根据指引探索区域，与机关交互解锁新的区域，最后完成新手的简单战斗。根据前文的描述可以将任务差分为三个子任务序列（序列代表着任务之间有着相对顺序，即完成任务一才可以去继续完成任务二，而不可以顺序颠倒）。<br />
将所有子任务序列及其描述依次进行配置（sequence time是任务的限制时间，超时未完成将导致任务失败）：</p>
<p><img src="MissionSystem_Sequences.png" alt="" /></p>
<p>UMG中的子任务序列显示：</p>
<p><img src="MissionSystem_SequenceInUMG.png" alt="" /></p>
<p>Objectives代表了当前子任务序列的目标，即它定义了玩家当前任务的主要玩法。如可以定义玩家的当前任务目标为探索寻路（follow）：</p>
<p><img src="MissionSystem_Objectives.png" alt="" /></p>
<p>其中WidgeType描述了当前任务的UMG展现形式：</p>
<p><img src="MissionSystem_WidgeType.png" alt="" /></p>
<p>对于探索寻路任务（follow），可以使用检查点（Checkpoint）来定义要去的地方（主要是定义一些检查点的核心属性，如显示规则，位置及UI外观等）。<br />
而对于其他任务来说，就需要用到Objective Targets。其中需要自己去添加相应的Target Actor来定义具体的规则，及对应的Actor上需要添加BP_TargetComponent组件，如与特定机关交互的Actor：</p>
<p><img src="MissionSystem_TargetComponent.png" alt="" /></p>
<p>如需要进行击杀的Actor：</p>
<p><img src="MissionSystem_EnemyTargetComponent.png" alt="" /></p>
<h3 id="任务切换"><a class="markdownIt-Anchor" href="#任务切换"></a> 任务切换</h3>
<p>在配置表的最后，当任务完成时，可以配置经验奖励，以及在任务列表里新增的任务，该任务依然可以通过ID查找任务表里的其他任务来实现。</p>
<p><img src="MissionSystem_MissionSwitch.png" alt="" /></p>
<h3 id="任务开始"><a class="markdownIt-Anchor" href="#任务开始"></a> 任务开始</h3>
<p>任务的控制是在任务管理器（BP_MissionComponent）中进行的，可以利用BP_MissionComponent组件方便得进行任务的控制。</p>
<p><img src="MissionSystem_MissionEvent.png" alt="" /></p>
<p>可以简单得在PlayerControler里在BeginPlay时开始之前配置好的任务：</p>
<p><img src="MissionSystem_StartMission.png" alt="" /></p>
<h3 id="接入umg"><a class="markdownIt-Anchor" href="#接入umg"></a> 接入UMG</h3>
<p>BP_MissionComponent中管理着所有的任务数据和日志，包括完成的，未完成的，成功的，失败的，等等。UMG可以方便得访问运行时的任务数据，并予以显示：</p>
<p><img src="MissionSystem_UMGGlobal.png" alt="" /></p>
<p><img src="MissionSystem_UMGLog.png" alt="" /></p>
<h2 id="演示"><a class="markdownIt-Anchor" href="#演示"></a> 演示</h2>
<p><a href="https://www.bilibili.com/video/BV1XY411777M">演示Demo</a></p>
]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>插件</tag>
        <tag>任务系统</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻5新特性之GameFeature</title>
    <url>/2022/04/08/%E8%99%9A%E5%B9%BB5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BGameFeature/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="3a2a77867c312dec004b2c52918e1e8a8438362fced4174dd8a0aaa76619b5e6">fa2633a7d743470e974359ef9dad0234f30774894771689c244dd76c90a00c707e2b0b6b53c70c9116e6c04f325fabfebe5d967d3d9c14599e169f7aaa1570c3c38240daf1ae1532d5afb15dba8aa3ea55f48ee2c31074acb32324f723d53439340ac23c855abaedb9d018bcad80aab888877285a993baa1410c66288895a530a704c8ff01d261decedd2f507e784727e814683021ee726001340231967f92768cb15164c1352464f8de6ac20ab2144ae8e2209838abcf791a1a917717c79038f293394e1469b98ede072befa2dc93f1e9c41980d376a1e8b30c153b3e270b15d94fca7d2878f47dde43e203d1341a13a37cf2d45789377b2e63715e8b0c08c4245ec5f80de95a7a934c6d5c44163883d38908731f018d79fefbc1a9fe9b684a550c8ab4d3eddc9515fd033c323d57850aee5ce13bd3d991992ad325654e55a0e562159834abaf45941a8853055b121a3fae25cac87e4be3756d184b999ab8bd76a82b80af8d684b2f6f7b1b94e4a71e970e76d784c503a7d3185aa74168b0507652ddb5c6fc0c2d4a4663e2a2b22643655b995c7d829f4cd1fef4dc4e7798bb1f450c63bc3ef74c5c7ea8cf63d486d1d6132319f8861f7551fc8068f61aaa81cd3510bd8e4bae54ec4b73261683cad36440f786f262cd674bed247e4814a39b2cdedbdfc0107bd05140f87e1efe8db9f1349b82bd2eb39004928407527d75554e30c37ea0d17144dbdd0c551d77501577395e1e1dccd7ef1ccc4803920a78bf742483be62bb345cc94547952bc54c73b16b4c5764c7e95bc5e56462386a52ae71e8d64b5b99210b62cd7bae9dde8ee955ce546d670a199f0970b9f20a9ebcd38a30a88c5c0f9f6a6a36ac0d216c412b8b5eb5499ed3a89c829ef45de8eadaba231a8e9a7a38c39c2437b89d664ceb115255cdbfbdb5e232bc1519a40b70b43ba8663f4cced321b4a8c80eac4c106d166ceb84b58ac9dde9cc037df30d982977bb5a6c16ee6d18d5de086edf2cfacfdb9599b08da331407c4a5e0d529b3e8517a799a40f678138c3d8a7db0b00cd054f3849d3310cba8e30df748e114de29e547c644422968697cf3ed7c3dec370d44fac66ce50b1a7d7262988f9980d7c134561f3a9810e97dfa112e047f942143f7756a41d0f8bfaae906799f1b54ae600da98dce4d4d7ad01363d80932fcb2397b044b9fd1e7123af6f66d9a0b7b1ace75ce9ba42888673de91fb2638ff12057cac127a5fc75a11730d4956667b120b030c364c7bf1477794d3d67e04d5939ca17bb52cb63487759c560bb2212fb9860ccd5c217b6878337c42bb57ef1280d076a7f7072648b1bd6a8b801b62a526f16e45b805f178cceabb79cde86988bd097b4a95239e764ece0aa3b966b66b48ab58fcffef73543a101c4a0187f2f8e5a10aa21f2126549f5e447a56f3704c5f5343a541b143839eef3ae47e700d5480c53e9147fa8799b008ce91643f89a58427187378ecf68a82b11a57b8b128cbb647c53415e4ec867b6a5e3fa95f16a52a17e436ed39bacbd871ea43baecca042b8e2dd15807c3ebb6d4bc1a555368657e042a9d4c6ae8409fdfe131f6e1fcb6042f9c61a49b357fa558e58709843c391d5c48f433660ddad1f96b12455dfd9002ce66579cdb02dc2f566716c771456221f21947e57f5699dc7dad618d6911b63a566d23210e6fc45c104ac395a472923d92a69cdffa01986efe08ca19489f46d684be75272f1ce0a59eb0cf2f1934f3cab65e94638c3d4cc3c1fdb64f99250eff56e68903c18c6413d13623f35a327c6e6a8ac1476a4b5cd36653a557d7e6b0bcb2439ab3c287f2915a630444f7507325bd780ab96736bde0498d6f8db65c88bb846f8b18dd02c381940242a51474c70d6db4773315e339f953ee1daf9db85a9d145c907c6c93639aad67fa5f1cd2102770bf496c662e951849d50d03fecf5a6e25be84556fc3f954f520cc05e677b56581e99cc453fb7a4ec8d20330bd64fceb1bab6a4fa81c5a6aa8dd6f042aefe33d1537eeed29f298075aa1f141808eb96ef04f5fbcb4a72d1bab836318bc05540eb339ca37ff55477923e2ebdb1bccbfe8ac0c78de5f600d7179651fd71abb17a46672587377a719acbde9fb4a60bde385b594e3e3f7f0b0393244b83997e2362d8cee4a1f6d8531a16cdaf715ec66f8a15abd5504fcd5c1a3dfe324ebb405ef6f4ebe20b1705a989291e4762966006ae3d713d6f1dbd6d417e2cc98394744a5eb967a7cad0947e5988b92a0b5a93d6142640fb3c41b711c72702ab7ec47f267918eb3d9abe9dcb8d743c2db4623f50c63a7993d7a0ec5dd0552cd469c81c2640ca1d5cfd59efb26bb22522c2f9e1e1be044bb725ce63ba305f4dec3ba97706bcb253cd0eb4140c3a286bb953dd98e666fc444ef6df563e23adb6d46851f9f09d8d3b85deea8c4102d01f621bb16f29536ed9f01e680d41e4c1c01b139b0e2b2e52738de0d633f2144c64336df5d51e1e6478fd37e0b95710df85be4d1403911138dfc9050afba75668ae763ebe005cf0bc8c2c358a6c34728e2b0548ef59babf436c0fc1504682139b87a2c7b8e1a1afb9cd04af79c35023c69899319d72f249d83f2b2d79f1778fa2f4e6fc828d8a63f542a63a8862ed6e9435251b2fd5760d326bd6873e8aa28c7c8c81cec46957bf331dd39121b3581d26db0cf1469a576f14508623760672982acb3fd8dfa91cf522450bca040852ac9c4a49ebe08d8e7cc384645ce4ebcf3848bf0ab734f7200b7817f2639e911228edca44363a62d06efe8c3d357a2e82ec593868fbe1568221fb1875d8e2abdb9c9b65de6c8acfd391126fa22910cb4acae1500d942c959a3b5ca88b7a3a80f611fcd83ca56b11ff40ab58d8975e01f7b747c5c502eb55dd7588ce3c2bcb4242f9539b2ac144bcf159647f7c3a8f02bf79b4aa079d4890152e7eb0cdac77505e2ff2f990f06f9203893dc92ae813906619d252fd81f3bc427751247f770c09fad2904c97ec6939fccb56147fb559768508025c6fabff2a103df2f441c34b42f922205b5bef223dadf83b1263813d2414947e752a2564ae4831b2856a52497206b4be44c8019e48a6e82780c496a5ef09f8f5adf9660d190f626c62c4be7718b44c4ca1745f91b878920f213f3bc83608799fe0228031bd9c0ef559093c514b8835447f3c2e82fe6996aa076db864a537860bced0197ec17b22a3bf48fe15deb0b5136afff58bafc2ce20dd7a1c1a8352f8816fb5e6c99156d8a826d461352f29b5e20c255656f67a617fb44947e593406575193e7a2a484d555ee4b761cdcd58c7b48f7a7a01ef48ad7c87120e1b6d10ff9c4c801cc29d9dc97070a9686450e552ed0479b4e11ab2bd1b328f53a59159d13044626ce1776a67ad11a26a1efbaaddd4e8b5516953883cf8cc47e008da26af92e3e4dee684586b4cbd727171f58e79782bd5d6911fcd0477b08cd63f5db52ae00dbe6839c61f52daf1e36a56e5566971a7e4de2da7353c050860392a148cd726f754ed14369e8e8bb2339847a4f1e52a29736ce1462ca9d7fdbcda6afbb073ceec5c17c348706d58bd94d0986f8d9b9e4484ab07185e27de459c75ec82744ad617f5360af6541fb6e80573669dfde0ea3bd9d0ff15543f2a5cf52b93bb26b8001c357701c4e0e2170de162c7c38b05cc14d3a9833741bb5e496b9c294e961f7c8c3a0d730685b9e398ce83a1a1bbfb10367b7f207b55404f1913d63a183ce7e80f5c387e5db47c55e949d1a147a47f15d9aacabdef9fd42a076bf98000a8420cc30b864fc625972c58362bef131d50cfd00281cfab1acd74e0b2b2e53d2a89901e3d5568da00359acfd8dc9b8c1bfd6dcb20443da7d7bab787d5e7b083de4f28aab2c24765f9fa91326e29bb5e4c2ba91edf622977c564d69b3fb8c69ec4b21d3dc42a240f186e31ed0070a9c0e5c8394f86cdac9af39ba0280b503b8d4eafaaa6ffd06f58a01c6ccb729b55d20e4ca7f4b97663e1e377a35b7e985fd3be72fcdacba0d925be0c0b1f7054bf3aedb4e8d88456cf04ab0082c1ebc4f9bdbe05fa98c1abf3907b20b3f9612c5825ead83adb10916245bf0dd93fd8e9ffaf02be2d02b182aa828fc06998d7c9530cc9bfa3eb17fc454d09a42cee5dcd1fc6ca3e12efa786518b760491d1d949115d42535f0ebaf361963231c3b4a736d24f6df5f07f5ceb9b395825197da7d2a2972196b21ea0b9378b71e74016c288583ad3170482457011cf8853d05663eb7ac4b6df29f6f54a1a9f60be5878bf460b199a212e235326a5aea8f9d67ffddcbf9d5b427ce44a619365b05649bf858061b743d7f502f9eca78b0e520278ef19a152ee4735aa7818ab8804e4bb6bef9195fd56e7263c0a6aad661795f8a1ec60a2f5a1144edf932c665dc442915564a996217819179a81728aaa4c9a043d4962a0025d998c2b17f2c7aead67a5ec865b49d3a82aa88c62e6ee1274efc1ba9713ef166864bc63898ec521618f451fbb0f8373b6dc4c577fc4137d6c858148acc0ab172a3974f14ba4cf1091a7e775a920b02da836da7b2ae0bb92a20a97e82d52b4e76bce21fbe84a3f34027b5cdc4522fa14423235dadc52ee4c402512c4a93fe8d7c663fbf15f27a6f14c245cfa272023d30e75e720c6862cb8e0b3dc62adf5a4d0debafb54e258026f34aca93eb021ab55ac63e9d89724422811d2d37c05e95c739d6f2ebede3e0330340f5679769f8e09d98e039a593d07cf0dd91d549cb9bcd91c387545f6e7c736213d2fae2ef7f35917da60d5a94ba8d1af9480efb7fef632e76fe4a5e945769fa1ba6754e72ceb4b48cc3d0ffe6c4a04c36637d6f64b70a8df0e3d3f72d0c8aa7bf5319dd0d640337e4e91b1db8577e2a836ff9fcdcb58573483388e66b828557ed9c40790f98a5e0b92259dcbc2ced980ddfa6fc03757a941bb19a2368adcf503194c9e1904749fbe6c0bf1f3cc5ac413a23b5b11dd24abd35f8a45bc7d149139c44193f84ab452c2ca9bea52b432212ad69e10227b5a48a9f79e6f2fd31452e72c9958b0109de5034f09601d7152a5670d81220759bddd9b59c60f70b989c463be4a51df42e3ed5e2e4bc52e261b05c216519353798465af0854b75b4d364d0c82a735dd9d1a0f8552677a3db38ec101dbb520d64d3f0cfd607fb7a515d5bafc18df232e5c160102a4614ca98c5bc9c954ad6c32f917299934e401fb81ff305fe203a2efc7a5f973caf33fc03e06d573d68cc2ba84a73461c1dafc5d2332e321adc4641c59c9182f4515e4427f7d0bf261756ccce90c5489365acdc9812fe284c0e1ec2d152c8face0ad6f393345656baa1d19f29fd8d3e3c449181378d4fdc0d879ff4ded09774e496962b24c3f48ca7977739c052f6060ab7f27ea809b7be60162bcb1be474cd7e5c335ae79cc2989f56e940b45dab2a516978644ad2d1755838ac3118f75b1e7432ac68656aa29dbc71c62a11763c77d4b43adcc96f2ab5d336990ffe49da41b00645ae3d43321c02d00ac5f438ae7a5a37028db422c5ba176075313578743931259faccaa2441bf9b1e92e1c336866557f4853506804ad3f211362e8c166867c36689ffb550ef81aab78dca442428fa4b0464f7a3e97bff50d417b7ce044587aad2077b2ba96dce0aea9c7b7a76f137fa60c9fa493271645079d6337bfaa95ee1ebd5e31a4e05daa7f3c07a6b9299ace3d8c8d9b05817daf266c9d865ddf8a427deaabd9ee41d933f990de0688f0efd8d1d4ffbd098e13819c20c00bd60c36730f6e998cb8754ba7cdf66e61df04544f95d7feee2b11bfb81d0f69cda59d4f1087aa18f1af886211510282234cc83457850e06d958b08af8680ce8ebc4e7a029e866a9cf1e002a79569e9a8ba2506f33c11591ab0a6ef99bac08432ceb1b0bd7763ceeab274d3ea2ada3bacf5757d1a63e78f245e7344c5d627337b630ce70cd0eab25d787cdfcea6d6a3b68a0db9fe24e1c97b91da107a64439c186104f888808401d22acb27b930f5127c9e1d5169e31f3720e9af5da89164408292682bf5d45b7e6e1a926a370509138417e79221195f0c52e279969c9299917f34946369b39e4c315466ce72ff505ae13fb778253c9fc90db61e29d7c7cab1960893234fddff433eaae254c14d5e85fe86c99909d263ce2bdf43262e750428cae299b08765042ae31c21cfc8aee30314bc3762d3b3c628bc0afbd3a9f826d0f869a8a6ffa82d2267d87c5080d6b890506827358d82759a3c1b351cb73512ce125f5b0d9431531f8e51040bcbdd9543429b9f7e493e3ffcba9f1c271444b3095918e59145bed61349416ffdba973808cc090c5e8b5b0f9c1c0533c85bfb56e4640e77aee53e83504d0b224b255c13012a1df4d09e3522ff8193be73c3be31074f2bdc40df1507df88ad87df5d92b34414b4f9060cb4052263820dcc0a822f6014840eb75fca75aa883637b1cad3bd113e498d0bc3cb793bf0711ce066f7ca748a14a63e03e50b042e0b2b6699905ae26ca9c13090c45ae58819777c7dc0deb230f97038ac953e6761a0bb39104bf1516f4fbba719d714b5744fd45eb622bd31db2793d96b5f9c1d96f73d82834704343d32ab30b191a445be9a97aecf3678dabcf967f86c6708e5e07cc92fd3cdfac962048001d5b0d257c7244eadeef215772c95ab76f32dbe05da48c1272100af3e53bcdb4b31d1094f899f61e14c4d142acc6e0ed8eead9e98182950f89db92240f1b2ab2c467e23066a9f244f79aad8c87ae1b0eb21f64bd641243c7a950c54705fc5f2cbe8b97682b9120d560ef85c473f24dca727c0bb5ef4369bfb0ebc2ce4e722aed5c6dfd2b64048b0251e4f7e691ae1b1fb165fd1092a9326bfe31e462545de19b4f069756b503be3660a474148505b93e1fcb5ac612f48ae5bd6524087a79a49b1a3c1d5cf960ef2d118aeac7f46aac9fc0225314b15604936abbd18c7aab20ec1c26842cdb13c30ec00c72b68c2b67b282bad2f7050149254d0521127fdcfa1f914adcfda0be0a18d6f4fb0da638c6fa74f528c454eaaf613350034ae1bdfa71675ef104b1fac68fd7560b44fb96f189d59a8cf4f56a38940d7121abc3e6e5532e9cb88457e0774b469edff5df5eb53901947c77e3454101e787463c7891e7895c51b1168830628c7f8763c3cdab08ab3cad79ce5375cbb332116c40ea5d668034662280c09832730257ffb09926b3acb8c75cb478c864ce8f648c19f2f605e80de602fe8ce389c2f6f5eea416e0c15cc0412059767bfa2b8c88943f27ae00272408095017426c98e41e4832f833cc17c685b8fe3153c7b5cc8883d232b3c4c83c9498ef5b58d89ac36574f0a36ff6f8b5ba25f101b9841ca169a5c1cc41ab5c3e659660afd8fca2ec9b8b9590fd75886700e2d6579adbe1de10dd4f2bfef24bbe9faa1bf05287e07b045ded6dab0e10b031a5de22521c3b1a52de0e8e0646336a04cade590cd50288c55ad6dffbee6039ac428eb1d336a6c1b35627cd961ddd8dc005b002c58a75da4ac2a2bb248d62cff5862d6f3dd9aefe48fe1fcd3b110fcc220f465869669885bae07ae7422da0cb2a6bee89c22d5519bb62ee1582b3418fc52be05da9516544a7be172de3b43652ef66c199665e75d8ce18d6b7b6c80221080bfe4af6fb359660624c7e8e71cf128b9b73562f3f8ab5d24a441256f15050959a962bf43564ff3d80144ee6b0ea6dc58bae69f9f62fd48ae6d27ac196f1f61d626838c5ea28d333f653f46e63f6f31b92f2d1f2471d89b8e3503c057856a31cb9b10c0a17ac84eab1c8b766cf5c9a33dddda7ddbdd81e75dbba0ddb7f9ad3ba508d777f1988273c5fdea31985326ca59b951fd2d46208110464c56b0e548738cdf6b4842d8748a0069c03ff93b28a186eb800aa885b6b400d4e86f07d88e119d95aabdea2ed8b2aa1981309e009e24644c0dba9df25b7f5d805669e05653ebfd247e318ba8c347b15a72063081ed2e45647f939f56109cb99a6f3eb82c14ab18bf3a706c0a1738142fe6e693522f1ef79f3c6ba6cbbaf49e5417adda00a139ef7257a517cab86dfce1699d7fbc624a683a439cf055e533b6d9022ddb85c6dae7f016f03a385d0d6e806451619adfb6bc37cffff78161c490506f80f9b11e5c2630f78e53c8d1779cc39e4252e612444575fed1e4bece3ab6aa0d0e179e569d48bb6c801568d512aae11d2b6af5df8cb347e820f213a730cbeb97f7cb22465b8e148e83d9c6648fee2a474f32f51d2914b4f501613e4522cef217fc9675abd2d130dec8f743a9eebf7bdb21a55a8df581e079fadbeaf98c2f13c0afe4a26634522e5f89f1dff058e471b51ba9ed83a3b6589ca8bf654bd15377a52d0e71dc09c962985f9cd646fc1a31975e60a285bed0159e12b9a8196eb8314384bec5769abcb15f973371a79c4a9a64b98e8f334bdcf5e25398bbb8c4e3a7ed6818b88b0a61f72407bcd540e52ae5b12db52bee19833409363332c6495d52a6299978f90075c23a447e4c7db23a18bdc902dd1584057f92854b5836a0e2118f2f3739d7b304d55eeac390cec1444ce63b461cb1b9bff46d12275939189f3a8e391f2904ffccf1f10256f5225fe826ddb61fcf4b331e3d7b9e1b22487a7ade2730ad533e5b71ffe9488fe30609cad99e8c3d825c2ccf1bb65f7f98b847aeadecf839e69358f0891d0d88f1cc671d646bef9da1b43dbd820a61696f05295f064690413189bed17dda2f720ff99b22f3da01ab18b56a1c53fc38fa8dbf7932220766c643b4ca0881b0476b120345d683ea508e216131fa6b6fa7e0401ab6a5e4fefd0060a6d621bbc8ad457d7dfe71c16f6f93720eeeb2504c159e12110d8900c6a9334419b14306be6a7a7eb247f685fb6687fa9731d322481858ac0c52ce222007512b2814f745e19c056374d071a71661615ca64b5ebf212c32e0286bfa2d860dc05a3b05a3b5e7e5443a1421f3b4544f3a12b60d7e2dd87b0daa52bdeec4bc6075110166b0631e1cdfc8cfbbcc05c1820b5f66888d91861eb12bff4a7d102ea6eea8c8a2a32b1c2364d63980647d9ae25519af307d81275a4041130c4308e0924ec80ae14efbb56858e0350f6afe5f584cda1d73fb4c1bd0996c4b2edb91fee0c71b97d06221b05f2beeb178a9e50e69f370303013951cbc4740a05e18ecc49d10061789979187272b4bb623930adb01212e8e5ba5bd4302dea1eeaa8effcd61bb350c8105e0fc59bab0d4507800270153b86c70f88eaa7aba59006669e5823bfbf03f2f75e38c42193545bebf47b7dfa88a4814d35b45c7ab41ed28bf70f6db6903a96c56f7f82f0addafefaf6eb922e8e1e1c8defca4c733986dea4a7f2f6800c8c46f9e6b0ac2abbb6af68efae2890a3d7e6daad3816d32f3f365433ba44990a1713d5be3710733f41daa6e60eeda8a0feca88820d01763ddbcfe7a3169177aa78a9eab4f6dbba13142c62943ba8148ff5f6b95b09a80a98e6e78f7bc6d8844e74be4f149fd731fc26d2e254bf82d87933bed4c3fceb048ed590268d90c0275939e6fa1e84211cbe71ed82e947017244d7f1bb833b01747e518f45869f1713dbe613ea1cfb6ca25827b430af62a6a12ef1770a91421831085bfb8bba43a3eea5c1f2e49cae1837298b81945fdee88e89bc49a71640273eab3568d018653dad4270e8345604a7e6267e02f2b7d70ec8b2852b24164469dab4c47a4e9390c5c0a2d87488004264313ee2448cb1471d74a423ff53c1b49ecc3fe04fc2e5f8aa6a5d5d5ee42650726eab3cf62abb22e0acaeb279723ab38d6288e307a1b777ebb00bd385101529ca3a3dce02adaeae0f21a58e7c72a69034337b8385449c4526b07cf1cdf7a5758ce36ea6f6adf7bc51490035f94e86088f29cb2a025698c51eeca9a3e74b5b5369cd6ec98b8235cf96370639fdf2ad1b36239a38fe8ab205cf04f46e0c0cf6573639650ddd83bdd5bbe7a3ffbffc98c6ab10174a174889fc32be5120d1a80c37086da0eb8d80ba28382445b549ea570663827ee3741e5758365b6fd5424121e3bf9650929d5ffe90519fe7346d7c4a950d137726d48856eff6c0489d3f3108ce11e35dd33977314686e6fc2ebf5e995e8b74479d945add1a01e1e212216a66b929a0698a0d293f5d1bffac43fdc242928860cd31f0af037ecc46ad8ab0b8cd647f44726d08079ea40eccd580b35b3a40fddb1283f722283e5b079113879fecde6217854261d0ef505a4c056f8b42b8cc0ab1ffa4c72b6bc609d442898eb63caea4cc6196f61e0a10b18aa1781fc52b364d3d3f34e7261895c0fbf50798771cdb99a3652823c5239d3a8b16a00e9414ea095e95d6ad0f8a137c35fafe84bbae19ab7f06b99dba2164c68a0c1b80ab06b0e6db1bd9b43fcfa46b94d10a22c3560d667c1999f736b12b0158ddb46d303c8e040717bd683b2fb990932ef919a39585cade50eb92a8905a481816dc51e17881595fdd9282ee69213fb126a4e783208b8213f80485353a161a3c98e83cf42df32f305932f81f0f14a8370d110b0e363a86fa6d7eef42d84da5c0b0a47cbb8cc0aad993c5aeca511314b3e9fb861ec518c781526796e8d6b5d4d3faea4111156e840250cfdbf7778d0358d3e0bd02dd6dd8c6d73a5a8b81822b0abe772d1a0e237a52048d0a2bc3f323d5113a821f8d0253e84dab1c58560237e86d155bb9ccfc6be8c6e1aa5a11ed4f35ecd4be1edf06b28a6fe212bdc78c3e4d2eed473b95542ff9bc34d4e53bdd92928798b5075b719d0ceb219268797adb85c88d7e1d6d7138752f2d93bd2085e7a9b51e14caa09e4294cfc56b651d5cc1e5337bd30f0dc7cc7dbe9ffdc5f8fe04849a8d3f2cb959b017caf8dc69e9e32286c6b47cedde6e2534d37f902c25d927ccda84e6d42d2477b5de7d3fbbc7806488cf6adb06bc6214acb66ef36c84740dc1dc2f5d93900582790ba7c7cff3e5ec412811320ade8b7c2d108a227a09ceb310f8aefa048fdc548e43fefcedb94befe094509765a91aa859eead886d1307c4c1cc855a6db6df9e743a34f41c0f8704883cbe2b03d9f0e554fd9093a92216902ae7555480fb7901f8522be49917dec5e6efe0bde76ddbabe03a12d336f634a00de166f7e552def3388faf894fa56024a06167b4d14467a737866b5beb6863f014f05795c20e5469087dd7ef368a5ff99419902588c7e084c5ef7c87a3cf29a8c9ec9e31877f5317f4f268789497bca33159f9db406e5b09232d539fb954316bb33bc6124bafc15c3d1ab03e8395e35880c865094d140d4e122127e381eac96780c772cb4e1317df40c928b4bc8bc00b74caf98d67a2286bcd6fac0436e474f6e5a0ae9e58a9c3b2ddd23ae003b60ffc870682bc045f4475ee9d632b8a0f946442e37dbdb3e7cf9b8bad9e05c2cd45f74da07aded1d67144fc94ae28b9c3310158745cd01a82ac0abe7f278251e9221bab31e6909d5a12946304cc14674daf56a7fe339778c559427def09b43d23dfba8ac67d5a85d0ac227eda153cc660341eae58fa103456488582c22f0f579416553069ae3fae30ae4a71105619fd77c068f08743008f0c66ef0326d9d09f0ea0d4848f02e3baef4957e2d3dbcb7162d37aded785334f042d151d6dc29f26d0ed4dda9e12d0f233a5bc79dfccb8067d7f71e3e86abc077557f04ec431899c6d38d1bf4d4db5dd66a1696a526fae43c3891c55a38e0f45995a9d91f5a1d2cac2038ad07d01428cd96f18e58d52fe7bcf46a866f26ad5b99f91cad680bcfee53e2b5d6e61497d170818b57dee37f02581aeeb206340b2bb1ce4e93b720c3908001eddc264dc77c7f0807a2523e9d8b86bcd1c4f12e3c8d87f9b5abf70e64a200e6a5f444110b1f76277cf0a903e78010c20a82cb03de5d63ae6de0d433a434b292e2302cbe005bf712d51644b9b84b1b69a7ce9ef605e0dae44c976968ee780753b98a42351895f088f5f0e1b3358125147ce6f9668caf7a3def47fd553c347360c89abdd8fb0179195eb9ad1495849fa095e74007ba7468aaf713950391a49a08ee7fc769bc0c5cd2b607f5f93cd4889dcaaeaec4c2c0a948e2522f9fa8a46a8e6207b1599da9848df3b2eac7e6080e392811d5dc762a1927b61b716a1008b277ae30fafb59bf6f868d5476f0a085d997f4884d4a4beaf7d6b31368fee3b367c5cbe7f4d43f4f5f214e49d07d651ff178a3af5d286e474761c6c2e47fb7ac780a485adff8b2748c00f7ee05348b15599dd274e0202abf245b670d5b070d650f46cf351aa075943cce8597e7f0f63a31c934c09d044adf5bd03cbca99fa65e97df881553653081fbae72ca0bf471bc96a25536fe6ef664560e07b0bc57d7a25e536b1c19546c6230aa33f31e97566d6e8460fecd7f8fdf75fae914ddc8dd6e6bc64afb05cc85545fd1a8afd40cc78316cff8a01356ffe43a0db24aa976f437594ebe0ddeb94c51bac27fe4369247f7e2ca0b1ef3d1ea7c9bea41ac005beee3ca9b64be6</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入邀请码阅读</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>虚幻</category>
      </categories>
      <tags>
        <tag>UE5</tag>
        <tag>Gameplay</tag>
      </tags>
  </entry>
  <entry>
    <title>虚幻编程准备之 宏定义的语法</title>
    <url>/2022/04/07/%E8%99%9A%E5%B9%BB%E7%BC%96%E7%A8%8B%E5%87%86%E5%A4%87%E4%B9%8B-%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>虚幻编程要面对的很大一部分代码都是用宏来书写的，包括整个虚幻的反射机制也是由宏来支撑的。</p>
<p>这里对宏来做一个简单的用法总结，主要还是针对C++和C的宏语法。</p>
<span id="more"></span>
<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9C%80%E7%AE%80%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%AE%8F">最简形式的宏</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89">定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="#%E8%BE%93%E5%87%BA">输出</a></li>
</ul>
</li>
<li><a href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E5%8D%95%E5%8F%82%E6%95%B0">带参数的宏(单参数)</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89-2">定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-2">使用</a></li>
<li><a href="#%E8%BE%93%E5%87%BA-2">输出</a></li>
</ul>
</li>
<li><a href="#%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%8F%E5%A4%9A%E5%8F%82%E6%95%B0">带参数的宏(多参数)</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89-3">定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-3">使用</a></li>
<li><a href="#%E8%BE%93%E5%87%BA-3">输出</a></li>
</ul>
</li>
<li><a href="#%E6%8D%A2%E8%A1%8C">换行</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89-4">定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-4">使用</a></li>
<li><a href="#%E8%BE%93%E5%87%BA-4">输出</a></li>
</ul>
</li>
<li><a href="#%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8">#号的使用</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89-5">定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-5">使用</a></li>
<li><a href="#%E8%BE%93%E5%87%BA-5">输出</a></li>
</ul>
</li>
<li><a href="#%E5%8F%B7%E7%9A%84%E4%BD%BF%E7%94%A8-2">##号的使用</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89-6">定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-6">使用</a></li>
<li><a href="#%E8%BE%93%E5%87%BA-6">输出</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E7%BD%AE%E7%9A%84%E5%AE%8F">内置的宏</a>
<ul>
<li><a href="#%E5%88%97%E4%B8%BE">列举</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-7">使用</a></li>
<li><a href="#%E8%BE%93%E5%87%BA-7">输出</a></li>
</ul>
</li>
</ul>
</p>
<h2 id="最简形式的宏"><a class="markdownIt-Anchor" href="#最简形式的宏"></a> 最简形式的宏</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> pi 3.14</span></span><br></pre></td></tr></table></figure>
<h3 id="使用"><a class="markdownIt-Anchor" href="#使用"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">funcSampleMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> pi * <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出"><a class="markdownIt-Anchor" href="#输出"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">31.4</span></span><br></pre></td></tr></table></figure>
<h2 id="带参数的宏单参数"><a class="markdownIt-Anchor" href="#带参数的宏单参数"></a> 带参数的宏(单参数)</h2>
<h3 id="定义-2"><a class="markdownIt-Anchor" href="#定义-2"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> func(x) (x * 2)</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-2"><a class="markdownIt-Anchor" href="#使用-2"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">funcParamerizedMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">func</span>(<span class="number">3.14</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-2"><a class="markdownIt-Anchor" href="#输出-2"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6.28</span></span><br></pre></td></tr></table></figure>
<h2 id="带参数的宏多参数"><a class="markdownIt-Anchor" href="#带参数的宏多参数"></a> 带参数的宏(多参数)</h2>
<h3 id="定义-3"><a class="markdownIt-Anchor" href="#定义-3"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST(...) t(##__VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">t</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用-3"><a class="markdownIt-Anchor" href="#使用-3"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">t</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">t</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">funcMultiParaMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TEST</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//float funcMultiParaMacro()</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//	return TEST(1, 2);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="输出-3"><a class="markdownIt-Anchor" href="#输出-3"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<h2 id="换行"><a class="markdownIt-Anchor" href="#换行"></a> 换行</h2>
<h3 id="定义-4"><a class="markdownIt-Anchor" href="#定义-4"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Wrap(functionName) float functionName()\</span></span><br><span class="line"><span class="meta">&#123;\</span></span><br><span class="line"><span class="meta">	return 3.14;\</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-4"><a class="markdownIt-Anchor" href="#使用-4"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Wrap</span>(unnamed)</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">funcWrapMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">unnamed</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-4"><a class="markdownIt-Anchor" href="#输出-4"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">3.14</span></span><br></pre></td></tr></table></figure>
<h2 id="号的使用"><a class="markdownIt-Anchor" href="#号的使用"></a> #号的使用</h2>
<p><code>#</code> 用来转化字符串</p>
<h3 id="定义-5"><a class="markdownIt-Anchor" href="#定义-5"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TOSTRING(x) #x</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-5"><a class="markdownIt-Anchor" href="#使用-5"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">funcToStringMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">TOSTRING</span>(hello world);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-5"><a class="markdownIt-Anchor" href="#输出-5"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="号的使用-2"><a class="markdownIt-Anchor" href="#号的使用-2"></a> ##号的使用</h2>
<p><code>##</code> 用来拼接</p>
<h3 id="定义-6"><a class="markdownIt-Anchor" href="#定义-6"></a> 定义</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> COMBINE(x,y) x##y</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-6"><a class="markdownIt-Anchor" href="#使用-6"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">string <span class="title">funcCombineMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">COMBINE</span>(func, <span class="built_in">ToStringMacro</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-6"><a class="markdownIt-Anchor" href="#输出-6"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>
<h2 id="内置的宏"><a class="markdownIt-Anchor" href="#内置的宏"></a> 内置的宏</h2>
<h3 id="列举"><a class="markdownIt-Anchor" href="#列举"></a> 列举</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__FILE__</span><br><span class="line">__LINE__</span><br><span class="line">__DATE__</span><br><span class="line">__TIME__</span><br><span class="line">__FUNCTION__</span><br></pre></td></tr></table></figure>
<h3 id="使用-7"><a class="markdownIt-Anchor" href="#使用-7"></a> 使用</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">funcBuildInMacro</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; __FILE__ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; __LINE__ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; __DATE__ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; __TIME__ &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; __FUNCTION__ &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="输出-7"><a class="markdownIt-Anchor" href="#输出-7"></a> 输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">E:\Project\CppResearchLoc\CppResearch\MacroResearch\Commen.h</span><br><span class="line"><span class="number">66</span></span><br><span class="line">Apr  <span class="number">7</span> <span class="number">2022</span></span><br><span class="line"><span class="number">16</span>:<span class="number">36</span>:<span class="number">28</span></span><br><span class="line">funcBuildInMacro</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>宏</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 111 二叉树的最小深度</title>
    <url>/2022/04/06/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%80%92%E5%BD%92">深度优先搜索（递归）</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
 <font color=#999AAA >
给定一个二叉树，找出其最小深度。
</font>
<font color=#999AAA >
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
</font>
<font color=#999AAA >
说明：叶子节点是指没有子节点的节点。
</font>
<ul>
<li>示例 1：<br />
输入：root = [3,9,20,null,null,15,7]<br />
输出：2</li>
<li>示例 2：<br />
输入：root = [2,null,3,null,4,null,5,null,6]<br />
输出：5</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先搜索递归"><a class="markdownIt-Anchor" href="#深度优先搜索递归"></a> 深度优先搜索（递归）</h2>
<p>该题目的重点是理解题意，为何“最近叶子节点”？叶子节点是树中某个左右子树均为空的节点，即只要只要该节点左右子树中某一个不为空的话，该节点即为叶子节点。此时可以依据情况具体讨论：</p>
<ul>
<li>当该节点为空时，该节点到最近叶子节点的距离为0；</li>
<li>当该节点的左右子树均为空时，该节点到最近叶子节点的距离为1；</li>
<li>当该节点的左右子树中其中一个为空另一个不为空时，该节点到最近叶子节点的距离为不为空的子树节点到其最近叶子节点的距离 + 1；</li>
<li>当该节点的左右子树均不为空时，该节点到最近叶子节点的距离为两个子树节点中距其最近叶子节点的较小者再 + 1；</li>
</ul>
<p>如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> || root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left) + <span class="built_in">minDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),<span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f6ab59ccb7d64b599de68a54ed75baba.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，h为二叉树的高度</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104 二叉树的最大深度</title>
    <url>/2022/04/05/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88">深度优先</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个二叉树，找出其最大深度。
</font>
<font color=#999AAA >
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
</font>
<font color=#999AAA >
说明: 叶子节点是指没有子节点的节点。
</font>
<ul>
<li>示例：<br />
给定二叉树 [3,9,20,null,null,15,7]，<br />
返回它的最大深度 3 。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先"><a class="markdownIt-Anchor" href="#深度优先"></a> 深度优先</h2>
<p>当前节点的最大深度就是左右子树中深度较大者再加上1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f558609051e24295838510b34d78197d.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(height)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>，height表示树的高度，最大可能是n</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101 对称二叉树</title>
    <url>/2022/04/05/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个二叉树的根节点 root ， 检查它是否轴对称。
</font>
<ul>
<li>示例 1：<br />
输入：root = [1,2,2,3,4,4,3]<br />
输出：true</li>
<li>示例 2：<br />
输入：root = [1,2,2,null,3,null,3]<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/symmetric-tree">https://leetcode-cn.com/problems/symmetric-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp;  <span class="built_in">check</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">check</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/10cd49e251a245018bb99f5ade67d0f1.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 100 相同的树</title>
    <url>/2022/04/05/LeetCode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%80%92%E5%BD%92">深度优先搜索（递归）</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
</font>
<font color=#999AAA >
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
</font>
<ul>
<li>示例 1：<br />
输入：p = [1,2,3], q = [1,2,3]<br />
输出：true</li>
<li>示例 2：<br />
输入：p = [1,2], q = [1,null,2]<br />
输出：false</li>
<li>示例 3：<br />
输入：p = [1,2,1], q = [1,1,2]<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/same-tree">https://leetcode-cn.com/problems/same-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先搜索递归"><a class="markdownIt-Anchor" href="#深度优先搜索递归"></a> 深度优先搜索（递归）</h2>
<p>先试着想想如何判断其中某个节点是否相等：判断其值是否相等 &amp;&amp; 判断其左子节点的值是否相等 &amp;&amp; 判断其右子节点的值是否相等。其中当要判断的两者中某个节点为空时，或者都为空时，可以不用判断相等而提前进行判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/274003d717384a2f82c989cd6e5345fd.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，取决于两树中最小的那个的大小<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 94 二叉树的中序遍历</title>
    <url>/2022/04/05/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个二叉树的根节点 root ，返回它的 中序 遍历。
</font>
<ul>
<li>示例 1：<br />
输入：root = [1,null,2,3]<br />
输出：[1,3,2]</li>
<li>示例 2：<br />
输入：root = []<br />
输出：[]</li>
<li>示例 3：<br />
输入：root = [1]<br />
输出：[1]</li>
<li>示例 4：<br />
输入：root = [1,2]<br />
输出：[2,1]</li>
<li>示例 5：<br />
输入：root = [1,null,2]<br />
输出：[1,2]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>中序遍历是左中右，即左子节点-&gt;当前节点-&gt;右子节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">recurve</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recurve</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">recurve</span>(root-&gt;left, v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">recurve</span>(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/30d5641c3f124aaf8d4d9c438c5cde91.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，遍历节点的复杂度<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，用分配空间存储结果，同时也需要分配相应的递归栈。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 88 合并两个有序数组</title>
    <url>/2022/04/05/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
</font>
<font color=#999AAA >
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
</font>
<font color=#999AAA >
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
</font>
<ul>
<li>示例 1：<br />
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br />
输出：[1,2,2,3,5,6]<br />
解释：需要合并 [1,2,3] 和 [2,5,6] 。<br />
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</li>
<li>示例 2：<br />
输入：nums1 = [1], m = 1, nums2 = [], n = 0<br />
输出：[1]<br />
解释：需要合并 [1] 和 [] 。<br />
合并结果是 [1] 。</li>
<li>示例 3：<br />
输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br />
输出：[1]<br />
解释：需要合并的数组是 [] 和 [1] 。<br />
合并结果是 [1] 。<br />
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array">https://leetcode-cn.com/problems/merge-sorted-array</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h2>
<p>利用两个指针分别遍历两个数组，比较指向的数据的大小，直到其中一方遍历完成，再把剩余数据填充完整即可。这里需要借助辅助数组空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums1_index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nums2_index = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vtemp</span><span class="params">(m+n)</span></span>;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (nums1_index &lt; m || nums2_index &lt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1_index == m) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[nums2_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums2_index == n) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[nums1_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[nums1_index] &lt; nums2[nums2_index]) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[nums1_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[nums2_index++];</span><br><span class="line">            &#125;</span><br><span class="line">            vtemp[nums1_index + nums2_index - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m + n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i] = vtemp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/0e6e0fc1d200457b88a2d5e22829fee8.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，遍历的代价<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，辅助数据空间的代价</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 83 删除排序链表中的重复元素</title>
    <url>/2022/04/05/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E9%81%8D%E5%8E%86">双指针遍历</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。
</font>
<ul>
<li>
<p>示例 1：<br />
输入：head = [1,1,2]<br />
输出：[1,2]</p>
</li>
<li>
<p>示例 2：<br />
输入：head = [1,1,2,3,3]<br />
输出：[1,2,3]</p>
</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="双指针遍历"><a class="markdownIt-Anchor" href="#双指针遍历"></a> 双指针遍历</h2>
<p>用一个指针pre指向前一个节点，然后用另一个指针cur进行链表的遍历，当cur的值和pre的值相同时，进行链表节点的删除。当cur指针为空时，说明遍历进行到了链表的结尾。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == pre-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e67b92d80e834fdbacb2e746d76feda9.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 70 爬楼梯</title>
    <url>/2022/04/05/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
</font>
<font color=#999AAA >
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
</font>
<ul>
<li>示例 1：<br />
输入：n = 2<br />
输出：2<br />
解释：有两种方法可以爬到楼顶。</li>
</ul>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<ul>
<li>示例 2：<br />
输入：n = 3<br />
输出：3<br />
解释：有三种方法可以爬到楼顶。</li>
</ul>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>每一层楼梯，基本都有两种方式可以到达：从前一阶过来，或者从前两阶过来。如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n<span class="number">-1</span>) + <span class="built_in">climbStairs</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，爆栈了。<br />
<img src="https://img-blog.csdnimg.cn/d7d6a1363ca241bc91d94ac06f7a4320.png" alt="在这里插入图片描述" /></p>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>先预先分配好内存，将求取的值存入到内存中，直到找到目标值对应的数目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        v[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i] = v[i<span class="number">-1</span>] + v[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2a9c86691e844d9e9b03bb365eddddf4.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 69 x的平方根</title>
    <url>/2022/04/05/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE">暴力枚举</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%B3%95">二分法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
</font> 
<font color=#999AAA >
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
</font> 
<font color=#999AAA >
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
</font> 
<ul>
<li>示例 1：<br />
输入：x = 4<br />
输出：2</li>
<li>示例 2：<br />
输入：x = 8<br />
输出：2<br />
解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/sqrtx">https://leetcode-cn.com/problems/sqrtx</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力枚举"><a class="markdownIt-Anchor" href="#暴力枚举"></a> 暴力枚举</h2>
<p>已知x是非负整数，那么一定有要求的平方根小于x，所以可以从0开始遍历，直到找到平方后大于x的值，再在这个值上减去1即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> seed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="type">long</span> <span class="type">long</span>)seed * seed &lt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            seed ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seed - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/10cd7c75f6b545eda47b5d25c9daaf98.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，从0到x遍历<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h2>
<p>从暴力枚举出发进行优化，利用二分法找目标值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="type">int</span> seed = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid &lt;= x) </span><br><span class="line">            &#123;</span><br><span class="line">                seed = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6d510435d4e0498f9bb6a91e4c9ff61d.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 67 二进制求和</title>
    <url>/2022/04/05/LeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%85%A7%E6%8A%84">照抄</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两个二进制字符串，返回它们的和（用二进制表示）。
</font> 
<font color=#999AAA >
输入为 非空 字符串且只包含数字 1 和 0。
</font> 
<ul>
<li>示例 1:<br />
输入: a = “11”, b = “1”<br />
输出: “100”</li>
<li>示例 2:<br />
输入: a = “1010”, b = “1011”<br />
输出: “10101”</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/add-binary">https://leetcode-cn.com/problems/add-binary</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="照抄"><a class="markdownIt-Anchor" href="#照抄"></a> 照抄</h2>
<p>凹了几天，最后还是照抄了官方给的做法，即先把字符串反过来（reverse()s函数），然后再把最后得到的结果反过来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((carry % <span class="number">2</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5105d7414e9b484388d28a964d733a66.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 66 加一</title>
    <url>/2022/04/05/LeetCode-66-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%BE%AA%E7%8E%AF%E8%BF%9B%E4%BD%8D">循环进位</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
</font> 
<font color=#999AAA >
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
</font> 
<font color=#999AAA >
你可以假设除了整数 0 之外，这个整数不会以零开头。
</font> 
<p>示例 1：</p>
<p>输入：digits = [1,2,3]<br />
输出：[1,2,4]<br />
解释：输入数组表示数字 123。<br />
示例 2：</p>
<p>输入：digits = [4,3,2,1]<br />
输出：[4,3,2,2]<br />
解释：输入数组表示数字 4321。<br />
示例 3：</p>
<p>输入：digits = [0]<br />
输出：[1]</p>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/plus-one">https://leetcode-cn.com/problems/plus-one</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="循环进位"><a class="markdownIt-Anchor" href="#循环进位"></a> 循环进位</h2>
<p>从数组最后一位开始遍历，如果有进位的话则继续下一位加一，最后需要在循环结束时判断是否还有进位，有的话则需要重新申请内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = end; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vtemp;</span><br><span class="line">            vtemp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                vtemp.<span class="built_in">push_back</span>(digits[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vtemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e7df2a129b68411fa582bec0b19b1a7b.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 58 最后一个单词的长度</title>
    <url>/2022/04/05/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E9%81%8D%E5%8E%86">暴力遍历</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。
</font> 
<font color=#999AAA >
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
</font> 
<ul>
<li>示例 1：<br />
输入：s = “Hello World”<br />
输出：5<br />
解释：最后一个单词是“World”，长度为5。</li>
<li>示例 2：<br />
输入：s = &quot;   fly me   to   the moon  &quot;<br />
输出：4<br />
解释：最后一个单词是“moon”，长度为4。</li>
<li>示例 3：<br />
输入：s = “luffy is still joyboy”<br />
输出：6<br />
解释：最后一个单词是长度为6的“joyboy”。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/length-of-last-word">https://leetcode-cn.com/problems/length-of-last-word</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力遍历"><a class="markdownIt-Anchor" href="#暴力遍历"></a> 暴力遍历</h2>
<p>从最后一位开始找起，当该位上字符不为空格时，开始计数，等到找到边界时，返回找到的不为空格的字符数。这里的边界可能是字符串的开头，也有可能是字符串中间的某个位置，即该字符不为空格，而前一个字符为空格，即为边界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4626a0f21a4d4004b64f278109f84268.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 53 最大子数组和</title>
    <url>/2022/04/05/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
</font> 
<font color=#999AAA >
子数组 是数组中的一个连续部分。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br />
输出：6<br />
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</li>
<li>示例 2：<br />
输入：nums = [1]<br />
输出：1</li>
<li>示例 3：<br />
输入：nums = [5,4,-1,7,8]<br />
输出：23</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>从第一位开始，我们找以该元素为结尾的最大子数组和，然后找出所有这些子数组和中最大的即可。这个问题的关键就是要紧紧围绕这个元素展开，不论我们如何运算，比较的内容中一定要包含这个元素，因为现在的子目标是要找的是<strong>以该元素为结尾的最大子数组和</strong>，可以想到，可以比较前一子数组和加上当前元素与当前元素进行比较，取二者中较大的一个，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)=max(f(i−1)+nums[i],nums[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxSubSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSubSum = <span class="built_in">max</span>(maxSubSum + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, maxSubSum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f48544a31b8f4647bfd81476eb0fc87e.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 35 搜索插入位置</title>
    <url>/2022/04/05/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C%E5%88%86%E6%B3%95">二分法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
</font> 
<font color=#999AAA >
请必须使用时间复杂度为 O(log n) 的算法。
</font> 
<ul>
<li>示例 1:<br />
输入: nums = [1,3,5,6], target = 5<br />
输出: 2</li>
<li>示例 2:<br />
输入: nums = [1,3,5,6], target = 2<br />
输出: 1</li>
<li>示例 3:<br />
输入: nums = [1,3,5,6], target = 7<br />
输出: 4</li>
<li>示例 4:<br />
输入: nums = [1,3,5,6], target = 0<br />
输出: 0</li>
<li>示例 5:<br />
输入: nums = [1], target = 0<br />
输出: 0</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/search-insert-position">https://leetcode-cn.com/problems/search-insert-position</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h2>
<p>直接使用二分法的话，查找到的条件是目标值和数组中元素相等；但是这里题目中描述的是数组中可能不存在与目标值相等的元素，此时的操作是返回插入该元素的位置，所以可以略微修改二分查找的条件：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>&gt;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[right - 1] &lt; target \leq nums[right]\\
left &gt; right
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5c34cef07cbe454d881c9888397ea254.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：数组二分，复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，也符合题目要求<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 28 实现strStr()</title>
    <url>/2022/04/05/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D">暴力匹配</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
实现 strStr() 函数。
</font> 
<font color=#999AAA >
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
</font> 
<font color=#999AAA >
说明：
</font> 
<font color=#999AAA >
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
</font> 
<font color=#999AAA >
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
</font> 
<ul>
<li>示例 1：<br />
输入：haystack = “hello”, needle = “ll”<br />
输出：2</li>
<li>示例 2：<br />
输入：haystack = “aaaaa”, needle = “bba”<br />
输出：-1</li>
<li>示例 3：<br />
输入：haystack = “”, needle = “”<br />
输出：0</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/implement-strstr">https://leetcode-cn.com/problems/implement-strstr</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力匹配"><a class="markdownIt-Anchor" href="#暴力匹配"></a> 暴力匹配</h2>
<p>匹配的实质是找出长字符串中的短字符串部分，所以可以枚举所有长字符串中的长度为短字符串长度的子字符串与短字符串进行匹配，如果匹配结果合适，则返回首字符下标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lenHay = haystack.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> lenNeedle = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (lenNeedle == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenHay - lenNeedle + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i + j &lt; lenHay &amp;&amp; j &lt; lenNeedle; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == lenNeedle - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/424b30b4772740d295f4c50a80d67ffe.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，极端情况下需要挨个对两个字符串进行匹配<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 27 移除元素</title>
    <url>/2022/04/05/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95">快慢指针解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
</font> 
<font color=#999AAA >
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
</font> 
<font color=#999AAA >
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [3,2,2,3], val = 3<br />
输出：2, nums = [2,2]<br />
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</li>
<li>示例 2：<br />
输入：nums = [0,1,2,2,3,0,4,2], val = 2<br />
输出：5, nums = [0,1,4,0,3]<br />
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="快慢指针解法"><a class="markdownIt-Anchor" href="#快慢指针解法"></a> 快慢指针解法</h2>
<p>分别设定快慢指针，快指针进行数组的遍历，慢指针负责维护“不等于目标元素的元素的数组”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> slowptr = <span class="number">-1</span>, quickptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; quickptr &lt; len; quickptr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[quickptr] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++slowptr] = nums[quickptr];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowptr + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4c834f280a3545fe9dc9a45f5779603a.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 26 删除有序数组中的重复项</title>
    <url>/2022/04/05/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%80%9F%E5%8A%A9%E8%BE%85%E5%8A%A9%E7%A9%BA%E9%97%B4">借助辅助空间</a></li>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95">快慢指针解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
</font> 
<font color=#999AAA >
由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
</font> 
<font color=#999AAA >
将最终结果插入 nums 的前 k 个位置后返回 k 。
</font> 
<font color=#999AAA >
不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [1,1,2]<br />
输出：2, nums = [1,2,_]<br />
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</li>
<li>示例 2：<br />
输入：nums = [0,0,1,1,1,2,2,3,3,4]<br />
输出：5, nums = [0,1,2,3,4]<br />
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="借助辅助空间"><a class="markdownIt-Anchor" href="#借助辅助空间"></a> 借助辅助空间</h2>
<p>对数组中元素遍历，当当前元素与前一个元素不等时，则判断其为新元素，加入到辅助数组空间中，直到遍历数组结束。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = res;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/642a1ed90cec498f9351b2905aabc413.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：申请了额外的数组空间，最大可能和原数组同样大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h2 id="快慢指针解法"><a class="markdownIt-Anchor" href="#快慢指针解法"></a> 快慢指针解法</h2>
<p>分别设定快慢指针，快指针进行数组的遍历，寻找“新元素”，而慢指针负责将不同的元素存储起来，即当快指针找到一个不同的元素时，将其覆盖掉慢指针指向元素的后一位，这样就相当于利用慢指针在维护一个无重复项的数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> slowPtr = <span class="number">0</span>, quickPtr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; quickPtr &lt; len; quickPtr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[quickPtr] != nums[quickPtr<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++slowPtr] = nums[quickPtr];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowPtr + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/321f3940a5044a20abdd8c79480d81e0.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 21 合并两个有序链表</title>
    <url>/2022/04/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%93%BE%E8%A1%A8%E9%A1%BA%E5%BA%8F%E6%9E%9A%E4%B8%BE">链表顺序枚举</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95">递归解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
</font> 
<ul>
<li>示例 1：<br />
输入：l1 = [1,2,4], l2 = [1,3,4]<br />
输出：[1,1,2,3,4,4]</li>
<li>示例 2：<br />
输入：l1 = [], l2 = []<br />
输出：[]</li>
<li>示例 3：<br />
输入：l1 = [], l2 = [0]<br />
输出：[0]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="链表顺序枚举"><a class="markdownIt-Anchor" href="#链表顺序枚举"></a> 链表顺序枚举</h2>
<p>按顺序对两链表的当前node进行数值的比对，符合条件者入新链表，并找该node的next继续进行这个比对操作，直到其中一个链表到头。此时将未遍历完的链接合到已有链上即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* curr = preHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                curr-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                curr-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr-&gt; next = list1 == <span class="literal">nullptr</span> ? list2:list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/54473df4dc834d8aa6d5db8b27be7a3b.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历两链表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="递归解法"><a class="markdownIt-Anchor" href="#递归解法"></a> 递归解法</h2>
<p>递归的理解是，求两个链表的合并，即是每个节点后接上该节点的后续链和另外一条链的合并。递归终止条件是其中一条链为空，此时返回另外一条链。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/206ec42b1aed4076b61fb7397c69e982.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历两链表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(n,m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，需要用到函数堆栈，容量与两链表的长度相关，最小函数堆栈为两个链表中较短的那一条的大小，最大即需要一直将所有节点都遍历一遍，此时函数堆栈大小为n+m。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 20 有效的括号</title>
    <url>/2022/04/05/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
</font>
<font color=#999AAA >
有效字符串需满足：
</font>
<font color=#999AAA >
左括号必须用相同类型的右括号闭合。
</font>
<font color=#999AAA >
左括号必须以正确的顺序闭合。
</font> 
<ul>
<li>示例 1：<br />
输入：s = “()”<br />
输出：true</li>
<li>示例 2：<br />
输入：s = “()[]{}”<br />
输出：true</li>
<li>示例 3：<br />
输入：s = “(]”<br />
输出：false</li>
<li>示例 4：<br />
输入：s = “([)]”<br />
输出：false</li>
<li>示例 5：<br />
输入：s = “{[]}”<br />
输出：true</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>可以利用一个栈结构来进行括号的存储，即遍历字符串，在遇到左括号（不论是哪一个），都进栈处理，而一旦遇到右括号，就和栈顶进行比对，不匹配说明不符合要求，则返回false，匹配的话则进行出栈，再继续进行判断。</p>
<p>值得注意的是这里的第二的条件“左括号必须以正确的顺序闭合”，即当遍历遇到右括号时，此时栈顶必须得是相应左括号才行，否则就不可能是以正确得顺序闭合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sta.<span class="built_in">empty</span>() || !<span class="built_in">isParaMatch</span>(sta.<span class="built_in">top</span>(), s[i])) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sta.<span class="built_in">empty</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isParaMatch</span><span class="params">(<span class="type">char</span> l, <span class="type">char</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2840a078c7a54fa69b822586adb95020.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组及字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，即栈的可能最大长度</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 14 最长公共前缀</title>
    <url>/2022/04/05/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
编写一个函数来查找字符串数组中的最长公共前缀。
</font>
<font color=#999AAA >
如果不存在公共前缀，返回空字符串 ""。
</font>
<ul>
<li>示例 1：<br />
输入：strs = [“flower”,“flow”,“flight”]<br />
输出：“fl”</li>
<li>示例 2：<br />
输入：strs = [“dog”,“racecar”,“car”]<br />
输出：&quot;&quot;<br />
解释：输入不存在公共前缀。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix">https://leetcode-cn.com/problems/longest-common-prefix</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>可以实现一个方法在两个字符串间寻找最长公共前缀，即按位比较，直到不一致时跳出，即可得到最长公共前缀。然后用这个得到的串再和数组内其他的字符串求最长公共前缀，直到遍历数组结束。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">getCommonPrefix</span>(res, strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getCommonPrefix</span><span class="params">(string str00, string str01)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len00 = str00.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len01 = str01.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len = len00 &lt;= len01 ? len00 : len01;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str00[i] == str01[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res += str00[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/91d589b02e9d4f44a61d3e3f4ea709ac.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组及字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，m表示单个字符串长度，n表示数组大小<br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，借助了临时字符串作存储</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 13 罗马数字转整数</title>
    <url>/2022/04/05/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
</font>
<table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:center">数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>V</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>X</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>L</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td>C</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td>D</td>
<td style="text-align:center">500</td>
</tr>
<tr>
<td>M</td>
<td style="text-align:center">1000</td>
</tr>
</tbody>
</table>
  <font color=#999AAA >
  例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
  </font>
<font color=#999AAA >
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
</font>
<font color=#999AAA >
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
</font>
<font color=#999AAA >
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
</font>
<font color=#999AAA >
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
</font>
<font color=#999AAA >
给定一个罗马数字，将其转换成整数。
</font>
<ul>
<li>示例 1:<br />
输入: s = “III”<br />
输出: 3</li>
<li>示例 2:<br />
输入: s = “IV”<br />
输出: 4</li>
<li>示例 3:<br />
输入: s = “IX”<br />
输出: 9</li>
<li>示例 4:<br />
输入: s = “LVIII”<br />
输出: 58<br />
解释: L = 50, V= 5, III = 3.</li>
<li>示例 5:<br />
输入: s = “MCMXCIV”<br />
输出: 1994<br />
解释: M = 1000, CM = 900, XC = 90, IV = 4.</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/roman-to-integer">https://leetcode-cn.com/problems/roman-to-integer</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>除了特殊情况以外（4，9，40，90等），这里的核心其实就是累加，如VII，就是5+1+1 = 7，即可以通过遍历字符串来将每个字符对应的值找到并累加。其实可以将特殊情况也用这样的方法的看，比如IV，就是在找到字符对应的值的时候，与后一位（如果存在的话）的对应的值进行比较，如果小于的话，那么就可以将该位上的值取反，即-1 + 5 = 4。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="built_in">getSingleInt</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; len &amp;&amp; temp &lt; <span class="built_in">getSingleInt</span>(s[i+<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                temp = <span class="number">0</span> - temp;</span><br><span class="line">            &#125;</span><br><span class="line">            res += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSingleInt</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6e92fbab0fe049ce90a949a95723c496.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 9 回文数</title>
    <url>/2022/04/05/LeetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">暴力解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
</font>
<font color=#999AAA >
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。
</font>
<ul>
<li>示例 1：<br />
输入：x = 121<br />
输出：true</li>
<li>示例 2：<br />
输入：x = -121<br />
输出：false<br />
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</li>
<li>示例 3：<br />
输入：x = 10<br />
输出：false<br />
解释：从右向左读, 为 01 。因此它不是一个回文数。</li>
<li>示例 4：<br />
输入：x = -101<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/palindrome-number">https://leetcode-cn.com/problems/palindrome-number</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力解法"><a class="markdownIt-Anchor" href="#暴力解法"></a> 暴力解法</h2>
<p>将各位上的数字依次输出，然后按照顺序进行比对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arrPalindrome;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x%<span class="number">10</span> != <span class="number">0</span> || x/<span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">            arrPalindrome.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = arrPalindrome.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrPalindrome[i] != arrPalindrome[len <span class="number">-1</span> - i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/abb8239a33f54bd7875a5f50b3dfc52c.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn + \frac{1}{2}logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：开辟辅助数组所出现的消耗，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1 两数之和</title>
    <url>/2022/04/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE">暴力枚举</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8C%96%E5%81%9A%E6%B3%95">基于哈希表的优化做法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。
</font>
<font color=#999AAA >
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。
</font>
<ul>
<li>
<p>示例 1：<br />
输入：nums = [2,7,11,15], target = 9<br />
输出：[0,1]<br />
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
</li>
<li>
<p>示例 2：<br />
输入：nums = [3,2,4], target = 6<br />
输出：[1,2]</p>
</li>
<li>
<p>示例 3：<br />
输入：nums = [3,3], target = 6<br />
输出：[0,1]</p>
</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力枚举"><a class="markdownIt-Anchor" href="#暴力枚举"></a> 暴力枚举</h2>
<p>按照下标从小往大的顺序，将数组中任意两数两两组合，以枚举出所有的可能性，从而检查两数字之和是否与目标值相等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/50fc18cd45ff4f3ba2a3ac31c487e401.png" alt="在这里插入图片描述" /><br />
复杂度分析<br />
时间复杂度：最坏情况下（符合要求两数字的下标位于数组的末尾），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="基于哈希表的优化做法"><a class="markdownIt-Anchor" href="#基于哈希表的优化做法"></a> 基于哈希表的优化做法</h2>
<p>利用哈希表的特性（查找快速），在遍历数组的同时，检查每个元素达成目标值所需要的另一元素是否存在于哈希表中，从而实现在遍历一遍数组的前提下，就能够找出符合要求的两个数组元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator iter = hashMap.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != hashMap.<span class="built_in">end</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, iter-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/1e538207d91a4d198ab33ad1e016203f.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，对每个元素需要以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的代价来判断是否存在另一个元素<br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，主要是用来开辟哈希表空间</p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
      <categories>
        <category>LeetCode</category>
        <category>easy</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>算法</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 纹理的处理（Texturing）</title>
    <url>/2022/03/30/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BA%B9%E7%90%86%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%88Texturing%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 着色基础（Shading Basics）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%9D%80%E8%89%B2%E5%9F%BA%E7%A1%80%EF%BC%88Shading-Basics%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 变换（Transforms）</title>
    <url>/2022/03/30/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E6%8D%A2%EF%BC%88Transforms%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 图形处理单元（The Graphics Processing Unit）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83%EF%BC%88The-Graphics-Processing-Unit%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 图形渲染管线（The Graphics Rendering Pipeline）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%88The-Graphics-Rendering-Pipeline%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 介绍（Introduction）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%8B%E7%BB%8D%EF%BC%88Introduction%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>渲染</category>
        <category>Real-Time Rendering 4th Edition 读书与翻译</category>
      </categories>
      <tags>
        <tag>渲染管线</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>快速建站方案（hexo + next）全面记录</title>
    <url>/2022/03/23/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>本文记录了笔者在搭建 <a href="https://claude-jhin.github.io">个人博客网站</a> 时所经历的过程，包含整个流程和中间遇到的一些麻烦。<br />
这里记录下来，作为自己一个阶段对网站开发学习的总结，并且如果能够帮助或者启发更多的人，也将不胜荣幸。<br />
当然，笔者并不是专业的前端开发人员，前端开发只是作为工具而去粗浅的使用，所以在一些细节上难以尽善尽美。</p>
<span id="more"></span>
<p>本文仅是对工具浮于表面的粗浅使用，更多的信息还是请参考备注的各种官方链接。</p>
<h3 id="hexo简介"><a class="markdownIt-Anchor" href="#hexo简介"></a> Hexo简介</h3>
<p>依据 <a href="https://hexo.io/zh-cn">Hexo中文官网</a> 中的介绍，Hexo是一个快速、简洁且高效的博客框架。<br />
最直观的，在这套框架的帮助下，我们可以很快的通过markdown来完成一篇又一篇博客的编辑。<br />
此外，Hexo也是可扩展的，在各种各样插件的帮助下，可以实现多种多样的前端效果。</p>
<h3 id="next简介"><a class="markdownIt-Anchor" href="#next简介"></a> next简介</h3>
<p>next是Hexo丰富多彩的主题中比较受欢迎的一个，其本身是一个 <a href="https://github.com/next-theme/hexo-theme-next">开源的项目</a> 到现在一直在不断得推出新的版本。</p>
<p>如果说Hexo是对前端开发的简化和封装，那么next就是对hexo框架允许内的前端效果的封装。<br />
在这两者的帮助下，降低了开发难度，让使用者可以仅仅通过简单的配置就可以拥有和维护属于自己的博客网站。</p>
<h2 id="本地基础开发环境准备"><a class="markdownIt-Anchor" href="#本地基础开发环境准备"></a> 本地基础开发环境准备</h2>
<ul>
<li><a href="https://nodejs.org/">Node.js</a></li>
</ul>
<p>下载后依据导航安装即可，推荐下载长期支持版（LTS）。</p>
<ul>
<li><a href="https://git-scm.com/">Git</a></li>
</ul>
<p>下载后依据导航安装即可，Git安装过程中会有很多的配置选项，如果有特定需求的话（了解其各个配置选项的含义）可以按需配置，否则就按照推荐选项进行安装即可。</p>
<p>安装完成后，右键的下拉菜单中就会出现Git相关的功能选项。</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_rightclick.png" alt="" /></p>
<h2 id="hexo环境搭建"><a class="markdownIt-Anchor" href="#hexo环境搭建"></a> hexo环境搭建</h2>
<p>在基本环境准备完成后，即可开始hexo相关的下载和安装。</p>
<p>在预先准备好的文件夹下（如 E:/Blog/），右键打开下拉菜单，点击Git Bash Here，输入下面的命令后点击回车键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_gitbush.png" alt="" /></p>
<p>完成后，再执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>完成后，对应文件夹中出现内容，目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>以上各文件各有作用，和我们博客最后的表现息息相关，在具体配置和使用时我们再做详细介绍。</p>
<p>最后执行以下命令完成配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>在等待上述命令执行完成后，可以在命令行键入以下命令启动hexo服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>此时，本地服务启动成功，可以在浏览器中键入<code>http://localhost:4000/</code> 来尝试访问默认的博客模板，<br />
出现以下页面即表示着前面的安装过程没有出现问题：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_defaultpage.png" alt="" /></p>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>在文件夹中找到 <code>_config.yml</code> 文件，该文件即是博客的主要配置文件，其中包含了绝大部分关于网站的我们可以自定义的部分。</p>
<p>预想要完成博客的个性化定制，需要对该文件各个部分的配置内容有个大概的了解。这里罗列一些核心部分，剩余部分的配置建议参考 <a href="https://hexo.io/zh-cn/docs/configuration">官方网站的内容</a> 。</p>
<p>当然，如果对美观和个性化没有需求的话，这一小节可以暂时先掠过，先进行后面的阅读。</p>
<h3 id="site"><a class="markdownIt-Anchor" href="#site"></a> Site</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: </span><br><span class="line">subtitle: </span><br><span class="line">description: </span><br><span class="line">keywords: </span><br><span class="line">author: </span><br><span class="line">language: </span><br><span class="line">timezone: </span><br></pre></td></tr></table></figure>
<p>这里是网站的一些主要属性的配置，其中各项代表的含义为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">网站标题</td>
</tr>
<tr>
<td style="text-align:center">subtitle</td>
<td style="text-align:center">网站副标题</td>
</tr>
<tr>
<td style="text-align:center">description</td>
<td style="text-align:center">网站描述</td>
</tr>
<tr>
<td style="text-align:center">keywords</td>
<td style="text-align:center">网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td style="text-align:center">author</td>
<td style="text-align:center">您的名字</td>
</tr>
<tr>
<td style="text-align:center">language</td>
<td style="text-align:center">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</td>
</tr>
<tr>
<td style="text-align:center">timezone</td>
<td style="text-align:center">网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</td>
</tr>
</tbody>
</table>
<h3 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https://claude-jhin.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure>
<p>这里是关于网站url的一些配置相关的内容，主要作用是对url进行美化。</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">后键入自己准备好的域名，我这里使用的是github提供的免费域名。</td>
</tr>
<tr>
<td style="text-align:center">permalink</td>
<td style="text-align:center">表示的是每一个我们编辑的markdown博客文件应该是以什么样子的域名来显示的，默认是以年+月+日+文章名字的形式。</td>
</tr>
<tr>
<td style="text-align:center">permalink_defaults</td>
<td style="text-align:center">是对permalink给出一个默认值。</td>
</tr>
<tr>
<td style="text-align:center">trailing_index</td>
<td style="text-align:center">是否为博客文件保留<code>index.html</code> 的后缀</td>
</tr>
<tr>
<td style="text-align:center">trailing_html</td>
<td style="text-align:center">是否为博客文件保留<code>.html</code> 的后缀</td>
</tr>
</tbody>
</table>
<h3 id="home-page-setting"><a class="markdownIt-Anchor" href="#home-page-setting"></a> Home page setting</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;) 博客索引页的根目录</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination) 每一页显示的文章数量</span><br><span class="line"># order_by: Posts order. (Order by date descending by default) 文章的排序方式</span><br><span class="line">index_generator:</span><br><span class="line">path: &#x27;&#x27;</span><br><span class="line">per_page: 10</span><br><span class="line">order_by: -date</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">博客索引页的根目录</td>
</tr>
<tr>
<td style="text-align:center">per_page</td>
<td style="text-align:center">每一页显示的文章数量</td>
</tr>
<tr>
<td style="text-align:center">order_by</td>
<td style="text-align:center">文章的排序方式</td>
</tr>
</tbody>
</table>
<h3 id="extension"><a class="markdownIt-Anchor" href="#extension"></a> Extension</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">theme</td>
<td style="text-align:center">所选择的主题，主题下载后保存在根目录的themes文件夹下，通过这里指定加载的主题。</td>
</tr>
</tbody>
</table>
<h2 id="写作"><a class="markdownIt-Anchor" href="#写作"></a> 写作</h2>
<h3 id="创建文章"><a class="markdownIt-Anchor" href="#创建文章"></a> 创建文章</h3>
<p>新建文章的指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>其中 [layout] 默认有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">布局</th>
<th style="text-align:center">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">post</td>
<td style="text-align:center">source/_posts</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">source</td>
</tr>
<tr>
<td style="text-align:center">draft</td>
<td style="text-align:center">source/_drafts</td>
</tr>
</tbody>
</table>
<p>在创建这三种不同类型的文件时，它们将会被保存到不同的路径。但是默认来说我们基本只需要用到post，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new post &quot;文章名字&quot;</span><br></pre></td></tr></table></figure>
<p>执行上面命令后，在source/_posts文件夹下就会生成对应的md文件，按照md格式进行文档的编辑即可。</p>
<p>截取本文的编辑界面如下：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_content.png" alt="" /></p>
<h3 id="配置文章属性front-matter"><a class="markdownIt-Anchor" href="#配置文章属性front-matter"></a> 配置文章属性（Front-matter）</h3>
<p>与博客一样，每篇文章除了内容以外，还有自己的属性，如建立时间、更行时间、分类和标签等。</p>
<p>博客模板会利用这些属性来自动实现一些高级的功能，如显示博客文章时间戳，按照分类来讲文章进行归档等。<br />
post模板会自动帮助我们创建出title，date和tags，此外还有一些其他内容，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">标题</td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">文件建立日期</td>
</tr>
<tr>
<td style="text-align:center">updated</td>
<td style="text-align:center">更新日期	文件更新日期</td>
</tr>
<tr>
<td style="text-align:center">comments</td>
<td style="text-align:center">开启文章的评论功能（true/false）</td>
</tr>
<tr>
<td style="text-align:center">tags</td>
<td style="text-align:center">标签（不适用于分页）</td>
</tr>
<tr>
<td style="text-align:center">categories</td>
<td style="text-align:center">分类（不适用于分页）</td>
</tr>
</tbody>
</table>
<p>如本文的Front-matter：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 快速建站方案（hexo + next）全面记录</span><br><span class="line">date: 2022-03-23 21:35:53</span><br><span class="line">updated: 2022-03-24 20:00:00</span><br><span class="line">comments: true</span><br><span class="line">tags:</span><br><span class="line">  - 前端</span><br><span class="line">categories: </span><br><span class="line">  - hexo</span><br></pre></td></tr></table></figure>
<h2 id="next主题"><a class="markdownIt-Anchor" href="#next主题"></a> next主题</h2>
<h3 id="主题下载与加载"><a class="markdownIt-Anchor" href="#主题下载与加载"></a> 主题下载与加载</h3>
<p>在hexoblog文件夹下打开命令行，键入并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>等待完成后，有：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_nextexplorer.png" alt="" /></p>
<p>在hexoblog下的_config.yml里配置theme即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<h3 id="预览"><a class="markdownIt-Anchor" href="#预览"></a> 预览</h3>
<p>在hexoblog文件夹下打开命令行，键入并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>有：</p>
<p>![](快速建站全面记录_hexo s.png)</p>
<p>此时就可以在浏览器中用 <code>http://localhost:4000/</code> 的地址来进行访问了。</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_localhost.png" alt="" /></p>
<p>但是注意，此时我们只是开启了一个本地服务，就是说，只能在我们开启服务时，在本地机器上进行访问，还没有发布到网络上供别人来查看。</p>
<h2 id="github-page准备"><a class="markdownIt-Anchor" href="#github-page准备"></a> github page准备</h2>
<p>在github上新建一个仓库，进入到 <code>General/Code and automation/Pages</code> 配置界面：</p>
<p><img src="%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_githubpage.png" alt="" /></p>
<p>这里顺便需要去设置界面把SSH给配置了，方便后续的更新和维护，<a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh">具体操作</a> ，这里不做过多赘述。</p>
<p>下面就是把之前做的内容推送到远程仓库里。</p>
<h2 id="发布"><a class="markdownIt-Anchor" href="#发布"></a> 发布</h2>
<p>回到hexoblog文件夹下的_config.yml，将远程仓库相关内容键入（注意这里使用的是SSH地址）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Github用户名/Github用户名全小写.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>在hexoblog打开命令行，键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>生成静态页面内容后，再键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>如果是第一次的话，可能过程中还要填写github的用户名和密码，按导航完成即可。</p>
<p>等待完成后，过一段时间（取决于github的处理），访问仓库地址（如<code>https://claude-jhin.github.io/</code> ），可以看到本地仓库已经发布到了网页。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>到此，基本上完成了从零开始的一个博客搭建，当然对于有心人来讲，事情远远还没有完成。<br />
一篇篇博客的积累，一点点前端特性的尝试与引入，学习的乐趣，开发的乐趣，远不止于此。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>frontend</tag>
      </tags>
  </entry>
</search>
