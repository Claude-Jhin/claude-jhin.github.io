<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>欢迎来到Claude的个人博客</title>
    <url>/2022/03/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%B0%9D%E8%AF%95/</url>
    <content><![CDATA[<ul>
<li>Claude是谁？</li>
</ul>
<p>Claude是一名潜心游戏研发的开发者，致力于研究游戏开发中的种种技术，包括编程、渲染、动画、玩法等等。<br />
目前在做虚幻引擎的学习和研究，希望有一天能够引导做出自己的3A大作。</p>
<p>更多信息，可以点击右侧 <code>关于</code></p>
<ul>
<li>为什么要建立自己的博客网站呢？</li>
</ul>
<p>主要是希望能够通过这样一种方式作为自身能力的展示。作为游戏开发流水线中的程序一角，与策划和美术不同的是，程序除了游戏作品以外，很难拿出能够显示自身实力的东西，类似美术工作者的作品集和策划工作者的设定文案之类的。</p>
<p>所以自己这才想到去建立这样一个博客网站，一方面记录自己在游戏开发之路上所积累的技术点滴，另一方面也想要把一些东西共享出来。</p>
<p>此前自己已经在csdn和知乎上进行了一定量的博客文章撰写，但是考虑到有一些私人的东西希望自己管理，遂花了一些时间研究前端的内容，并且就一个方案（hexo框架）来实际落地自己的想法。</p>
<p>这第一篇文章，就把自己此时完成建站时的所思所想，记录下来。</p>
]]></content>
  </entry>
  <entry>
    <title>LeetCode 111 二叉树的最小深度</title>
    <url>/2022/04/06/LeetCode-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%80%92%E5%BD%92">深度优先搜索（递归）</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
 <font color=#999AAA >
给定一个二叉树，找出其最小深度。
</font>
<font color=#999AAA >
最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
</font>
<font color=#999AAA >
说明：叶子节点是指没有子节点的节点。
</font>
<ul>
<li>示例 1：<br />
输入：root = [3,9,20,null,null,15,7]<br />
输出：2</li>
<li>示例 2：<br />
输入：root = [2,null,3,null,4,null,5,null,6]<br />
输出：5</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">https://leetcode-cn.com/problems/minimum-depth-of-binary-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先搜索递归"><a class="markdownIt-Anchor" href="#深度优先搜索递归"></a> 深度优先搜索（递归）</h2>
<p>该题目的重点是理解题意，为何“最近叶子节点”？叶子节点是树中某个左右子树均为空的节点，即只要只要该节点左右子树中某一个不为空的话，该节点即为叶子节点。此时可以依据情况具体讨论：</p>
<ul>
<li>当该节点为空时，该节点到最近叶子节点的距离为0；</li>
<li>当该节点的左右子树均为空时，该节点到最近叶子节点的距离为1；</li>
<li>当该节点的左右子树中其中一个为空另一个不为空时，该节点到最近叶子节点的距离为不为空的子树节点到其最近叶子节点的距离 + 1；</li>
<li>当该节点的左右子树均不为空时，该节点到最近叶子节点的距离为两个子树节点中距其最近叶子节点的较小者再 + 1；</li>
</ul>
<p>如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> || root-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">minDepth</span>(root-&gt;left) + <span class="built_in">minDepth</span>(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(<span class="built_in">minDepth</span>(root-&gt;left),<span class="built_in">minDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f6ab59ccb7d64b599de68a54ed75baba.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span>，h为二叉树的高度</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 104 二叉树的最大深度</title>
    <url>/2022/04/05/LeetCode-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88">深度优先</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个二叉树，找出其最大深度。
</font>
<font color=#999AAA >
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
</font>
<font color=#999AAA >
说明: 叶子节点是指没有子节点的节点。
</font>
<ul>
<li>示例：<br />
给定二叉树 [3,9,20,null,null,15,7]，<br />
返回它的最大深度 3 。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先"><a class="markdownIt-Anchor" href="#深度优先"></a> 深度优先</h2>
<p>当前节点的最大深度就是左右子树中深度较大者再加上1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f558609051e24295838510b34d78197d.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>h</mi><mi>e</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(height)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>，height表示树的高度，最大可能是n</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 101 对称二叉树</title>
    <url>/2022/04/05/LeetCode-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个二叉树的根节点 root ， 检查它是否轴对称。
</font>
<ul>
<li>示例 1：<br />
输入：root = [1,2,2,3,4,4,3]<br />
输出：true</li>
<li>示例 2：<br />
输入：root = [1,2,2,null,3,null,3]<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/symmetric-tree">https://leetcode-cn.com/problems/symmetric-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* left, TreeNode* right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left-&gt;val == right-&gt;val &amp;&amp;  <span class="built_in">check</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">check</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/10cd49e251a245018bb99f5ade67d0f1.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 100 相同的树</title>
    <url>/2022/04/05/LeetCode-100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%80%92%E5%BD%92">深度优先搜索（递归）</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。
</font>
<font color=#999AAA >
如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
</font>
<ul>
<li>示例 1：<br />
输入：p = [1,2,3], q = [1,2,3]<br />
输出：true</li>
<li>示例 2：<br />
输入：p = [1,2], q = [1,null,2]<br />
输出：false</li>
<li>示例 3：<br />
输入：p = [1,2,1], q = [1,1,2]<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/same-tree">https://leetcode-cn.com/problems/same-tree</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="深度优先搜索递归"><a class="markdownIt-Anchor" href="#深度优先搜索递归"></a> 深度优先搜索（递归）</h2>
<p>先试着想想如何判断其中某个节点是否相等：判断其值是否相等 &amp;&amp; 判断其左子节点的值是否相等 &amp;&amp; 判断其右子节点的值是否相等。其中当要判断的两者中某个节点为空时，或者都为空时，可以不用判断相等而提前进行判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">nullptr</span> &amp;&amp; q == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == <span class="literal">nullptr</span> || q == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val != q-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSameTree</span>(p-&gt;left, q-&gt;left) &amp;&amp; <span class="built_in">isSameTree</span>(p-&gt;right,q-&gt;right);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/274003d717384a2f82c989cd6e5345fd.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，取决于两树中最小的那个的大小<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(m,n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 94 二叉树的中序遍历</title>
    <url>/2022/04/05/LeetCode-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个二叉树的根节点 root ，返回它的 中序 遍历。
</font>
<ul>
<li>示例 1：<br />
输入：root = [1,null,2,3]<br />
输出：[1,3,2]</li>
<li>示例 2：<br />
输入：root = []<br />
输出：[]</li>
<li>示例 3：<br />
输入：root = [1]<br />
输出：[1]</li>
<li>示例 4：<br />
输入：root = [1,2]<br />
输出：[2,1]</li>
<li>示例 5：<br />
输入：root = [1,null,2]<br />
输出：[1,2]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">https://leetcode-cn.com/problems/binary-tree-inorder-traversal</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>中序遍历是左中右，即左子节点-&gt;当前节点-&gt;右子节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">recurve</span>(root, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recurve</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">recurve</span>(root-&gt;left, v);</span><br><span class="line">        v.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">recurve</span>(root-&gt;right, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/30d5641c3f124aaf8d4d9c438c5cde91.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，遍历节点的复杂度<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，用分配空间存储结果，同时也需要分配相应的递归栈。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 88 合并两个有序数组</title>
    <url>/2022/04/05/LeetCode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88">双指针</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。
</font>
<font color=#999AAA >
请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。
</font>
<font color=#999AAA >
注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。
</font>
<ul>
<li>示例 1：<br />
输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3<br />
输出：[1,2,2,3,5,6]<br />
解释：需要合并 [1,2,3] 和 [2,5,6] 。<br />
合并结果是 [1,2,2,3,5,6] ，其中斜体加粗标注的为 nums1 中的元素。</li>
<li>示例 2：<br />
输入：nums1 = [1], m = 1, nums2 = [], n = 0<br />
输出：[1]<br />
解释：需要合并 [1] 和 [] 。<br />
合并结果是 [1] 。</li>
<li>示例 3：<br />
输入：nums1 = [0], m = 0, nums2 = [1], n = 1<br />
输出：[1]<br />
解释：需要合并的数组是 [] 和 [1] 。<br />
合并结果是 [1] 。<br />
注意，因为 m = 0 ，所以 nums1 中没有元素。nums1 中仅存的 0 仅仅是为了确保合并结果可以顺利存放到 nums1 中。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/merge-sorted-array">https://leetcode-cn.com/problems/merge-sorted-array</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="双指针"><a class="markdownIt-Anchor" href="#双指针"></a> 双指针</h2>
<p>利用两个指针分别遍历两个数组，比较指向的数据的大小，直到其中一方遍历完成，再把剩余数据填充完整即可。这里需要借助辅助数组空间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nums1_index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nums2_index = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vtemp</span><span class="params">(m+n)</span></span>;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (nums1_index &lt; m || nums2_index &lt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1_index == m) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[nums2_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums2_index == n) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[nums1_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[nums1_index] &lt; nums2[nums2_index]) </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[nums1_index++];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[nums2_index++];</span><br><span class="line">            &#125;</span><br><span class="line">            vtemp[nums1_index + nums2_index - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i != m + n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i] = vtemp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/0e6e0fc1d200457b88a2d5e22829fee8.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，遍历的代价<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m+n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，辅助数据空间的代价</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 83 删除排序链表中的重复元素</title>
    <url>/2022/04/05/LeetCode-83-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8F%8C%E6%8C%87%E9%92%88%E9%81%8D%E5%8E%86">双指针遍历</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次 。返回 已排序的链表 。
</font>
<ul>
<li>
<p>示例 1：<br />
输入：head = [1,1,2]<br />
输出：[1,2]</p>
</li>
<li>
<p>示例 2：<br />
输入：head = [1,1,2,3,3]<br />
输出：[1,2,3]</p>
</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="双指针遍历"><a class="markdownIt-Anchor" href="#双指针遍历"></a> 双指针遍历</h2>
<p>用一个指针pre指向前一个节点，然后用另一个指针cur进行链表的遍历，当cur的值和pre的值相同时，进行链表节点的删除。当cur指针为空时，说明遍历进行到了链表的结尾。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ListNode* pre = head;</span><br><span class="line">        ListNode* cur = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;val == pre-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">                pre-&gt;next = cur;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e67b92d80e834fdbacb2e746d76feda9.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 70 爬楼梯</title>
    <url>/2022/04/05/LeetCode-70-%E7%88%AC%E6%A5%BC%E6%A2%AF/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%80%92%E5%BD%92">递归</a></li>
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
</font>
<font color=#999AAA >
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
</font>
<ul>
<li>示例 1：<br />
输入：n = 2<br />
输出：2<br />
解释：有两种方法可以爬到楼顶。</li>
</ul>
<ol>
<li>1 阶 + 1 阶</li>
<li>2 阶</li>
</ol>
<ul>
<li>示例 2：<br />
输入：n = 3<br />
输出：3<br />
解释：有三种方法可以爬到楼顶。</li>
</ul>
<ol>
<li>1 阶 + 1 阶 + 1 阶</li>
<li>1 阶 + 2 阶</li>
<li>2 阶 + 1 阶</li>
</ol>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/climbing-stairs">https://leetcode-cn.com/problems/climbing-stairs</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="递归"><a class="markdownIt-Anchor" href="#递归"></a> 递归</h2>
<p>每一层楼梯，基本都有两种方式可以到达：从前一阶过来，或者从前两阶过来。如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">climbStairs</span>(n<span class="number">-1</span>) + <span class="built_in">climbStairs</span>(n<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是，爆栈了。<br />
<img src="https://img-blog.csdnimg.cn/d7d6a1363ca241bc91d94ac06f7a4320.png" alt="在这里插入图片描述" /></p>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>先预先分配好内存，将求取的值存入到内存中，直到找到目标值对应的数目。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        v[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        v[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        v[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            v[i] = v[i<span class="number">-1</span>] + v[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2a9c86691e844d9e9b03bb365eddddf4.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 69 x的平方根</title>
    <url>/2022/04/05/LeetCode-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE">暴力枚举</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%B3%95">二分法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个非负整数 x ，计算并返回 x 的 算术平方根 。
</font> 
<font color=#999AAA >
由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。
</font> 
<font color=#999AAA >
注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。
</font> 
<ul>
<li>示例 1：<br />
输入：x = 4<br />
输出：2</li>
<li>示例 2：<br />
输入：x = 8<br />
输出：2<br />
解释：8 的算术平方根是 2.82842…, 由于返回类型是整数，小数部分将被舍去。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/sqrtx">https://leetcode-cn.com/problems/sqrtx</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力枚举"><a class="markdownIt-Anchor" href="#暴力枚举"></a> 暴力枚举</h2>
<p>已知x是非负整数，那么一定有要求的平方根小于x，所以可以从0开始遍历，直到找到平方后大于x的值，再在这个值上减去1即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> seed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="type">long</span> <span class="type">long</span>)seed * seed &lt;= x)</span><br><span class="line">        &#123;</span><br><span class="line">            seed ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seed - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/10cd7c75f6b545eda47b5d25c9daaf98.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，从0到x遍历<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h2>
<p>从暴力枚举出发进行优化，利用二分法找目标值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="type">int</span> seed = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)mid * mid &lt;= x) </span><br><span class="line">            &#123;</span><br><span class="line">                seed = mid;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> seed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6d510435d4e0498f9bb6a91e4c9ff61d.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 67 二进制求和</title>
    <url>/2022/04/05/LeetCode-67-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E7%85%A7%E6%8A%84">照抄</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你两个二进制字符串，返回它们的和（用二进制表示）。
</font> 
<font color=#999AAA >
输入为 非空 字符串且只包含数字 1 和 0。
</font> 
<ul>
<li>示例 1:<br />
输入: a = “11”, b = “1”<br />
输出: “100”</li>
<li>示例 2:<br />
输入: a = “1010”, b = “1011”<br />
输出: “10101”</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/add-binary">https://leetcode-cn.com/problems/add-binary</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="照抄"><a class="markdownIt-Anchor" href="#照抄"></a> 照抄</h2>
<p>凹了几天，最后还是照抄了官方给的做法，即先把字符串反过来（reverse()s函数），然后再把最后得到的结果反过来。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addBinary</span><span class="params">(string a, string b)</span> </span>&#123;</span><br><span class="line">        string ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">max</span>(a.<span class="built_in">size</span>(), b.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            carry += i &lt; a.<span class="built_in">size</span>() ? (a.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            carry += i &lt; b.<span class="built_in">size</span>() ? (b.<span class="built_in">at</span>(i) == <span class="string">&#x27;1&#x27;</span>) : <span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>((carry % <span class="number">2</span>) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            carry /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (carry) </span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">reverse</span>(ans.<span class="built_in">begin</span>(), ans.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5105d7414e9b484388d28a964d733a66.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 66 加一</title>
    <url>/2022/04/05/LeetCode-66-%E5%8A%A0%E4%B8%80/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%BE%AA%E7%8E%AF%E8%BF%9B%E4%BD%8D">循环进位</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
</font> 
<font color=#999AAA >
最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
</font> 
<font color=#999AAA >
你可以假设除了整数 0 之外，这个整数不会以零开头。
</font> 
<p>示例 1：</p>
<p>输入：digits = [1,2,3]<br />
输出：[1,2,4]<br />
解释：输入数组表示数字 123。<br />
示例 2：</p>
<p>输入：digits = [4,3,2,1]<br />
输出：[4,3,2,2]<br />
解释：输入数组表示数字 4321。<br />
示例 3：</p>
<p>输入：digits = [0]<br />
输出：[1]</p>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/plus-one">https://leetcode-cn.com/problems/plus-one</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="循环进位"><a class="markdownIt-Anchor" href="#循环进位"></a> 循环进位</h2>
<p>从数组最后一位开始遍历，如果有进位的话则继续下一位加一，最后需要在循环结束时判断是否还有进位，有的话则需要重新申请内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">plusOne</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = digits.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> end = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = end; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            digits[i] += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (digits[i] &gt;= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                digits[i] = digits[i] % <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; vtemp;</span><br><span class="line">            vtemp.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                vtemp.<span class="built_in">push_back</span>(digits[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> vtemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/e7df2a129b68411fa582bec0b19b1a7b.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 58 最后一个单词的长度</title>
    <url>/2022/04/05/LeetCode-58-%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E9%81%8D%E5%8E%86">暴力遍历</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个字符串 s，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 最后一个 单词的长度。
</font> 
<font color=#999AAA >
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。
</font> 
<ul>
<li>示例 1：<br />
输入：s = “Hello World”<br />
输出：5<br />
解释：最后一个单词是“World”，长度为5。</li>
<li>示例 2：<br />
输入：s = &quot;   fly me   to   the moon  &quot;<br />
输出：4<br />
解释：最后一个单词是“moon”，长度为4。</li>
<li>示例 3：<br />
输入：s = “luffy is still joyboy”<br />
输出：6<br />
解释：最后一个单词是长度为6的“joyboy”。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/length-of-last-word">https://leetcode-cn.com/problems/length-of-last-word</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力遍历"><a class="markdownIt-Anchor" href="#暴力遍历"></a> 暴力遍历</h2>
<p>从最后一位开始找起，当该位上字符不为空格时，开始计数，等到找到边界时，返回找到的不为空格的字符数。这里的边界可能是字符串的开头，也有可能是字符串中间的某个位置，即该字符不为空格，而前一个字符为空格，即为边界。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count ++;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> == <span class="number">-1</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> count;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4626a0f21a4d4004b64f278109f84268.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 53 最大子数组和</title>
    <url>/2022/04/05/LeetCode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">动态规划</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
</font> 
<font color=#999AAA >
子数组 是数组中的一个连续部分。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]<br />
输出：6<br />
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</li>
<li>示例 2：<br />
输入：nums = [1]<br />
输出：1</li>
<li>示例 3：<br />
输入：nums = [5,4,-1,7,8]<br />
输出：23</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/maximum-subarray">https://leetcode-cn.com/problems/maximum-subarray</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="动态规划"><a class="markdownIt-Anchor" href="#动态规划"></a> 动态规划</h2>
<p>从第一位开始，我们找以该元素为结尾的最大子数组和，然后找出所有这些子数组和中最大的即可。这个问题的关键就是要紧紧围绕这个元素展开，不论我们如何运算，比较的内容中一定要包含这个元素，因为现在的子目标是要找的是<strong>以该元素为结尾的最大子数组和</strong>，可以想到，可以比较前一子数组和加上当前元素与当前元素进行比较，取二者中较大的一个，公式如下：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>a</mi><mi>x</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(i)=max(f(i−1)+nums[i],nums[i])
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> maxSubSum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSubSum = <span class="built_in">max</span>(maxSubSum + nums[i], nums[i]);</span><br><span class="line">            res = <span class="built_in">max</span>(res, maxSubSum);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/f48544a31b8f4647bfd81476eb0fc87e.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 35 搜索插入位置</title>
    <url>/2022/04/05/LeetCode-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E4%BA%8C%E5%88%86%E6%B3%95">二分法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
</font> 
<font color=#999AAA >
请必须使用时间复杂度为 O(log n) 的算法。
</font> 
<ul>
<li>示例 1:<br />
输入: nums = [1,3,5,6], target = 5<br />
输出: 2</li>
<li>示例 2:<br />
输入: nums = [1,3,5,6], target = 2<br />
输出: 1</li>
<li>示例 3:<br />
输入: nums = [1,3,5,6], target = 7<br />
输出: 4</li>
<li>示例 4:<br />
输入: nums = [1,3,5,6], target = 0<br />
输出: 0</li>
<li>示例 5:<br />
输入: nums = [1], target = 0<br />
输出: 0</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/search-insert-position">https://leetcode-cn.com/problems/search-insert-position</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="二分法"><a class="markdownIt-Anchor" href="#二分法"></a> 二分法</h2>
<p>直接使用二分法的话，查找到的条件是目标值和数组中元素相等；但是这里题目中描述的是数组中可能不存在与目标值相等的元素，此时的操作是返回插入该元素的位置，所以可以略微修改二分查找的条件：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>≤</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo stretchy="false">[</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace><mi>l</mi><mi>e</mi><mi>f</mi><mi>t</mi><mo>&gt;</mo><mi>r</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">nums[right - 1] &lt; target \leq nums[right]\\
left &gt; right
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8304100000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span><span class="mclose">]</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">h</span><span class="mord mathdefault">t</span></span></span></span></span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> mid = ((right - left) &gt;&gt; <span class="number">1</span>) + left;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/5c34cef07cbe454d881c9888397ea254.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：数组二分，复杂度为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>，也符合题目要求<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 28 实现strStr()</title>
    <url>/2022/04/05/LeetCode-28-%E5%AE%9E%E7%8E%B0strStr/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D">暴力匹配</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
实现 strStr() 函数。
</font> 
<font color=#999AAA >
给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回  -1 。
</font> 
<font color=#999AAA >
说明：
</font> 
<font color=#999AAA >
当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。
</font> 
<font color=#999AAA >
对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。
</font> 
<ul>
<li>示例 1：<br />
输入：haystack = “hello”, needle = “ll”<br />
输出：2</li>
<li>示例 2：<br />
输入：haystack = “aaaaa”, needle = “bba”<br />
输出：-1</li>
<li>示例 3：<br />
输入：haystack = “”, needle = “”<br />
输出：0</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/implement-strstr">https://leetcode-cn.com/problems/implement-strstr</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力匹配"><a class="markdownIt-Anchor" href="#暴力匹配"></a> 暴力匹配</h2>
<p>匹配的实质是找出长字符串中的短字符串部分，所以可以枚举所有长字符串中的长度为短字符串长度的子字符串与短字符串进行匹配，如果匹配结果合适，则返回首字符下标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lenHay = haystack.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> lenNeedle = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (lenNeedle == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; lenHay - lenNeedle + <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; i + j &lt; lenHay &amp;&amp; j &lt; lenNeedle; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (haystack[i + j] != needle[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j == lenNeedle - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/424b30b4772740d295f4c50a80d67ffe.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>×</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，极端情况下需要挨个对两个字符串进行匹配<br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 27 移除元素</title>
    <url>/2022/04/05/LeetCode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95">快慢指针解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
</font> 
<font color=#999AAA >
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
</font> 
<font color=#999AAA >
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [3,2,2,3], val = 3<br />
输出：2, nums = [2,2]<br />
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。</li>
<li>示例 2：<br />
输入：nums = [0,1,2,2,3,0,4,2], val = 2<br />
输出：5, nums = [0,1,4,0,3]<br />
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-element">https://leetcode-cn.com/problems/remove-element</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="快慢指针解法"><a class="markdownIt-Anchor" href="#快慢指针解法"></a> 快慢指针解法</h2>
<p>分别设定快慢指针，快指针进行数组的遍历，慢指针负责维护“不等于目标元素的元素的数组”。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> slowptr = <span class="number">-1</span>, quickptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; quickptr &lt; len; quickptr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[quickptr] != val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++slowptr] = nums[quickptr];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowptr + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/4c834f280a3545fe9dc9a45f5779603a.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 26 删除有序数组中的重复项</title>
    <url>/2022/04/05/LeetCode-26-%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E5%80%9F%E5%8A%A9%E8%BE%85%E5%8A%A9%E7%A9%BA%E9%97%B4">借助辅助空间</a></li>
<li><a href="#%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E8%A7%A3%E6%B3%95">快慢指针解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。
</font> 
<font color=#999AAA >
由于在某些语言中不能改变数组的长度，所以必须将结果放在数组nums的第一部分。更规范地说，如果在删除重复项之后有 k 个元素，那么 nums 的前 k 个元素应该保存最终结果。
</font> 
<font color=#999AAA >
将最终结果插入 nums 的前 k 个位置后返回 k 。
</font> 
<font color=#999AAA >
不要使用额外的空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
</font> 
<ul>
<li>示例 1：<br />
输入：nums = [1,1,2]<br />
输出：2, nums = [1,2,_]<br />
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</li>
<li>示例 2：<br />
输入：nums = [0,0,1,1,1,2,2,3,3,4]<br />
输出：5, nums = [0,1,2,3,4]<br />
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="借助辅助空间"><a class="markdownIt-Anchor" href="#借助辅助空间"></a> 借助辅助空间</h2>
<p>对数组中元素遍历，当当前元素与前一个元素不等时，则判断其为新元素，加入到辅助数组空间中，直到遍历数组结束。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = res;</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/642a1ed90cec498f9351b2905aabc413.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：申请了额外的数组空间，最大可能和原数组同样大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
<h2 id="快慢指针解法"><a class="markdownIt-Anchor" href="#快慢指针解法"></a> 快慢指针解法</h2>
<p>分别设定快慢指针，快指针进行数组的遍历，寻找“新元素”，而慢指针负责将不同的元素存储起来，即当快指针找到一个不同的元素时，将其覆盖掉慢指针指向元素的后一位，这样就相当于利用慢指针在维护一个无重复项的数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> len;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> slowPtr = <span class="number">0</span>, quickPtr = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; quickPtr &lt; len; quickPtr++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[quickPtr] != nums[quickPtr<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[++slowPtr] = nums[quickPtr];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slowPtr + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/321f3940a5044a20abdd8c79480d81e0.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>快慢指针</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 21 合并两个有序链表</title>
    <url>/2022/04/05/LeetCode-21-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E9%93%BE%E8%A1%A8%E9%A1%BA%E5%BA%8F%E6%9E%9A%E4%B8%BE">链表顺序枚举</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E8%A7%A3%E6%B3%95">递归解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 
</font> 
<ul>
<li>示例 1：<br />
输入：l1 = [1,2,4], l2 = [1,3,4]<br />
输出：[1,1,2,3,4,4]</li>
<li>示例 2：<br />
输入：l1 = [], l2 = []<br />
输出：[]</li>
<li>示例 3：<br />
输入：l1 = [], l2 = [0]<br />
输出：[0]</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">https://leetcode-cn.com/problems/merge-two-sorted-lists</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="链表顺序枚举"><a class="markdownIt-Anchor" href="#链表顺序枚举"></a> 链表顺序枚举</h2>
<p>按顺序对两链表的当前node进行数值的比对，符合条件者入新链表，并找该node的next继续进行这个比对操作，直到其中一个链表到头。此时将未遍历完的链接合到已有链上即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        ListNode* curr = preHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                curr-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                curr-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        curr-&gt; next = list1 == <span class="literal">nullptr</span> ? list2:list1;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/54473df4dc834d8aa6d5db8b27be7a3b.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历两链表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="递归解法"><a class="markdownIt-Anchor" href="#递归解法"></a> 递归解法</h2>
<p>递归的理解是，求两个链表的合并，即是每个节点后接上该节点的后续链和另外一条链的合并。递归终止条件是其中一条链为空，此时返回另外一条链。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists</span>(list1-&gt;next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists</span>(list1, list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/206ec42b1aed4076b61fb7397c69e982.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历两链表<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span><br />
空间复杂度： <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo separator="true">,</mo><mi>m</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(min(n,m))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n+m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，需要用到函数堆栈，容量与两链表的长度相关，最小函数堆栈为两个链表中较短的那一条的大小，最大即需要一直将所有节点都遍历一遍，此时函数堆栈大小为n+m。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 20 有效的括号</title>
    <url>/2022/04/05/LeetCode-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
</font>
<font color=#999AAA >
有效字符串需满足：
</font>
<font color=#999AAA >
左括号必须用相同类型的右括号闭合。
</font>
<font color=#999AAA >
左括号必须以正确的顺序闭合。
</font> 
<ul>
<li>示例 1：<br />
输入：s = “()”<br />
输出：true</li>
<li>示例 2：<br />
输入：s = “()[]{}”<br />
输出：true</li>
<li>示例 3：<br />
输入：s = “(]”<br />
输出：false</li>
<li>示例 4：<br />
输入：s = “([)]”<br />
输出：false</li>
<li>示例 5：<br />
输入：s = “{[]}”<br />
输出：true</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>可以利用一个栈结构来进行括号的存储，即遍历字符串，在遇到左括号（不论是哪一个），都进栈处理，而一旦遇到右括号，就和栈顶进行比对，不匹配说明不符合要求，则返回false，匹配的话则进行出栈，再继续进行判断。</p>
<p>值得注意的是这里的第二的条件“左括号必须以正确的顺序闭合”，即当遍历遇到右括号时，此时栈顶必须得是相应左括号才行，否则就不可能是以正确得顺序闭合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; sta;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sta.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (sta.<span class="built_in">empty</span>() || !<span class="built_in">isParaMatch</span>(sta.<span class="built_in">top</span>(), s[i])) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sta.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sta.<span class="built_in">empty</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isParaMatch</span><span class="params">(<span class="type">char</span> l, <span class="type">char</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> r == <span class="string">&#x27;]&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/2840a078c7a54fa69b822586adb95020.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组及字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，即栈的可能最大长度</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 14 最长公共前缀</title>
    <url>/2022/04/05/LeetCode-14-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
编写一个函数来查找字符串数组中的最长公共前缀。
</font>
<font color=#999AAA >
如果不存在公共前缀，返回空字符串 ""。
</font>
<ul>
<li>示例 1：<br />
输入：strs = [“flower”,“flow”,“flight”]<br />
输出：“fl”</li>
<li>示例 2：<br />
输入：strs = [“dog”,“racecar”,“car”]<br />
输出：&quot;&quot;<br />
解释：输入不存在公共前缀。</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/longest-common-prefix">https://leetcode-cn.com/problems/longest-common-prefix</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>可以实现一个方法在两个字符串间寻找最长公共前缀，即按位比较，直到不一致时跳出，即可得到最长公共前缀。然后用这个得到的串再和数组内其他的字符串求最长公共前缀，直到遍历数组结束。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (strs.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = strs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; strs.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res = <span class="built_in">getCommonPrefix</span>(res, strs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">getCommonPrefix</span><span class="params">(string str00, string str01)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len00 = str00.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len01 = str01.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len = len00 &lt;= len01 ? len00 : len01;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str00[i] == str01[i])</span><br><span class="line">            &#123;</span><br><span class="line">                res += str00[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/91d589b02e9d4f44a61d3e3f4ea709ac.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组及字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(mn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，m表示单个字符串长度，n表示数组大小<br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mclose">)</span></span></span></span>，借助了临时字符串作存储</p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 13 罗马数字转整数</title>
    <url>/2022/04/05/LeetCode-13-%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p></p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。
</font>
<table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:center">数值</th>
</tr>
</thead>
<tbody>
<tr>
<td>I</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>V</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>X</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td>L</td>
<td style="text-align:center">50</td>
</tr>
<tr>
<td>C</td>
<td style="text-align:center">100</td>
</tr>
<tr>
<td>D</td>
<td style="text-align:center">500</td>
</tr>
<tr>
<td>M</td>
<td style="text-align:center">1000</td>
</tr>
</tbody>
</table>
  <font color=#999AAA >
  例如， 罗马数字 2 写做 II ，即为两个并列的 1 。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。
  </font>
<font color=#999AAA >
通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：
</font>
<font color=#999AAA >
I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
</font>
<font color=#999AAA >
X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
</font>
<font color=#999AAA >
C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。
</font>
<font color=#999AAA >
给定一个罗马数字，将其转换成整数。
</font>
<ul>
<li>示例 1:<br />
输入: s = “III”<br />
输出: 3</li>
<li>示例 2:<br />
输入: s = “IV”<br />
输出: 4</li>
<li>示例 3:<br />
输入: s = “IX”<br />
输出: 9</li>
<li>示例 4:<br />
输入: s = “LVIII”<br />
输出: 58<br />
解释: L = 50, V= 5, III = 3.</li>
<li>示例 5:<br />
输入: s = “MCMXCIV”<br />
输出: 1994<br />
解释: M = 1000, CM = 900, XC = 90, IV = 4.</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/roman-to-integer">https://leetcode-cn.com/problems/roman-to-integer</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<p>除了特殊情况以外（4，9，40，90等），这里的核心其实就是累加，如VII，就是5+1+1 = 7，即可以通过遍历字符串来将每个字符对应的值找到并累加。其实可以将特殊情况也用这样的方法的看，比如IV，就是在找到字符对应的值的时候，与后一位（如果存在的话）的对应的值进行比较，如果小于的话，那么就可以将该位上的值取反，即-1 + 5 = 4。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="built_in">getSingleInt</span>(s[i]);</span><br><span class="line">            <span class="keyword">if</span> (i+<span class="number">1</span> &lt; len &amp;&amp; temp &lt; <span class="built_in">getSingleInt</span>(s[i+<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                temp = <span class="number">0</span> - temp;</span><br><span class="line">            &#125;</span><br><span class="line">            res += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSingleInt</span><span class="params">(<span class="type">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">500</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/6e92fbab0fe049ce90a949a95723c496.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历字符串 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 9 回文数</title>
    <url>/2022/04/05/LeetCode-9-%E5%9B%9E%E6%96%87%E6%95%B0/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95">暴力解法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。
</font>
<font color=#999AAA >
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。
</font>
<ul>
<li>示例 1：<br />
输入：x = 121<br />
输出：true</li>
<li>示例 2：<br />
输入：x = -121<br />
输出：false<br />
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</li>
<li>示例 3：<br />
输入：x = 10<br />
输出：false<br />
解释：从右向左读, 为 01 。因此它不是一个回文数。</li>
<li>示例 4：<br />
输入：x = -101<br />
输出：false</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/palindrome-number">https://leetcode-cn.com/problems/palindrome-number</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力解法"><a class="markdownIt-Anchor" href="#暴力解法"></a> 暴力解法</h2>
<p>将各位上的数字依次输出，然后按照顺序进行比对。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arrPalindrome;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (x%<span class="number">10</span> != <span class="number">0</span> || x/<span class="number">10</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> temp = x%<span class="number">10</span>;</span><br><span class="line">            x = x/<span class="number">10</span>;</span><br><span class="line">            arrPalindrome.<span class="built_in">push_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> len = arrPalindrome.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len/<span class="number">2</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arrPalindrome[i] != arrPalindrome[len <span class="number">-1</span> - i])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/abb8239a33f54bd7875a5f50b3dfc52c.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn + \frac{1}{2}logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span><br />
空间复杂度：开辟辅助数组所出现的消耗，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(logn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></p>
]]></content>
      <categories>
        <category>LeetCode</category>
        <category>简单</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 1 两数之和</title>
    <url>/2022/04/04/LeetCode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%9A%B4%E5%8A%9B%E6%9E%9A%E4%B8%BE">暴力枚举</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E4%BC%98%E5%8C%96%E5%81%9A%E6%B3%95">基于哈希表的优化做法</a></li>
</ul>
</p>
<span id="more"></span>
<h1 id="题目要求"><a class="markdownIt-Anchor" href="#题目要求"></a> 题目要求</h1>
<font color=#999AAA >
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值 target  的那两个整数，并返回它们的数组下标。
</font>
<font color=#999AAA >
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。
</font>
<ul>
<li>
<p>示例 1：<br />
输入：nums = [2,7,11,15], target = 9<br />
输出：[0,1]<br />
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p>
</li>
<li>
<p>示例 2：<br />
输入：nums = [3,2,4], target = 6<br />
输出：[1,2]</p>
</li>
<li>
<p>示例 3：<br />
输入：nums = [3,3], target = 6<br />
输出：[0,1]</p>
</li>
</ul>
<p>来源：力扣（LeetCode）<br />
链接：<a href="https://leetcode-cn.com/problems/two-sum">https://leetcode-cn.com/problems/two-sum</a><br />
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">
<h1 id="解法"><a class="markdownIt-Anchor" href="#解法"></a> 解法</h1>
<h2 id="暴力枚举"><a class="markdownIt-Anchor" href="#暴力枚举"></a> 暴力枚举</h2>
<p>按照下标从小往大的顺序，将数组中任意两数两两组合，以枚举出所有的可能性，从而检查两数字之和是否与目标值相等。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/50fc18cd45ff4f3ba2a3ac31c487e401.png" alt="在这里插入图片描述" /><br />
复杂度分析<br />
时间复杂度：最坏情况下（符合要求两数字的下标位于数组的末尾），<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span><br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></p>
<h2 id="基于哈希表的优化做法"><a class="markdownIt-Anchor" href="#基于哈希表的优化做法"></a> 基于哈希表的优化做法</h2>
<p>利用哈希表的特性（查找快速），在遍历数组的同时，检查每个元素达成目标值所需要的另一元素是否存在于哈希表中，从而实现在遍历一遍数组的前提下，就能够找出符合要求的两个数组元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; hashMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            unordered_map &lt;<span class="type">int</span>, <span class="type">int</span>&gt;::const_iterator iter = hashMap.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (iter != hashMap.<span class="built_in">end</span>()) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, iter-&gt;second&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashMap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/1e538207d91a4d198ab33ad1e016203f.png" alt="在这里插入图片描述" /></p>
<p>复杂度分析<br />
时间复杂度：遍历数组 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，对每个元素需要以 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 的代价来判断是否存在另一个元素<br />
空间复杂度：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，主要是用来开辟哈希表空间</p>
<hr style=" border:solid; width:100px; height:1px;" color=#000000 size=1">]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>C++</tag>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 纹理的处理（Texturing）</title>
    <url>/2022/03/30/%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BA%B9%E7%90%86%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%88Texturing%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 着色基础（Shading Basics）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%9D%80%E8%89%B2%E5%9F%BA%E7%A1%80%EF%BC%88Shading-Basics%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 变换（Transforms）</title>
    <url>/2022/03/30/%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%98%E6%8D%A2%EF%BC%88Transforms%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 图形处理单元（The Graphics Processing Unit）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E5%A4%84%E7%90%86%E5%8D%95%E5%85%83%EF%BC%88The-Graphics-Processing-Unit%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 图形渲染管线（The Graphics Rendering Pipeline）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BF%EF%BC%88The-Graphics-Rendering-Pipeline%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>default</category>
      </categories>
      <tags>
        <tag>default</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章 介绍（Introduction）</title>
    <url>/2022/03/30/%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BB%8B%E7%BB%8D%EF%BC%88Introduction%EF%BC%89/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>渲染</category>
        <category>Real-Time Rendering 4th Edition 读书与翻译</category>
      </categories>
      <tags>
        <tag>渲染管线</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>快速建站方案（hexo + next）全面记录</title>
    <url>/2022/03/23/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>本文记录了笔者在搭建 <a href="https://claude-jhin.github.io">个人博客网站</a> 时所经历的过程，包含整个流程和中间遇到的一些麻烦。<br />
这里记录下来，作为自己一个阶段对网站开发学习的总结，并且如果能够帮助或者启发更多的人，也将不胜荣幸。<br />
当然，笔者并不是专业的前端开发人员，前端开发只是作为工具而去粗浅的使用，所以在一些细节上难以尽善尽美。</p>
<span id="more"></span>
<p>本文仅是对工具浮于表面的粗浅使用，更多的信息还是请参考备注的各种官方链接。</p>
<h3 id="hexo简介"><a class="markdownIt-Anchor" href="#hexo简介"></a> Hexo简介</h3>
<p>依据 <a href="https://hexo.io/zh-cn">Hexo中文官网</a> 中的介绍，Hexo是一个快速、简洁且高效的博客框架。<br />
最直观的，在这套框架的帮助下，我们可以很快的通过markdown来完成一篇又一篇博客的编辑。<br />
此外，Hexo也是可扩展的，在各种各样插件的帮助下，可以实现多种多样的前端效果。</p>
<h3 id="next简介"><a class="markdownIt-Anchor" href="#next简介"></a> next简介</h3>
<p>next是Hexo丰富多彩的主题中比较受欢迎的一个，其本身是一个 <a href="https://github.com/next-theme/hexo-theme-next">开源的项目</a> 到现在一直在不断得推出新的版本。</p>
<p>如果说Hexo是对前端开发的简化和封装，那么next就是对hexo框架允许内的前端效果的封装。<br />
在这两者的帮助下，降低了开发难度，让使用者可以仅仅通过简单的配置就可以拥有和维护属于自己的博客网站。</p>
<h2 id="本地基础开发环境准备"><a class="markdownIt-Anchor" href="#本地基础开发环境准备"></a> 本地基础开发环境准备</h2>
<ul>
<li><a href="https://nodejs.org/">Node.js</a></li>
</ul>
<p>下载后依据导航安装即可，推荐下载长期支持版（LTS）。</p>
<ul>
<li><a href="https://git-scm.com/">Git</a></li>
</ul>
<p>下载后依据导航安装即可，Git安装过程中会有很多的配置选项，如果有特定需求的话（了解其各个配置选项的含义）可以按需配置，否则就按照推荐选项进行安装即可。</p>
<p>安装完成后，右键的下拉菜单中就会出现Git相关的功能选项。</p>
<p><img src="./%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_rightclick.png" alt="" /></p>
<h2 id="hexo环境搭建"><a class="markdownIt-Anchor" href="#hexo环境搭建"></a> hexo环境搭建</h2>
<p>在基本环境准备完成后，即可开始hexo相关的下载和安装。</p>
<p>在预先准备好的文件夹下（如 E:/Blog/），右键打开下拉菜单，点击Git Bash Here，输入下面的命令后点击回车键：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>如图：</p>
<p><img src="./%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_gitbush.png" alt="" /></p>
<p>完成后，再执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<p>完成后，对应文件夹中出现内容，目录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure>
<p>以上各文件各有作用，和我们博客最后的表现息息相关，在具体配置和使用时我们再做详细介绍。</p>
<p>最后执行以下命令完成配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
<p>在等待上述命令执行完成后，可以在命令行键入以下命令启动hexo服务器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>此时，本地服务启动成功，可以在浏览器中键入<code>http://localhost:4000/</code> 来尝试访问默认的博客模板，<br />
出现以下页面即表示着前面的安装过程没有出现问题：</p>
<p><img src="./%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_defaultpage.png" alt="" /></p>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>在文件夹中找到 <code>_config.yml</code> 文件，该文件即是博客的主要配置文件，其中包含了绝大部分关于网站的我们可以自定义的部分。</p>
<p>预想要完成博客的个性化定制，需要对该文件各个部分的配置内容有个大概的了解。这里罗列一些核心部分，剩余部分的配置建议参考 <a href="https://hexo.io/zh-cn/docs/configuration">官方网站的内容</a> 。</p>
<p>当然，如果对美观和个性化没有需求的话，这一小节可以暂时先掠过，先进行后面的阅读。</p>
<h3 id="site"><a class="markdownIt-Anchor" href="#site"></a> Site</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Site</span><br><span class="line">title: </span><br><span class="line">subtitle: </span><br><span class="line">description: </span><br><span class="line">keywords: </span><br><span class="line">author: </span><br><span class="line">language: </span><br><span class="line">timezone: </span><br></pre></td></tr></table></figure>
<p>这里是网站的一些主要属性的配置，其中各项代表的含义为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">网站标题</td>
</tr>
<tr>
<td style="text-align:center">subtitle</td>
<td style="text-align:center">网站副标题</td>
</tr>
<tr>
<td style="text-align:center">description</td>
<td style="text-align:center">网站描述</td>
</tr>
<tr>
<td style="text-align:center">keywords</td>
<td style="text-align:center">网站的关键词。支持多个关键词。</td>
</tr>
<tr>
<td style="text-align:center">author</td>
<td style="text-align:center">您的名字</td>
</tr>
<tr>
<td style="text-align:center">language</td>
<td style="text-align:center">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。</td>
</tr>
<tr>
<td style="text-align:center">timezone</td>
<td style="text-align:center">网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。</td>
</tr>
</tbody>
</table>
<h3 id="url"><a class="markdownIt-Anchor" href="#url"></a> URL</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: https://claude-jhin.github.io/</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line">pretty_urls:</span><br><span class="line">  trailing_index: true # Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span><br><span class="line">  trailing_html: true # Set to false to remove trailing &#x27;.html&#x27; from permalinks</span><br></pre></td></tr></table></figure>
<p>这里是关于网站url的一些配置相关的内容，主要作用是对url进行美化。</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">url</td>
<td style="text-align:center">后键入自己准备好的域名，我这里使用的是github提供的免费域名。</td>
</tr>
<tr>
<td style="text-align:center">permalink</td>
<td style="text-align:center">表示的是每一个我们编辑的markdown博客文件应该是以什么样子的域名来显示的，默认是以年+月+日+文章名字的形式。</td>
</tr>
<tr>
<td style="text-align:center">permalink_defaults</td>
<td style="text-align:center">是对permalink给出一个默认值。</td>
</tr>
<tr>
<td style="text-align:center">trailing_index</td>
<td style="text-align:center">是否为博客文件保留<code>index.html</code> 的后缀</td>
</tr>
<tr>
<td style="text-align:center">trailing_html</td>
<td style="text-align:center">是否为博客文件保留<code>.html</code> 的后缀</td>
</tr>
</tbody>
</table>
<h3 id="home-page-setting"><a class="markdownIt-Anchor" href="#home-page-setting"></a> Home page setting</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Home page setting</span><br><span class="line"># path: Root path for your blogs index page. (default = &#x27;&#x27;) 博客索引页的根目录</span><br><span class="line"># per_page: Posts displayed per page. (0 = disable pagination) 每一页显示的文章数量</span><br><span class="line"># order_by: Posts order. (Order by date descending by default) 文章的排序方式</span><br><span class="line">index_generator:</span><br><span class="line">path: &#x27;&#x27;</span><br><span class="line">per_page: 10</span><br><span class="line">order_by: -date</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">path</td>
<td style="text-align:center">博客索引页的根目录</td>
</tr>
<tr>
<td style="text-align:center">per_page</td>
<td style="text-align:center">每一页显示的文章数量</td>
</tr>
<tr>
<td style="text-align:center">order_by</td>
<td style="text-align:center">文章的排序方式</td>
</tr>
</tbody>
</table>
<h3 id="extension"><a class="markdownIt-Anchor" href="#extension"></a> Extension</h3>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">theme</td>
<td style="text-align:center">所选择的主题，主题下载后保存在根目录的themes文件夹下，通过这里指定加载的主题。</td>
</tr>
</tbody>
</table>
<h2 id="写作"><a class="markdownIt-Anchor" href="#写作"></a> 写作</h2>
<h3 id="创建文章"><a class="markdownIt-Anchor" href="#创建文章"></a> 创建文章</h3>
<p>新建文章的指令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>其中 [layout] 默认有：</p>
<table>
<thead>
<tr>
<th style="text-align:center">布局</th>
<th style="text-align:center">路径</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">post</td>
<td style="text-align:center">source/_posts</td>
</tr>
<tr>
<td style="text-align:center">page</td>
<td style="text-align:center">source</td>
</tr>
<tr>
<td style="text-align:center">draft</td>
<td style="text-align:center">source/_drafts</td>
</tr>
</tbody>
</table>
<p>在创建这三种不同类型的文件时，它们将会被保存到不同的路径。但是默认来说我们基本只需要用到post，即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new post &quot;文章名字&quot;</span><br></pre></td></tr></table></figure>
<p>执行上面命令后，在source/_posts文件夹下就会生成对应的md文件，按照md格式进行文档的编辑即可。</p>
<p>截取本文的编辑界面如下：</p>
<p><img src="./%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_content.png" alt="" /></p>
<h3 id="配置文章属性front-matter"><a class="markdownIt-Anchor" href="#配置文章属性front-matter"></a> 配置文章属性（Front-matter）</h3>
<p>与博客一样，每篇文章除了内容以外，还有自己的属性，如建立时间、更行时间、分类和标签等。</p>
<p>博客模板会利用这些属性来自动实现一些高级的功能，如显示博客文章时间戳，按照分类来讲文章进行归档等。<br />
post模板会自动帮助我们创建出title，date和tags，此外还有一些其他内容，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">title</td>
<td style="text-align:center">标题</td>
</tr>
<tr>
<td style="text-align:center">date</td>
<td style="text-align:center">文件建立日期</td>
</tr>
<tr>
<td style="text-align:center">updated</td>
<td style="text-align:center">更新日期	文件更新日期</td>
</tr>
<tr>
<td style="text-align:center">comments</td>
<td style="text-align:center">开启文章的评论功能（true/false）</td>
</tr>
<tr>
<td style="text-align:center">tags</td>
<td style="text-align:center">标签（不适用于分页）</td>
</tr>
<tr>
<td style="text-align:center">categories</td>
<td style="text-align:center">分类（不适用于分页）</td>
</tr>
</tbody>
</table>
<p>如本文的Front-matter：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title: 快速建站方案（hexo + next）全面记录</span><br><span class="line">date: 2022-03-23 21:35:53</span><br><span class="line">updated: 2022-03-24 20:00:00</span><br><span class="line">comments: true</span><br><span class="line">tags:</span><br><span class="line">  - 前端</span><br><span class="line">categories: </span><br><span class="line">  - hexo</span><br></pre></td></tr></table></figure>
<h2 id="next主题"><a class="markdownIt-Anchor" href="#next主题"></a> next主题</h2>
<h3 id="主题下载与加载"><a class="markdownIt-Anchor" href="#主题下载与加载"></a> 主题下载与加载</h3>
<p>在hexoblog文件夹下打开命令行，键入并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>等待完成后，有：</p>
<p><img src="./%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_nextexplorer.png" alt="" /></p>
<p>在hexoblog下的_config.yml里配置theme即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<h3 id="预览"><a class="markdownIt-Anchor" href="#预览"></a> 预览</h3>
<p>在hexoblog文件夹下打开命令行，键入并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>有：</p>
<p>![](./快速建站全面记录/快速建站全面记录_hexo s.png)</p>
<p>此时就可以在浏览器中用 <code>http://localhost:4000/</code> 的地址来进行访问了。</p>
<p><img src="./%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_localhost.png" alt="" /></p>
<p>但是注意，此时我们只是开启了一个本地服务，就是说，只能在我们开启服务时，在本地机器上进行访问，还没有发布到网络上供别人来查看。</p>
<h2 id="github-page准备"><a class="markdownIt-Anchor" href="#github-page准备"></a> github page准备</h2>
<p>在github上新建一个仓库，进入到 <code>General/Code and automation/Pages</code> 配置界面：</p>
<p><img src="./%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95/%E5%BF%AB%E9%80%9F%E5%BB%BA%E7%AB%99%E5%85%A8%E9%9D%A2%E8%AE%B0%E5%BD%95_githubpage.png" alt="" /></p>
<p>这里顺便需要去设置界面把SSH给配置了，方便后续的更新和维护，<a href="https://docs.github.com/cn/authentication/connecting-to-github-with-ssh">具体操作</a> ，这里不做过多赘述。</p>
<p>下面就是把之前做的内容推送到远程仓库里。</p>
<h2 id="发布"><a class="markdownIt-Anchor" href="#发布"></a> 发布</h2>
<p>回到hexoblog文件夹下的_config.yml，将远程仓库相关内容键入（注意这里使用的是SSH地址）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/one-command-deployment</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Github用户名/Github用户名全小写.github.io.git</span><br><span class="line">  branch: main</span><br></pre></td></tr></table></figure>
<p>在hexoblog打开命令行，键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>生成静态页面内容后，再键入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>如果是第一次的话，可能过程中还要填写github的用户名和密码，按导航完成即可。</p>
<p>等待完成后，过一段时间（取决于github的处理），访问仓库地址（如<code>https://claude-jhin.github.io/</code> ），可以看到本地仓库已经发布到了网页。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>到此，基本上完成了从零开始的一个博客搭建，当然对于有心人来讲，事情远远还没有完成。<br />
一篇篇博客的积累，一点点前端特性的尝试与引入，学习的乐趣，开发的乐趣，远不止于此。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>frontend</tag>
      </tags>
  </entry>
</search>
